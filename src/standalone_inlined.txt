<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="__GAMETITLE__">
<title>__GAMETITLE__</title>
<style>
body {
	background-color:black;
	font-family:"Courier New", Courier, monospace
}

#gameCanvas {
  position:absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  bottom: 0px;
  right:0px;
  border: 0px;
  background-color: black;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  
} 

h1 {
	color:lightblue;
	font-weight:normal;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height:2em;
    margin-top:0.5em;
    margin-bottom: 0.5em;
}

a {
	color:lightblue;
}

.title {	
	background-color:none;
	text-align:center;
	font-size:100%;
	float:center;
	color:gray;
	position:absolute;
	left:10%;
	right:10%;
	top:0%;
	height:10%;
}

.footer {	
	background-color:none;
	text-align:center;
	float:center;
	color:white;
	position:absolute;
	margin-top:10px;
	left:10%;
	right:10%;
	top:90%;
	bottom:10%;
}
.gameContainer {
	background-color:none;
	position:absolute;
	left:10%;
	right:10%;
	top:70px;
	bottom:70px;
    touch-action: none;
}

.mobile-menu {
    position: relative;
    top: 4em;
    margin-left: auto;
    margin-right: auto;
    font-weight: bold;
    border-radius: 0.25em;
}

.mobile-menu.item-count-3 {
    width: 30em;
}
.mobile-menu.item-count-3 .button {
    width: 28.3333%;
    /* scale the height of the button relative to the width of .mobile-menu */
    padding: 7.5% 0%;
}

.mobile-menu.item-count-2 {
    width: 20em;
}
.mobile-menu.item-count-2 .button {
    width: 46%;
    /* scale the height of the button relative to the width of .mobile-menu */
    padding: 12.1765% 0%;
}

.mobile-menu.item-count-1 {
    width: 10em;
}
.mobile-menu.item-count-1 .button {
    width: 98%;
    /* scale the height of the button relative to the width of .mobile-menu */
    padding: 26.5% 0%;
}

.mobile-menu,
.tab-icon,
.mobile-menu .close {
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(255, 255, 255, 0.4);
    color: rgba(255, 255, 255, 1);
}

.mobile-menu .button {
    margin: 2%;
    border-radius: 0.25em;
    text-align: center;
    float: left;
}
.mobile-menu .clear {
    clear: both;
}

.tab-affordance,
.close-affordance {
    width: 6em;
    height: 6em;
    position: absolute;
    z-index: 1000;
}

.tab-affordance {
    left: -2em;
    top: 55px;
}

.close-affordance {
    left: -4em;
    top: -1em;
}

.tab-icon,
.mobile-menu .close {
    height: 48px;
    position: absolute;
    border-radius: 6px;
}

.tab-icon {
    left: -0.5em;
    top: 70px;
    width: 18px;
    border-radius: 0 6px 6px 0;
    border-left: 0;
}

.mobile-menu .close {
    left: -18px;
    width: 18px;
    top: 0px;
    border-radius: 6px 0 0 6px;
    border-right: 0;
}

.tab-icon .slice,
.mobile-menu .close .slice {
    margin: 4.5px 1px;
    width: 2px;
    height: 80%;
    background: rgba(255, 255, 255, 0.4);
}

.tab-icon .slice {
    float: right;
}

.tab-icon .slice:first-child {
    margin-right: 4.5px;
}

.mobile-menu .close .slice {
    float: left;
}
.mobile-menu .close .slice:first-child {
    margin-left: 4.5px;
}

@media screen and (max-width: 32em) {
    .mobile-menu {
        font-size: 0.8em;
        width: 90%;
    }
}
@media screen and (max-width: 24em) {
    .mobile-menu {
        font-size: 0.65em;
        width: 90%;
    }
}

.disable-select {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
</style>
<style>

body {
	background-color:___BGCOLOR___;
	font-family:"Courier New", Courier, monospace;
    touch-action: none;
}
#gameCanvas {
  position:absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  bottom: 0px;
  right:0px;
  border: 0px;
  background-color: ___BGCOLOR___; 
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
} 

.homepagelink {
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50%;
}

h1 {
	color:___TEXTCOLOR___;
	font-weight:normal;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height:2em;
    margin-top:0.5em;
    margin-bottom: 0.5em;
}
a {
	color:___TEXTCOLOR___;
}
.title {	
	background-color:none;
	text-align:center;
	font-size:100%;
	float:center;
	color:gray;
	position:absolute;
	left:10%;
	right:10%;
	top:0%;
	height:3em;
}

.footer {	
	background-color:none;
	text-align:center;
	float:center;
	color:white;
	position:absolute;
	left:0%;
	right:0%;
	height:3em;
	bottom:0;
}
.gameContainer {
	background-color:none;
	position:absolute;
	left:0%;
	right:0%;
	top:3.5em;
	bottom:3em;
  touch-action: none;
}

  .mobile-menu {
      position: relative;
      top: 5em;
      margin-left: auto;
      margin-right: auto;
      font-weight: bold;
      border-radius: 0.25em;
  }

  .mobile-menu.item-count-3 {
      width: 30em;
  }
  .mobile-menu.item-count-3 .button {
      width: 28.3333%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 7.5% 0%;
  }

  .mobile-menu.item-count-2 {
      width: 20em;
  }
  .mobile-menu.item-count-2 .button {
      width: 46%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 12.1765% 0%;
  }

  .mobile-menu.item-count-1 {
      width: 10em;
  }
  .mobile-menu.item-count-1 .button {
      width: 98%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 26.5% 0%;
  }

  .mobile-menu,
  .tab-icon,
  .mobile-menu .close {
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 1);
  }

  .mobile-menu .button {
      margin: 2%;
      border-radius: 0.25em;
      text-align: center;
      float: left;
  }
  .mobile-menu .clear {
      clear: both;
  }

  .tab-affordance,
  .close-affordance {
      width: 6em;
      height: 6em;
      position: absolute;
      z-index: 1000;
  }

  .tab-affordance {
      left: -2em;
      top: 5em;
  }

  .close-affordance {
      left: -4em;
      top: -1em;
  }

  .tab-icon,
  .mobile-menu .close {
      height: 48px;
      position: absolute;
      border-radius: 6px;
  }

  .tab-icon {
      left: -0.5em;
      top: 70px;
      width: 18px;
      border-radius: 0 6px 6px 0;
      border-left: 0;
  }

  .mobile-menu .close {
      left: -18px;
      width: 18px;
      top: 0px;
      border-radius: 6px 0 0 6px;
      border-right: 0;
  }

  .tab-icon .slice,
  .mobile-menu .close .slice {
      margin: 4.5px 1px;
      width: 2px;
      height: 80%;
      background: rgba(255, 255, 255, 0.4);
  }

  .tab-icon .slice {
      float: right;
  }

  .tab-icon .slice:first-child {
       margin-right: 4.5px;
  }

  .mobile-menu .close .slice {
      float: left;
  }
  .mobile-menu .close .slice:first-child {
       margin-left: 4.5px;
  }

  @media screen and (max-width: 32em) {
      .mobile-menu {
          font-size: 0.8em;
          width: 90%;
      }
  }
  @media screen and (max-width: 24em) {
      .mobile-menu {
          font-size: 0.65em;
          width: 90%;
      }
  }

 .disable-select {
     -webkit-touch-callout: none;
     -webkit-user-select: none;
     -khtml-user-select: none;
     -moz-user-select: none;
     -ms-user-select: none;
     user-select: none;
 }

a {
    display:inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80%;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>
<body>
<div class="title"><h1 id="gametitle">__GAMETITLE__</h1></div>
<div class="gameContainer">
<canvas 
    id="gameCanvas" ></canvas>
</div> 
<div class="footer">
<span id="errormessage" style="color:red;"></span>
<a id="homepagelink" href="__HOMEPAGE__" target="_blank">__HOMEPAGE_STRIPPED_PROTOCOL__</a>
</div>
</div>
<script>
	if (window.document.documentMode) {
		document.getElementById('errormessage').innerHTML = "Internet Explorer is not supported.<br>Consider updating to another browser.";
		//We can't really stop execution of the rest of the code here. Should crash soon enough.
	} 
</script>

<!--___SCRIPTINSERT___-->
<script>
function storage_has(key){
    const value = localStorage.getItem(key) != undefined;
    if (debugSwitch.includes('stor')) console.log(`Storage has key=${key} = ${value}.`);
    return value;
}

function storage_get(key){
    const value = localStorage.getItem(key);
    if (debugSwitch.includes('stor')) console.log(`Storage get key=${key} = "${value}".`);
    return value;
}

function storage_set(key, value){
    if (debugSwitch.includes('stor')) console.log(`Storage set key=${key} = "${value}".`);
    return localStorage.setItem(key,value);
}

function storage_remove(key){
    if (debugSwitch.includes('stor')) console.log(`Storage remove key=${key}.`);
    localStorage.removeItem(key);
}
</script>
<script>
var unitTesting=false;
let curLevelNo = 0;
var solvedSections = [];
var curlevelTarget=null;
var hasUsedCheckpoint=false;
var levelEditorOpened=false;
var muted=0;
var runrulesonlevelstart_phase=false;
var ignoreNotJustPressedAction=true;

var verbose_logging=false;
var throttle_movement=false;
var cache_console_messages=false;
var quittingTitleScreen=false;
var quittingMessageScreen=false;

var deltatime=17; // this gets updated every frame; see loop()
var timer=0;
var repeatinterval=150;
var autotick=0;
var autotickinterval=0;
var winning=false;
var againing=false;
var againinterval=150;
var norepeat_action=false;
var oldflickscreendat = [];//used for buffering old flickscreen/scrollscreen positions, in case player vanishes
var keybuffer = [];

var debugSwitch = '';
var showLayers = false;
var showLayerNo = 0;
var defaultDebugMode = false;
var defaultVerboseLogging = false;

var tweeninterval=0;
var tweentimer=0;
var isAnimating = false;    // true for any kind of animation/tweening that is not yet complete
var animateinterval=0;

var restarting=false;

var messageselected=false;

var textImages = {};
var initLevel = {};
var curLevel = initLevel;


</script>
<script>
solving = false;
var canSetHTMLColors=true;
var canDump=false;
var canOpenEditor=false;
var IDE=false;
const diffToVisualize=null;

function stripTags(str) {
	var div = document.createElement("div");
	div.innerHTML = str;
	var result = div.textContent || div.innerText || "";
	return result;
}

function consolePrint(linenumber,inspect_ID){
/*	var errorText = document.getElementById("errormessage");
	
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";*/
}

function consolePrintFromRule(str,rule,urgent){
/*	var errorText = document.getElementById("errormessage");
	
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";*/
}

function consoleCacheDump(str){
	
}

function consoleError(str,lineNumber){
	var errorText = document.getElementById("errormessage");
	if (errorText) {
		str=stripTags(str);
		errorText.innerHTML+=str+"<br>";
	} else {
		//No element available, log to console instead
		console.error(str, lineNumber)
	}
}

function logErrorNoLine(str){
	var errorText = document.getElementById("errormessage");
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";
}

function clearInputHistory() {}
function pushInput(inp) {}
function pushSoundToHistory(seed) {}

</script>
<script>

var font = {
    '0':`
00000
00000
00000
01110
10001
10011
10101
11001
10001
01110
00000
00000`,
	'1':`
00000
00000
00000
11100
00100
00100
00100
00100
00100
11111
00000
00000`,
	'2':`
00000
00000
00000
11110
00001
00001
01110
10000
10000
11111
00000
00000`,
	'3':`
00000
00000
00000
11110
00001
00110
00001
00001
00001
11110
00000
00000`,
	'4':`
00000
00000
00000
10000
10000
10000
10010
11111
00010
00010
00000
00000`,
	'5':`
00000
00000
00000
11111
10000
11110
00001
00001
00001
11110
00000
00000`,
	'6':`
00000
00000
00000
01110
10000
11110
10001
10001
10001
01110
00000
00000`,
	'7':`
00000
00000
00000
11111
00001
00010
00100
00100
00100
00100
00000
00000`,
	'8':`
00000
00000
00000
01110
10001
01110
10001
10001
10001
01110
00000
00000`,
	'9':`
00000
00000
00000
01110
10001
10001
10001
01111
00001
01110
00000
00000`,
	'a':`
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00000
00000`,
	'b':`
00000
00000
00000
10000
10000
11110
10001
10001
10001
01110
00000
00000`,
	'c':`
00000
00000
00000
00000
00000
01111
10000
10000
10000
01111
00000
00000`,
	'd':`
00000
00000
00000
00001
00001
01111
10001
10001
10001
01111
00000
00000`,
	'e':`
00000
00000
00000
00000
00000
01110
10001
11111
10000
01110
00000
00000`,
	'f':`
00000
00000
00000
00011
00100
11111
00100
00100
00100
00100
00000
00000`,
	'g':`
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00001
01110`,
	'h':`
00000
00000
00000
10000
10000
11110
10001
10001
10001
10001
00000
00000`,
	'i':`
00000
00000
00000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'j':`
00000
00000
00000
00100
00000
01100
00100
00100
00100
00100
10100
01000`,
	'k':`
00000
00000
00000
10000
10000
10001
10010
11100
10010
10001
00000
00000`,
	'l':`
00000
00000
00000
01100
00100
00100
00100
00100
00100
01110
00000
00000`,
	'm':`
00000
00000
00000
00000
00000
01010
10101
10101
10101
10101
00000
00000`,
	'n':`
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00000
00000`,
	'o':`
00000
00000
00000
00000
00000
01110
10001
10001
10001
01110
00000
00000`,
	'p':`
00000
00000
00000
00000
00000
11110
10001
10001
10001
11110
10000
10000`,
	'q':`
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00001
00001`,
	'r':`
00000
00000
00000
00000
00000
01111
10000
10000
10000
10000
00000
00000`,
	's':`
00000
00000
00000
00000
00000
01111
10000
01110
00001
11110
00000
00000`,
	't':`
00000
00000
00000
00100
00100
11111
00100
00100
00100
00011
00000
00000`,
	'u':`
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00000
00000`,
	'v':`
00000
00000
00000
00000
00000
10001
10010
10100
11000
10000
00000
00000`,
	'w':`
00000
00000
00000
00000
00000
10101
10101
10101
10101
01010
00000
00000`,
	'x':`
00000
00000
00000
00000
00000
10001
01010
00100
01010
10001
00000
00000`,
	'×':`
00000
00000
00000
00000
00000
10001
01010
00100
01010
10001
00000
00000`,
	'y':`
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00001
11110`,
	'z':`
00000
00000
00000
00000
00000
11111
00010
00100
01000
11111
00000
00000`,
	'A':`
00000
00000
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'B':`
00000
00000
00000
11110
10001
11110
10001
10001
10001
11110
00000
00000`,
	'C':`
00000
00000
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'D':`
00000
00000
00000
11110
10001
10001
10001
10001
10001
11110
00000
00000`,
	'E':`
00000
00000
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'F':`
00000
00000
00000
11111
10000
11111
10000
10000
10000
10000
00000
00000`,
	'G':`
00000
00000
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'H':`
00000
00000
00000
10001
10001
11111
10001
10001
10001
10001
00000
00000`,
	'I':`
00000
00000
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'J':`
00000
00000
00000
01111
00001
00001
00001
00001
00001
01110
00000
00000`,
	'K':`
00000
00000
00000
10001
10010
10100
11000
10100
10010
10001
00000
00000`,
	'L':`
00000
00000
00000
10000
10000
10000
10000
10000
10000
11111
00000
00000`,
	'M':`
00000
00000
00000
11111
10101
10101
10101
10101
10101
10101
00000
00000`,
	'N':`
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'O':`
00000
00000
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'P':`
00000
00000
00000
11110
10001
10001
10001
11110
10000
10000
00000
00000`,
	'Q':`
00000
00000
00000
01110
10001
10001
10001
10001
10101
01110
00100
00000`,
	'R':`
00000
00000
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'S':`
00000
00000
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'T':`
00000
00000
00000
11111
00100
00100
00100
00100
00100
00100
00000
00000`,
	'U':`
00000
00000
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'V':`
00000
00000
00000
10001
10001
10001
10001
10001
01010
00100
00000
00000`,
	'W':`
00000
00000
00000
10101
10101
10101
10101
10101
10101
01010
00000
00000`,
	'X':`
00000
00000
00000
10001
10001
01010
00100
01010
10001
10001
00000
00000`,
	'Y':`
00000
00000
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Z':`
00000
00000
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'.':`
00000
00000
00000
00000
00000
00000
00000
00000
00000
00100
00000
00000`,
	'·':`
00000
00000
00000
00000
00000
00000
00100
00000
00000
00000
00000
00000`,
	'•':`
00000
00000
00000
00000
00000
01110
01110
01110
00000
00000
00000
00000`,
	'…':`
00000
00000
00000
00000
00000
00000
00000
00000
00000
10101
00000
00000`,
	'†':`
00000
00100
00100
01110
00100
00100
00100
00100
00100
00100
00000
00000`,
	'‡':`
00000
00100
00100
01110
00100
00100
00100
00100
01110
00100
00000
00000`,
	'ƒ':`
00000
00000
00000
00011
00100
11111
00100
00100
00100
00100
01000
00000`,
	'‚':`
00000
00000
00000
00000
00000
00000
00000
00000
00100
01100
00000
00000`,
	'„':`
00000
00000
00000
00000
00000
00000
00000
00000
01001
11011
00000
00000`,
	',':`
00000
00000
00000
00000
00000
00000
00000
00000
00100
01100
00000
00000`,
	';':`
00000
00000
00000
00000
00000
00100
00000
00000
00100
01100
00000
00000`,
	':':`
00000
00000
00000
00000
00000
00100
00000
00000
00000
00100
00000
00000`,
	'?':`
00000
00000
00000
01110
10001
00001
00001
00110
00000
00100
00000
00000`,
	'¿':`
00000
00000
00000
00100
00000
01100
10000
10000
10001
01110
00000
00000`,
	'!':`
00000
00000
00000
00100
00100
00100
00100
00100
00000
00100
00000
00000`,
	'¡':`
00000
00000
00000
00100
00000
00100
00100
00100
00100
00100
00000
00000`,
	'@':`
00000
00000
00000
00000
00000
01110
10001
10111
10000
01110
00000
00000`,
	'£':`
00000
00000
00000
00000
00000
01110
01001
11100
01000
11111
00000
00000`,
	'$':`
00000
00000
00000
00000
00100
01111
10100
01110
00101
11110
00100
00000`,
	'%':`
00000
00000
00000
00000
00000
11001
11010
00100
01011
10011
00000
00000`,
	'‰':`
00000
00000
00000
00000
11001
11010
00100
01011
10011
00000
00011
00011`,
	'^':`
00000
00000
00000
00100
01010
00000
00000
00000
00000
00000
00000
00000`,
	'&':`
00000
00000
00000
00000
00000
01100
10000
01011
10010
01100
00000
00000`,
	'*':`
00000
00000
00000
00000
00000
01010
00100
01010
00000
00000
00000
00000`,
	'(':`
00000
00000
00000
00010
00100
00100
00100
00100
00100
00010
00000
00000`,
	')':`
00000
00000
00000
01000
00100
00100
00100
00100
00100
01000
00000
00000`,
	'+':`
00000
00000
00000
00000
00000
00100
00100
11111
00100
00100
00000
00000`,
	'÷':`
00000
00000
00000
00000
00000
00100
00000
11111
00000
00100
00000
00000`,
	'±':`
00000
00000
00000
00000
00000
00100
00100
11111
00100
11111
00000
00000`,
	'-':`
00000
00000
00000
00000
00000
00000
00000
01110
00000
00000
00000
00000`,
	'–':`
00000
00000
00000
00000
00000
00000
00000
11110
00000
00000
00000
00000`,
	'—':`
00000
00000
00000
00000
00000
00000
00000
11111
00000
00000
00000
00000`,
	'_':`
00000
00000
00000
00000
00000
00000
00000
00000
00000
11111
00000
00000`,
	'=':`
00000
00000
00000
00000
00000
00000
11111
00000
11111
00000
00000
00000`,
	' ':`
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000`,
	'{':`
00000
00000
00000
00110
00100
00100
01100
00100
00100
00110
00000
00000`,
	'}':`
00000
00000
00000
01100
00100
00100
00110
00100
00100
01100
00000
00000`,
	'[':`
00000
00000
00000
00110
00100
00100
00100
00100
00100
00110
00000
00000`,
	']':`
00000
00000
00000
01100
00100
00100
00100
00100
00100
01100
00000
00000`,
	'\'':`
00000
00000
00000
00100
00100
00100
00000
00000
00000
00000
00000
00000`,
	'‘':`
00000
00000
00000
00110
00100
00000
00000
00000
00000
00000
00000
00000`,
	'’':`
00000
00000
00000
00100
01100
00000
00000
00000
00000
00000
00000
00000`,
	'“':`
00000
00000
00000
11011
10010
00000
00000
00000
00000
00000
00000
00000`,
	'”':`
00000
00000
00000
01001
11011
00000
00000
00000
00000
00000
00000
00000`,
	'"':`
00000
00000
00000
01010
01010
01010
00000
00000
00000
00000
00000
00000`,
	'/':`
00000
00000
00000
00000
00000
00001
00010
00100
01000
10000
00000
00000`,
	'\\':`
00000
00000
00000
00000
00000
10000
01000
00100
00010
00001
00000
00000`,
	'|':`
00000
00000
00000
00000
00000
00100
00100
00100
00100
00100
00000
00000`,
	'¦':`
00000
00000
00000
00000
00100
00100
00000
00100
00100
00100
00000
00000`,
	'<':`
00000
00000
00000
00000
00000
00010
00100
01000
00100
00010
00000
00000`,
	'‹':`
00000
00000
00000
00000
00000
00000
00100
01000
00100
00000
00000
00000`,
	'«':`
00000
00000
00000
00000
00000
00000
01001
10010
01001
00000
00000
00000`,
	'>':`
00000
00000
00000
00000
00000
01000
00100
00010
00100
01000
00000
00000`,
	'›':`
00000
00000
00000
00000
00000
00000
00100
00010
00100
00000
00000
00000`,
	'»':`
00000
00000
00000
00000
00000
00000
10010
01001
10010
00000
00000
00000`,
	'~':`
00000
00000
00000
00000
00000
00000
01000
10101
00010
00000
00000
00000`,
	'˜':`
00000
00000
00000
00000
00000
01010
10100
00000
00000
00000
00000
00000`,
	'`':`
00000
00000
00000
00000
00000
01000
00100
00000
00000
00000
00000
00000`,
	'#':`
00000
00000
00000
00000
00000
01010
11111
01010
11111
01010
00000
00000`,
	'À':`
01000
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Á':`
00010
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Â':`
00100
01010
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Ã':`
01000
10101
00010
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Ä':`
00000
01010
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Å':`
00100
01010
00100
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Æ':`
00000
00000
00000
01111
10100
10100
10100
11111
10100
10111
00000
00000`,
	'Ç':`
00000
00000
00000
01111
10000
10000
10000
10000
10000
01111
00100
01000`,
	'È':`
01000
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'É':`
00010
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ê':`
00100
01010
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ë':`
00000
01010
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ì':`
01000
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Í':`
00010
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Î':`
00100
01010
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Ï':`
00000
01010
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Ð':`
00000
00000
00000
01110
01001
01001
11101
01001
01001
01110
00000
00000`,
	'Ñ':`
01001
10110
00000
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'Ò':`
01000
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ó':`
00010
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ô':`
00100
01010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Õ':`
01001
10110
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ö':`
00000
01010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ø':`
00000
00010
00100
01110
10101
10101
10101
10101
10101
01110
00100
01000`,
	'Ù':`
00000
01000
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ú':`
00000
00010
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Û':`
00100
01010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ü':`
00000
01010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ý':`
00000
00000
00100
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Þ':`
00000
00000
10000
11110
10001
10001
10001
10001
10001
11110
10000
00000`,
	'ß':`
00000
00000
00000
01110
10001
10110
10001
10001
10001
10110
10000
00000`,
	'ẞ':`
00000
00000
00000
01110
10001
10110
10001
10001
10001
10110
00000
00000`,
	'à':`
00000
00000
01000
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'á':`
00000
00000
00010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'â':`
00000
00000
00100
01010
00000
01111
10001
10001
10001
01111
00000
00000`,
	'ã':`
00000
00000
01001
10110
00000
01111
10001
10001
10001
01111
00000
00000`,
	'ä':`
00000
00000
00000
01010
00000
01111
10001
10001
10001
01111
00000
00000`,
	'å':`
00000
00100
01010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'æ':`
00000
00000
00000
00000
00000
01110
10101
10110
10100
01111
00000
00000`,
	'ç':`
00000
00000
00000
00000
00000
01111
10000
10000
10000
01111
00100
01000`,
	'è':`
00000
00000
01000
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'é':`
00000
00000
00010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ê':`
00000
00000
00100
01010
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ë':`
00000
00000
00000
01010
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ì':`
00000
00000
01000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'í':`
00000
00000
00010
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'î':`
00000
00000
00100
01010
00000
01100
00100
00100
00100
01110
00000
00000`,
	'ï':`
00000
00000
00000
01010
00000
01100
00100
00100
00100
01110
00000
00000`,
	'ð':`
00000
00000
00010
00111
00010
01110
10010
10010
10010
01110
00000
00000`,
	'ñ':`
00000
00000
01001
10110
00000
01110
10001
10001
10001
10001
00000
00000`,
	'ò':`
00000
00000
01000
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ó':`
00000
00000
00010
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ô':`
00000
00000
00100
01010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'õ':`
00000
00000
01001
10110
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ö':`
00000
00000
00000
01010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ø':`
00000
00000
00000
00010
00100
01110
10101
10101
10101
01110
00100
01000`,
	'ù':`
00000
00000
00000
01000
00100
10001
10001
10001
10001
01111
00000
00000`,
	'ú':`
00000
00000
00000
00010
00100
10001
10001
10001
10001
01111
00000
00000`,
	'û':`
00000
00000
00100
01010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'ü':`
00000
00000
00000
01010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'ý':`
00000
00000
00000
00010
00100
10001
10001
10001
10001
01111
00001
11110`,
	'þ':`
00000
00000
00000
10000
10000
11110
10001
10001
10001
11110
10000
10000`,
	'ÿ':`
00000
00000
00000
01010
00000
10001
10001
10001
10001
01111
00001
11110`,
	'Ā':`
00000
01110
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'ā':`
00000
00000
00000
01110
00000
01111
10001
10001
10001
01111
00000
00000`,
	'Ă':`
01010
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'ă':`
00000
00000
01010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'Ą':`
00000
00000
00000
01110
10001
10001
10001
11111
10001
10001
00010
00001`,
	'ą':`
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00010
00001`,
	'Ć':`
00010
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ć':`
00000
00000
00010
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ĉ':`
00100
01010
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ĉ':`
00000
00000
00100
01010
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ċ':`
00000
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ċ':`
00000
00000
00000
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Č':`
01010
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'č':`
00000
00000
01010
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ď':`
01010
00100
00000
11110
10001
10001
10001
10001
10001
11110
00000
00000`,
	'ď':`
00000
00000
00000
00101
00101
01100
10100
10100
10100
01100
00000
00000`,
	'Đ':`
00000
00000
00000
01110
01001
01001
11101
01001
01001
01110
00000
00000`,
	'đ':`
00000
00000
00010
00111
00010
01110
10010
10010
10010
01110
00000
00000`,
	'Ē':`
00000
01110
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ē':`
00000
00000
00000
01110
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ĕ':`
01010
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ĕ':`
00000
00000
01010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ė':`
00000
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ė':`
00000
00000
00000
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ę':`
00000
00000
00000
11111
10000
11111
10000
10000
10000
11111
00010
00001`,
	'ę':`
00000
00000
00000
00000
00000
01110
10001
11111
10000
01110
00010
00001`,
	'Ě':`
01010
00100
00000
11111
10000
11111
10000
10000
10000
11110
00000
00000`,
	'ě':`
00000
00000
01010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ĝ':`
00100
01010
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ĝ':`
00000
00000
00100
01010
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ğ':`
01010
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ğ':`
00000
00000
01010
00100
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ġ':`
00000
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ġ':`
00000
00000
00000
00100
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ģ':`
00000
00000
00000
01111
10000
10000
10000
10011
10001
01111
00000
01100`,
	'ģ':`
00010
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'Ĥ':`
00100
01010
00000
10001
10001
11111
10001
10001
10001
10001
00000
00000`,
	'ĥ':`
00100
01010
00000
10000
10000
11110
10001
10001
10001
10001
00000
00000`,
	'Ħ':`
00000
00000
01010
11111
01010
01110
01010
01010
01010
01010
00000
00000`,
	'ħ':`
00000
00000
01000
11100
01000
01110
01001
01001
01001
01001
00000
00000`,
	'Ĩ':`
01001
10110
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ĩ':`
01010
10100
00000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ī':`
00000
01110
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ī':`
00000
00000
00000
01110
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ĭ':`
01010
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ĭ':`
00000
00000
01010
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Į':`
00000
00000
00000
11111
00100
00100
00100
00100
00100
11111
00010
00001`,
	'į':`
00000
00000
00000
00100
00000
01100
00100
00100
00100
01110
00010
00001`,
	'İ':`
00000
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ı':`
00000
00000
00000
00000
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ĳ':`
00000
00000
00000
10010
10010
10010
10010
10010
10010
10110
00000
00000`,
	'ĳ':`
00000
00000
00000
01001
00000
11001
01001
01001
01001
11101
00001
00010`,
	'Ĵ':`
00010
00101
00000
01111
00001
00001
00001
00001
00001
01110
00000
00000`,
	'ĵ':`
00000
00000
00100
01010
00000
01100
00100
00100
00100
00100
10100
01000`,
	'Ķ':`
00000
00000
00000
10001
10010
10100
11000
10100
10010
10001
00100
01000`,
	'ķ':`
00000
00000
00000
10000
10000
10001
10010
11100
10010
10001
00100
01000`,
	'ĸ':`
00000
00000
00000
00000
00000
10001
10010
11100
10010
10001
00000
00000`,
	'Ĺ':`
00000
00010
00100
10000
10000
10000
10000
10000
10000
11111
00000
00000`,
	'ĺ':`
00010
00100
00000
01100
00100
00100
00100
00100
00100
01110
00000
00000`,
	'Ļ':`
00000
00000
00000
10000
10000
10000
10000
10000
10000
11111
00000
00100`,
	'ļ':`
00000
00000
00000
01100
00100
00100
00100
00100
00100
01110
00000
00100`,
	'Ľ':`
00000
00000
00000
10010
10010
10000
10000
10000
10000
11111
00000
00000`,
	'ľ':`
00000
00000
00000
01101
00101
00100
00100
00100
00100
01110
00000
00000`,
	'Ŀ':`
00000
00000
00000
10000
10000
10100
10000
10000
10000
11111
00000
00000`,
	'ŀ':`
00000
00000
00000
01100
00100
00100
00101
00100
00100
01110
00000
00000`,
	'Ł':`
00000
00000
00000
01000
01010
01100
11000
01000
01000
01111
00000
00000`,
	'ł':`
00000
00000
00000
01100
00100
00100
00110
01100
00100
01110
00000
00000`,
	'Ń':`
00000
00010
00100
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'ń':`
00000
00000
00010
00100
00000
01110
10001
10001
10001
10001
00000
00000`,
	'Ņ':`
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00100
01000`,
	'ņ':`
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00100
01000`,
	'Ň':`
00000
01010
00100
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'ň':`
00000
00000
01010
00100
00000
01110
10001
10001
10001
10001
00000
00000`,
	'ŉ':`
00000
00000
00000
10000
10000
00110
01001
01001
01001
01001
00000
00000`,
	'Ŋ':`
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00001
00010`,
	'ŋ':`
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00001
00010`,
	'Ō':`
00000
01110
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ō':`
00000
00000
00000
01110
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Ŏ':`
01010
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ŏ':`
00000
00000
01010
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Ő':`
01001
10010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ő':`
00000
00000
01001
10010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Œ':`
00000
00000
00000
01111
10100
10100
10111
10100
10100
01111
00000
00000`,
	'œ':`
00000
00000
00000
00000
00000
01110
10101
10110
10100
01111
00000
00000`,
	'Ŕ':`
00010
00100
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'ŕ':`
00000
00000
00010
00100
00000
01111
10000
10000
10000
10000
00000
00000`,
	'Ŗ':`
00000
00000
00000
11110
10001
10001
11110
10001
10001
10001
00100
01000`,
	'ŗ':`
00000
00000
00000
00000
00000
01111
10000
10000
10000
10000
00100
01000`,
	'Ř':`
01010
00100
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'ř':`
00000
00000
01010
00100
00000
01111
10000
10000
10000
10000
00000
00000`,
	'Ś':`
00010
00100
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'ś':`
00000
00000
00010
00100
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ŝ':`
00100
01010
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'ŝ':`
00000
00000
00100
01010
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ş':`
00000
00000
00000
01111
10000
01110
00001
00001
00001
11110
00100
00000`,
	'ş':`
00000
00000
00000
00000
00000
01111
10000
01110
00001
11110
00100
01000`,
	'Š':`
01010
00100
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'š':`
00000
00000
01010
00100
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ţ':`
00000
00000
00000
11111
00100
00100
00100
00100
00100
00100
00010
00100`,
	'ţ':`
00000
00000
00000
00100
00100
11111
00100
00100
00100
00011
00000
01100`,
	'Ť':`
01010
00100
00000
11111
00100
00100
00100
00100
00100
00100
00000
00000`,
	'ť':`
00000
00000
00001
00101
00100
11111
00100
00100
00100
00011
00000
00000`,
	'Ŧ':`
00000
00000
00000
11111
00100
00100
01110
00100
00100
00100
00000
00000`,
	'ŧ':`
00000
00000
00000
00100
00100
11111
00100
01110
00100
00011
00000
00000`,
	'Ũ':`
01001
10110
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ũ':`
00000
00000
01001
10110
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ū':`
00000
01110
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ū':`
00000
00000
00000
01110
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ŭ':`
01010
00100
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ŭ':`
00000
00000
01010
00100
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ů':`
00100
01010
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ů':`
00000
00000
00100
01010
00100
10001
10001
10001
10001
01111
00000
00000`,
	'Ű':`
01001
10010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ű':`
00000
00000
01001
10010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ų':`
00000
00000
00000
10001
10001
10001
10001
10001
10001
01110
00100
00010`,
	'ų':`
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00010
00001`,
	'Ŵ':`
00100
01010
00000
10101
10101
10101
10101
10101
10101
01010
00000
00000`,
	'ŵ':`
00000
00000
00100
01010
00000
10101
10101
10101
10101
01010
00000
00000`,
	'Ŷ':`
00100
01010
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'ŷ':`
00000
00000
00100
01010
00000
10001
10001
10001
10001
01111
00001
11110`,
	'Ÿ':`
00000
01010
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Ź':`
00010
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ź':`
00000
00000
00010
00100
00000
11111
00010
00100
01000
11111
00000
00000`,
	'Ż':`
00000
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ż':`
00000
00000
00000
00100
00000
11111
00010
00100
01000
11111
00000
00000`,
	'Ž':`
01010
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ž':`
00000
00000
01010
00100
00000
11111
00010
00100
01000
11111
00000
00000`,
	
	'€':`
00000
00000
00000
00111
01000
11110
01000
11110
01000
00111
00000
00000`,
	
	'™':`
00000
11111
00100
00100
00100
00000
01010
10101
10101
10101
00000
00000`,
	'¢':`
00000
00000
00000
00010
00100
01111
10100
10100
10100
01111
00100
01000`,
	
	'¤':`
00000
00000
00000
00000
10001
01110
10001
10001
01110
10001
00000
00000`,
	'¥':`
00000
00000
10001
01010
00100
01110
00100
01110
00100
00000
00000`,
	
	'§':`
00000
00000
00000
01110
10000
01110
10001
01110
00001
01110
00000
00000`,
	'¨':`
00000
00000
00000
01010
00000
00000
00000
00000
00000
00000
00000
00000`,
	'©':`
00000
00000
00000
01110
10001
10111
10101
10111
10001
01110
00000
00000`,
	'®':`
00000
00000
00000
01110
10001
10111
10101
10101
10001
01110
00000
00000`,
	'ª':`
00000
01110
00010
01110
01010
01110
00000
00000
00000
00000
00000
00000`,
	'º':`
00000
00100
01010
01010
01010
00100
00000
00000
00000
00000
00000
00000`,
	
	'¬':`
00000
00000
00000
00000
00000
00000
00000
01110
00010
00000
00000
00000`,
	'¯':`
00000
00000
00000
01110
00000
00000
00000
00000
00000
00000
00000
00000`,
	'°':`
00000
00000
00100
01010
00100
00000
00000
00000
00000
00000
00000
00000`,
	'✓':`
00000
00000
00000
00000
00000
00001
00010
10100
01000
00000
00000
00000`,
}

var fontKeys = Object.keys(font);

var fontIndex = {};
for (var i = 0; i < fontKeys.length; i++) {
	fontIndex[fontKeys[i]] = i;
}
</script>
<script>
/**
 * Seedable random number generator functions.
 * @version 1.0.0
 * @license Public Domain
 *
 * @example
 * var rng = new RNG('Example');
 * rng.random(40, 50);  // =>  42
 * rng.uniform();       // =>  0.7972798995050903
 * rng.normal();        // => -0.6698504543216376
 * rng.exponential();   // =>  1.0547367609131555
 * rng.poisson(4);      // =>  2
 * rng.gamma(4);        // =>  2.781724687386858
 */

/**
 * Get the underlying bytes of this string.
 * @return {Array} An array of bytes
 */
String.prototype.getBytes = function() {
    var output = [];
    for (var i = 0; i < this.length; i++) {
        var c = this.charCodeAt(i);
        var bytes = [];
        do {
            bytes.push(c & 0xFF);
            c = c >> 8;
        } while (c > 0);
        output = output.concat(bytes.reverse());
    }
    return output;
};

/**
 * @param {String} seed A string to seed the generator.
 * @constructor
 */
function RC4(seed) {
    this.s = new Array(256);
    this.i = 0;
    this.j = 0;
    for (var i = 0; i < 256; i++) {
        this.s[i] = i;
    }
    if (seed) {
        this.mix(seed);
    }
}

RC4.prototype._swap = function(i, j) {
    var tmp = this.s[i];
    this.s[i] = this.s[j];
    this.s[j] = tmp;
};

/**
 * Mix additional entropy into this generator.
 * @param {String} seed
 */
RC4.prototype.mix = function(seed) {
    var input = seed.getBytes();
    var j = 0;
    for (var i = 0; i < this.s.length; i++) {
        j += this.s[i] + input[i % input.length];
        j %= 256;
        this._swap(i, j);
    }
};

/**
 * @return {number} The next byte of output from the generator.
 */
RC4.prototype.next = function() {
    this.i = (this.i + 1) % 256;
    this.j = (this.j + this.s[this.i]) % 256;
    this._swap(this.i, this.j);
    return this.s[(this.s[this.i] + this.s[this.j]) % 256];
};

function print_call_stack() {
  var e = new Error();
  var stack = e.stack;
  console.log( stack );
}
/**
 * Create a new random number generator with optional seed. If the
 * provided seed is a function (i.e. Math.random) it will be used as
 * the uniform number generator.
 * @param seed An arbitrary object used to seed the generator.
 * @constructor
 */
function RNG(seed) {
    this.seed = seed;
    if (seed == null) {
        seed = (Math.random() + Date.now()).toString();
        //window.console.log("setting random seed "+seed); 
        //print_call_stack();  

    } else if (typeof seed === 'function') {
        // Use it as a uniform number generator
        this.uniform = seed;
        this.nextByte = function() {
            return ~~(this.uniform() * 256);
        };
        seed = null;
    } else if (Object.prototype.toString.call(seed) !== '[object String]') {
        seed = JSON.stringify(seed);
    } else {
        //window.console.log("setting seed "+seed);
        //print_call_stack();
    }
    this._normal = null;
    if (seed) {
        this._state = new RC4(seed);
    } else {
        this._state = null;
    }
}

/**
 * @return {number} Uniform random number between 0 and 255.
 */
RNG.prototype.nextByte = function() {
    return this._state.next();
};

/**
 * @return {number} Uniform random number between 0 and 1.
 */
RNG.prototype.uniform = function() {
    var BYTES = 7; // 56 bits to make a 53-bit double
    var output = 0;
    for (var i = 0; i < BYTES; i++) {
        output *= 256;
        output += this.nextByte();
    }
    return output / (Math.pow(2, BYTES * 8) - 1);
};

/**
 * Produce a random integer within [n, m).
 * @param {number} [n=0]
 * @param {number} m
 *
 */
RNG.prototype.random = function(n, m) {
    if (n == null) {
        return this.uniform();
    } else if (m == null) {
        m = n;
        n = 0;
    }
    return n + Math.floor(this.uniform() * (m - n));
};

/**
 * Generates numbers using this.uniform() with the Box-Muller transform.
 * @return {number} Normally-distributed random number of mean 0, variance 1.
 */
RNG.prototype.normal = function() {
    if (this._normal !== null) {
        var n = this._normal;
        this._normal = null;
        return n;
    } else {
        var x = this.uniform() || Math.pow(2, -53); // can't be exactly 0
        var y = this.uniform();
        this._normal = Math.sqrt(-2 * Math.log(x)) * Math.sin(2 * Math.PI * y);
        return Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);
    }
};

/**
 * Generates numbers using this.uniform().
 * @return {number} Number from the exponential distribution, lambda = 1.
 */
RNG.prototype.exponential = function() {
    return -Math.log(this.uniform() || Math.pow(2, -53));
};

/**
 * Generates numbers using this.uniform() and Knuth's method.
 * @param {number} [mean=1]
 * @return {number} Number from the Poisson distribution.
 */
RNG.prototype.poisson = function(mean) {
    var L = Math.exp(-(mean || 1));
    var k = 0, p = 1;
    do {
        k++;
        p *= this.uniform();
    } while (p > L);
    return k - 1;
};

/**
 * Generates numbers using this.uniform(), this.normal(),
 * this.exponential(), and the Marsaglia-Tsang method.
 * @param {number} a
 * @return {number} Number from the gamma distribution.
 */
RNG.prototype.gamma = function(a) {
    var d = (a < 1 ? 1 + a : a) - 1 / 3;
    var c = 1 / Math.sqrt(9 * d);
    do {
        do {
            var x = this.normal();
            var v = Math.pow(c * x + 1, 3);
        } while (v <= 0);
        var u = this.uniform();
        var x2 = Math.pow(x, 2);
    } while (u >= 1 - 0.0331 * x2 * x2 &&
             Math.log(u) >= 0.5 * x2 + d * (1 - v + Math.log(v)));
    if (a < 1) {
        return d * v * Math.exp(this.exponential() / -a);
    } else {
        return d * v;
    }
};

/**
 * Accepts a dice rolling notation string and returns a generator
 * function for that distribution. The parser is quite flexible.
 * @param {string} expr A dice-rolling, expression i.e. '2d6+10'.
 * @param {RNG} rng An optional RNG object.
 * @return {Function}
 */
RNG.roller = function(expr, rng) {
    var parts = expr.split(/(\d+)?d(\d+)([+-]\d+)?/).slice(1);
    var dice = parseFloat(parts[0]) || 1;
    var sides = parseFloat(parts[1]);
    var mod = parseFloat(parts[2]) || 0;
    rng = rng || new RNG();
    return function() {
        var total = dice + mod;
        for (var i = 0; i < dice; i++) {
            total += rng.random(sides);
        }
        return total;
    };
};
</script>
<script>
/*
 * RIFFWAVE.js v0.02 - Audio encoder for HTML5 <audio> elements.
 * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * The full license is available at http://www.gnu.org/licenses/gpl.html
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 *
 * Changelog:
 *
 * 0.01 - First release
 * 0.02 - New faster base64 encoding
 *
 */

var FastBase64_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var FastBase64_encLookup = [];

function FastBase64_Init() {
  for (var i = 0; i < 4096; i++) {
    FastBase64_encLookup[i] = FastBase64_chars[i >> 6] + FastBase64_chars[i & 0x3F];
  }
}

function FastBase64_Encode(src) {
  var len = src.length;
  var dst = '';
  var i = 0;
  while (len > 2) {
    n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];
    dst += FastBase64_encLookup[n >> 12] + FastBase64_encLookup[n & 0xFFF];
    len -= 3;
    i += 3;
  }
  if (len > 0) {
    var n1 = (src[i] & 0xFC) >> 2;
    var n2 = (src[i] & 0x03) << 4;
    if (len > 1) n2 |= (src[++i] & 0xF0) >> 4;
    dst += FastBase64_chars[n1];
    dst += FastBase64_chars[n2];
    if (len == 2) {
      var n3 = (src[i++] & 0x0F) << 2;
      n3 |= (src[i] & 0xC0) >> 6;
      dst += FastBase64_chars[n3];
    }
    if (len == 1) dst += '=';
    dst += '=';
  }
  return dst;
} // end Encode

FastBase64_Init();

function u32ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF]; }

function u16ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF]; }

function MakeRiff ( sampleRate, bitsPerSample,data) {
  var dat = [];
  var wav=[];
  var dataURI=[];

  var header = {                         // OFFS SIZE NOTES
    chunkId: [0x52, 0x49, 0x46, 0x46], // 0    4    "RIFF" = 0x52494646
    chunkSize: 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)
    format: [0x57, 0x41, 0x56, 0x45], // 8    4    "WAVE" = 0x57415645
    subChunk1Id: [0x66, 0x6d, 0x74, 0x20], // 12   4    "fmt " = 0x666d7420
    subChunk1Size: 16,                    // 16   4    16 for PCM
    audioFormat: 1,                     // 20   2    PCM = 1
    numChannels: 1,                     // 22   2    Mono = 1, Stereo = 2, etc.
    sampleRate: sampleRate,                  // 24   4    8000, 44100, etc
    byteRate: 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8
    blockAlign: 0,                     // 32   2    NumChannels*BitsPerSample/8
    bitsPerSample: bitsPerSample,                     // 34   2    8 bits = 8, 16 bits = 16, etc...
    subChunk2Id: [0x64, 0x61, 0x74, 0x61], // 36   4    "data" = 0x64617461
    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8
  };

  header.byteRate = (header.sampleRate * header.numChannels * header.bitsPerSample) >> 3;
  header.blockAlign = (header.numChannels * header.bitsPerSample) >> 3;
  header.subChunk2Size = data.length;
  header.chunkSize = 36 + header.subChunk2Size;

  wav = header.chunkId.concat(
      u32ToArray(header.chunkSize),
      header.format,
      header.subChunk1Id,
      u32ToArray(header.subChunk1Size),
      u16ToArray(header.audioFormat),
      u16ToArray(header.numChannels),
      u32ToArray(header.sampleRate),
      u32ToArray(header.byteRate),
      u16ToArray(header.blockAlign),
      u16ToArray(header.bitsPerSample),
      header.subChunk2Id,
      u32ToArray(header.subChunk2Size),
      data
    );
    
    dataURI = 'data:audio/wav;base64,' + FastBase64_Encode(wav);

    var result = {
      dat:dat,
      wav:wav,
      header:header,
      dataURI:dataURI
    };

    return result;
}


if (typeof exports != 'undefined')  // For node.js
  exports.RIFFWAVE = RIFFWAVE;

</script>
<script>
var SOUND_VOL = 0.25;
var SAMPLE_RATE = 5512;
var BIT_DEPTH = 8;

var SQUARE = 0;
var SAWTOOTH = 1;
var SINE = 2;
var NOISE = 3;
var TRIANGLE = 4;
var BREAKER = 5;

var SHAPES = [
  'square', 'sawtooth', 'sine', 'noise', 'triangle', 'breaker'
];

var AUDIO_CONTEXT;

function checkAudioContextExists(){
  try{
    if (AUDIO_CONTEXT==null){
      if (typeof AudioContext != 'undefined') {
        AUDIO_CONTEXT = new AudioContext();
      } else if (typeof webkitAudioContext != 'undefined') {
        AUDIO_CONTEXT = new webkitAudioContext();
      }
    }
  }
  catch (ex){
    window.console.log(ex)
  }
}

checkAudioContextExists();

// Playback volume
var masterVolume = 1.0;

// Sound generation parameters are on [0,1] unless noted SIGNED, & thus [-1,1]
function Params() {
  var result={};
  // Wave shape
  result.wave_type = SQUARE;

  // Envelope
  result.p_env_attack = 0.0;   // Attack time
  result.p_env_sustain = 0.3;  // Sustain time
  result.p_env_punch = 0.0;    // Sustain punch
  result.p_env_decay = 0.4;    // Decay time

  // Tone
  result.p_base_freq = 0.3;    // Start frequency
  result.p_freq_limit = 0.0;   // Min frequency cutoff
  result.p_freq_ramp = 0.0;    // Slide (SIGNED)
  result.p_freq_dramp = 0.0;   // Delta slide (SIGNED)
  // Vibrato
  result.p_vib_strength = 0.0; // Vibrato depth
  result.p_vib_speed = 0.0;    // Vibrato speed

  // Tonal change
  result.p_arp_mod = 0.0;      // Change amount (SIGNED)
  result.p_arp_speed = 0.0;    // Change speed

  // Duty (wat's that?)
  result.p_duty = 0.0;         // Square duty
  result.p_duty_ramp = 0.0;    // Duty sweep (SIGNED)

  // Repeat
  result.p_repeat_speed = 0.0; // Repeat speed

  // Phaser
  result.p_pha_offset = 0.0;   // Phaser offset (SIGNED)
  result.p_pha_ramp = 0.0;     // Phaser sweep (SIGNED)

  // Low-pass filter
  result.p_lpf_freq = 1.0;     // Low-pass filter cutoff
  result.p_lpf_ramp = 0.0;     // Low-pass filter cutoff sweep (SIGNED)
  result.p_lpf_resonance = 0.0;// Low-pass filter resonance
  // High-pass filter
  result.p_hpf_freq = 0.0;     // High-pass filter cutoff
  result.p_hpf_ramp = 0.0;     // High-pass filter cutoff sweep (SIGNED)

  // Sample parameters
  result.sound_vol = 0.5;
  result.sample_rate = 44100;
  result.bit_depth = 8;
  return result;
}

var rng;
var seeded = false;
function frnd(range) {
  if (seeded) {
    return rng.uniform() * range;
  } else {
    return Math.random() * range;
  }
}


function rnd(max) {
  if (seeded) {
  return Math.floor(rng.uniform() * (max + 1));
  } else {
    return Math.floor(Math.random() * (max + 1));
  }
}


pickupCoin = function() {
  var result=Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = 0;
  }
  result.p_base_freq = 0.4 + frnd(0.5);
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.1);
  result.p_env_decay = 0.1 + frnd(0.4);
  result.p_env_punch = 0.3 + frnd(0.3);
  if (rnd(1)) {
    result.p_arp_speed = 0.5 + frnd(0.2);
    var num = (frnd(7) | 1) + 1;
    var den = num + (frnd(7) | 1) + 2;
    result.p_arp_mod = (+num) / (+den); //0.2 + frnd(0.4);
  }
  return result;
};


laserShoot = function() {
  var result=Params();
  result.wave_type = rnd(2);
  if (result.wave_type === SINE && rnd(1))
    result.wave_type = rnd(1);
  result.wave_type = Math.floor(frnd(SHAPES.length));

  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }

  result.p_base_freq = 0.5 + frnd(0.5);
  result.p_freq_limit = result.p_base_freq - 0.2 - frnd(0.6);
  if (result.p_freq_limit < 0.2) result.p_freq_limit = 0.2;
  result.p_freq_ramp = -0.15 - frnd(0.2);
  if (rnd(2) === 0)
  {
    result.p_base_freq = 0.3 + frnd(0.6);
    result.p_freq_limit = frnd(0.1);
    result.p_freq_ramp = -0.35 - frnd(0.3);
  }
  if (rnd(1))
  {
    result.p_duty = frnd(0.5);
    result.p_duty_ramp = frnd(0.2);
  }
  else
  {
    result.p_duty = 0.4 + frnd(0.5);
    result.p_duty_ramp = -frnd(0.7);
  }
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.2);
  result.p_env_decay = frnd(0.4);
  if (rnd(1))
    result.p_env_punch = frnd(0.3);
  if (rnd(2) === 0)
  {
    result.p_pha_offset = frnd(0.2);
    result.p_pha_ramp = -frnd(0.2);
  }
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);

  return result;
};

explosion = function() {
  var result=Params();

  if (rnd(1)) {
    result.p_base_freq = 0.1 + frnd(0.4);
    result.p_freq_ramp = -0.1 + frnd(0.4);
  } else {
    result.p_base_freq = 0.2 + frnd(0.7);
    result.p_freq_ramp = -0.2 - frnd(0.2);
  }
  result.p_base_freq *= result.p_base_freq;
  if (rnd(4) === 0)
    result.p_freq_ramp = 0.0;
  if (rnd(2) === 0)
    result.p_repeat_speed = 0.3 + frnd(0.5);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.3);
  result.p_env_decay = frnd(0.5);
  if (rnd(1) === 0) {
    result.p_pha_offset = -0.3 + frnd(0.9);
    result.p_pha_ramp = -frnd(0.3);
  }
  result.p_env_punch = 0.2 + frnd(0.6);
  if (rnd(1)) {
    result.p_vib_strength = frnd(0.7);
    result.p_vib_speed = frnd(0.6);
  }
  if (rnd(2) === 0) {
    result.p_arp_speed = 0.6 + frnd(0.3);
    result.p_arp_mod = 0.8 - frnd(1.6);
  }

  return result;
};
//9675111
birdSound = function() {
  var result=Params();

if (frnd(10) < 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));
    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
result.p_freq_limit = 0 + frnd(0.2) - 0.1;
result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
if (frnd(1.0) < 0.5) {
  result.p_freq_ramp = 0.1 + frnd(0.15);
}
result.p_freq_dramp = 0.004598608156964473 + frnd(0.1) - 0.05;
result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
result.p_arp_mod = 0;//-0.46410459213693644+frnd(0.2)-0.1;
result.p_arp_speed = 0;//-0.10955361249587248+frnd(0.2)-0.1;
result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.6014860189319991 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
return result;
}

if (frnd(10) < 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));
    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.5277795946672003 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.18243733568468432 + frnd(0.2) - 0.1;
result.p_env_punch = -0.020159754546840117 + frnd(0.2) - 0.1;
result.p_env_decay = 0.1561353422051903 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9028855606533718 + frnd(0.2) - 0.1;
result.p_freq_limit = -0.008842787837148716;
result.p_freq_ramp = -0.1;
result.p_freq_dramp = -0.012891241489551925;
result.p_vib_strength = -0.17923136138403065 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.908263385610142 + frnd(0.2) - 0.1;
result.p_arp_mod = 0.41690153355414894 + frnd(0.2) - 0.1;
result.p_arp_speed = 0.0010766233195860703 + frnd(0.2) - 0.1;
result.p_duty = -0.8735363011184684 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.7397985366747507 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.0591789344172107 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9961184222777699 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.08234769395850523 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9412475115697335 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.18261358925834958 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.24541438107389477 + frnd(0.2) - 0.1;
result.p_hpf_freq = -0.01831940280978611 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.03857383633171346 + frnd(0.2) - 0.1;
return result;

}
  if (frnd(10) < 1) {
//result.wave_type = 4;
    result.wave_type = Math.floor(frnd(SHAPES.length));

    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
result.p_freq_limit = 0 + frnd(0.2) - 0.1;
result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
result.p_freq_dramp = 0.004598608156964473 + frnd(0.2) - 0.1;
result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
result.p_arp_mod = -0.46410459213693644 + frnd(0.2) - 0.1;
result.p_arp_speed = -0.10955361249587248 + frnd(0.2) - 0.1;
result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.7014860189319991 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
return result;
}
  if (frnd(5) > 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));

    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
    if (rnd(1)) {
      result.p_arp_mod = 0.2697849293151393 + frnd(0.2) - 0.1;
      result.p_arp_speed = -0.3131172257760948 + frnd(0.2) - 0.1;
      result.p_base_freq = 0.8090588299313949 + frnd(0.2) - 0.1;
      result.p_duty = -0.6210022920964955 + frnd(0.2) - 0.1;
      result.p_duty_ramp = -0.00043441813553182567 + frnd(0.2) - 0.1;
      result.p_env_attack = 0.004321877246874195 + frnd(0.2) - 0.1;
      result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
      result.p_env_punch = 0.061737781504416146 + frnd(0.2) - 0.1;
      result.p_env_sustain = 0.4987252564798832 + frnd(0.2) - 0.1;
      result.p_freq_dramp = 0.31700340314222614 + frnd(0.2) - 0.1;
      result.p_freq_limit = 0 + frnd(0.2) - 0.1;
      result.p_freq_ramp = -0.163380391341416 + frnd(0.2) - 0.1;
      result.p_hpf_freq = 0.4709005021145149 + frnd(0.2) - 0.1;
      result.p_hpf_ramp = 0.6924667290539194 + frnd(0.2) - 0.1;
      result.p_lpf_freq = 0.8351398631384511 + frnd(0.2) - 0.1;
      result.p_lpf_ramp = 0.36616557192873134 + frnd(0.2) - 0.1;
      result.p_lpf_resonance = -0.08685777111664439 + frnd(0.2) - 0.1;
      result.p_pha_offset = -0.036084571580025544 + frnd(0.2) - 0.1;
      result.p_pha_ramp = -0.014806445085568108 + frnd(0.2) - 0.1;
      result.p_repeat_speed = -0.8094368475518489 + frnd(0.2) - 0.1;
      result.p_vib_speed = 0.4496665457171294 + frnd(0.2) - 0.1;
      result.p_vib_strength = 0.23413762515532424 + frnd(0.2) - 0.1;
    } else {
      result.p_arp_mod = -0.35697118026766184 + frnd(0.2) - 0.1;
      result.p_arp_speed = 0.3581140690559588 + frnd(0.2) - 0.1;
      result.p_base_freq = 1.3260897696157528 + frnd(0.2) - 0.1;
      result.p_duty = -0.30984900436710694 + frnd(0.2) - 0.1;
      result.p_duty_ramp = -0.0014374759133411626 + frnd(0.2) - 0.1;
      result.p_env_attack = 0.3160357835682254 + frnd(0.2) - 0.1;
      result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
      result.p_env_punch = 0.24323114016870148 + frnd(0.2) - 0.1;
      result.p_env_sustain = 0.4 + frnd(0.2) - 0.1;
      result.p_freq_dramp = 0.2866475886237244 + frnd(0.2) - 0.1;
      result.p_freq_limit = 0 + frnd(0.2) - 0.1;
      result.p_freq_ramp = -0.10956352368742976 + frnd(0.2) - 0.1;
      result.p_hpf_freq = 0.20772718017889846 + frnd(0.2) - 0.1;
      result.p_hpf_ramp = 0.1564090637378835 + frnd(0.2) - 0.1;
      result.p_lpf_freq = 0.6021372770637031 + frnd(0.2) - 0.1;
      result.p_lpf_ramp = 0.24016227139979027 + frnd(0.2) - 0.1;
      result.p_lpf_resonance = -0.08787383821160144 + frnd(0.2) - 0.1;
      result.p_pha_offset = -0.381597686151701 + frnd(0.2) - 0.1;
      result.p_pha_ramp = -0.0002481687661373495 + frnd(0.2) - 0.1;
      result.p_repeat_speed = 0.07812112809425686 + frnd(0.2) - 0.1;
      result.p_vib_speed = -0.13648848579133943 + frnd(0.2) - 0.1;
      result.p_vib_strength = 0.0018874158972302657 + frnd(0.2) - 0.1;
    }
    return result;

  }

  result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
  if (result.wave_type === 1 || result.wave_type === 3) {
    result.wave_type = 2;
  }
  //new
  result.p_base_freq = 0.85 + frnd(0.15);
  result.p_freq_ramp = 0.3 + frnd(0.15);
//  result.p_freq_dramp = 0.3+frnd(2.0);

  result.p_env_attack = 0 + frnd(0.09);
  result.p_env_sustain = 0.2 + frnd(0.3);
  result.p_env_decay = 0 + frnd(0.1);

  result.p_duty = frnd(2.0) - 1.0;
  result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);


  result.p_repeat_speed = 0.5 + frnd(0.1);

  result.p_pha_offset = -0.3 + frnd(0.9);
  result.p_pha_ramp = -frnd(0.3);

  result.p_arp_speed = 0.4 + frnd(0.6);
  result.p_arp_mod = 0.8 + frnd(0.1);


  result.p_lpf_resonance = frnd(2.0) - 1.0;
  result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
  result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
    result.p_lpf_ramp = -result.p_lpf_ramp;
  result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
  result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);

  return result;
};


pushSound = function() {
  var result=Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
  if (result.wave_type === 2) {
    result.wave_type++;
  }
  if (result.wave_type === 0) {
    result.wave_type = NOISE;
  }
  //new
  result.p_base_freq = 0.1 + frnd(0.4);
  result.p_freq_ramp = 0.05 + frnd(0.2);

  result.p_env_attack = 0.01 + frnd(0.09);
  result.p_env_sustain = 0.01 + frnd(0.09);
  result.p_env_decay = 0.01 + frnd(0.09);

  result.p_repeat_speed = 0.3 + frnd(0.5);
  result.p_pha_offset = -0.3 + frnd(0.9);
  result.p_pha_ramp = -frnd(0.3);
  result.p_arp_speed = 0.6 + frnd(0.3);
  result.p_arp_mod = 0.8 - frnd(1.6);

  return result;
};



powerUp = function() {
  var result=Params();
  if (rnd(1))
    result.wave_type = SAWTOOTH;
  else
    result.p_duty = frnd(0.6);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }
  if (rnd(1))
  {
    result.p_base_freq = 0.2 + frnd(0.3);
    result.p_freq_ramp = 0.1 + frnd(0.4);
    result.p_repeat_speed = 0.4 + frnd(0.4);
  }
  else
  {
    result.p_base_freq = 0.2 + frnd(0.3);
    result.p_freq_ramp = 0.05 + frnd(0.2);
    if (rnd(1))
    {
      result.p_vib_strength = frnd(0.7);
      result.p_vib_speed = frnd(0.6);
    }
  }
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.4);
  result.p_env_decay = 0.1 + frnd(0.4);

  return result;
};

hitHurt = function() {
  result = Params();
  result.wave_type = rnd(2);
  if (result.wave_type === SINE)
    result.wave_type = NOISE;
  if (result.wave_type === SQUARE)
    result.p_duty = frnd(0.6);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  result.p_base_freq = 0.2 + frnd(0.6);
  result.p_freq_ramp = -0.3 - frnd(0.4);
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.1);
  result.p_env_decay = 0.1 + frnd(0.2);
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);
  return result;
};


jump = function() {
  result = Params();
  result.wave_type = SQUARE;
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }
  result.p_duty = frnd(0.6);
  result.p_base_freq = 0.3 + frnd(0.3);
  result.p_freq_ramp = 0.1 + frnd(0.2);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.3);
  result.p_env_decay = 0.1 + frnd(0.2);
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);
  if (rnd(1))
    result.p_lpf_freq = 1.0 - frnd(0.6);
  return result;
};

blipSelect = function() {
  result = Params();
  result.wave_type = rnd(1);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = rnd(1);
  }
  if (result.wave_type === SQUARE)
    result.p_duty = frnd(0.6);
  result.p_base_freq = 0.2 + frnd(0.4);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.1);
  result.p_env_decay = frnd(0.2);
  result.p_hpf_freq = 0.1;
  return result;
};

random = function() {
  result = Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));
  result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 2.0);
  if (rnd(1))
    result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 3.0) + 0.5;
  result.p_freq_limit = 0.0;
  result.p_freq_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
  if (result.p_base_freq > 0.7 && result.p_freq_ramp > 0.2)
    result.p_freq_ramp = -result.p_freq_ramp;
  if (result.p_base_freq < 0.2 && result.p_freq_ramp < -0.05)
    result.p_freq_ramp = -result.p_freq_ramp;
  result.p_freq_dramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_duty = frnd(2.0) - 1.0;
  result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_vib_strength = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_vib_speed = frnd(2.0) - 1.0;
  result.p_env_attack = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_env_sustain = Math.pow(frnd(2.0) - 1.0, 2.0);
  result.p_env_decay = frnd(2.0) - 1.0;
  result.p_env_punch = Math.pow(frnd(0.8), 2.0);
  if (result.p_env_attack + result.p_env_sustain + result.p_env_decay < 0.2) {
    result.p_env_sustain += 0.2 + frnd(0.3);
    result.p_env_decay += 0.2 + frnd(0.3);
  }
  result.p_lpf_resonance = frnd(2.0) - 1.0;
  result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
  result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
    result.p_lpf_ramp = -result.p_lpf_ramp;
  result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
  result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
  result.p_pha_offset = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_pha_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_repeat_speed = frnd(2.0) - 1.0;
  result.p_arp_speed = frnd(2.0) - 1.0;
  result.p_arp_mod = frnd(2.0) - 1.0;
  return result;
};

var generators = [
pickupCoin,
laserShoot,
explosion,
powerUp,
hitHurt,
jump,
blipSelect,
pushSound,
random,
birdSound
];

var generatorNames = [
'pickupCoin',
'laserShoot',
'explosion',
'powerUp',
'hitHurt',
'jump',
'blipSelect',
'pushSound',
'random',
'birdSound'
];

/*
i like 9675111
*/
generateFromSeed = function(seed) {
  const params = seed.toString().split(':');
  rng = new RNG((params[0] / 100) | 0);
  var generatorindex = params[0] % 100;
  var soundGenerator = generators[generatorindex % generators.length];
  seeded = true;
  var result = soundGenerator();
  result.seed = params[0];
  result.sound_vol = SOUND_VOL * (parseFloat(params[1]) || 10.0) / 10.0;
  seeded = false;
  return result;
};

function SoundEffect(length, sample_rate) {
  this._buffer = AUDIO_CONTEXT.createBuffer(1, length, sample_rate);
}

SoundEffect.prototype.getBuffer = function() {
  return this._buffer.getChannelData(0);
};


//unlock bullshit
function ULBS(){   
  if (AUDIO_CONTEXT.state === 'suspended')
  {
      var unlock = function()
      {
        AUDIO_CONTEXT.resume().then(function()
          {
            document.body.removeEventListener('touchstart', unlock);
            document.body.removeEventListener('touchend', unlock);
            document.body.removeEventListener('mousedown', unlock);
            document.body.removeEventListener('mouseup', unlock);
            document.body.removeEventListener('keydown', unlock);
            document.body.removeEventListener('keyup', unlock);
          });
      };

      document.body.addEventListener('touchstart', unlock, false);
      document.body.addEventListener('touchend', unlock, false);
      document.body.addEventListener('mousedown', unlock, false);
      document.body.addEventListener('mouseup', unlock, false);
      document.body.addEventListener('keydown', unlock, false);
      document.body.addEventListener('keyup', unlock, false);
  }
}

SoundEffect.prototype.play = function() {
  ULBS();

  var source = AUDIO_CONTEXT.createBufferSource();
  var filter1 = AUDIO_CONTEXT.createBiquadFilter();
  var filter2 = AUDIO_CONTEXT.createBiquadFilter();
  var filter3 = AUDIO_CONTEXT.createBiquadFilter();

  source.buffer = this._buffer;
  source.connect(filter1);

  filter1.frequency.value = 1600;
  filter2.frequency.value = 1600;
  filter3.frequency.value = 1600;

  filter1.connect(filter2);
  filter2.connect(filter3);
  filter3.connect(AUDIO_CONTEXT.destination);
  var t = AUDIO_CONTEXT.currentTime;
  if (typeof source.start != 'undefined') {
    source.start(t);
  } else {
    source.noteOn(t);
  }
  source.onended = function() {
    filter3.disconnect()
  }
};

SoundEffect.MIN_SAMPLE_RATE = 22050;

if (typeof AUDIO_CONTEXT == 'undefined') {
  SoundEffect = function SoundEffect(length, sample_rate) {
    this._sample_rate = sample_rate;
    this._buffer = new Array(length);
    this._audioElement = null;
  };

  SoundEffect.prototype.getBuffer = function() {
    this._audioElement = null;
    return this._buffer;
  };

  SoundEffect.prototype.play = function() {
    if (this._audioElement) {
      this._audioElement.cloneNode(false).play();
    } else {
      for (var i = 0; i < this._buffer.length; i++) {
        // bit_depth is always 8, rescale [-1.0, 1.0) to [0, 256)
        this._buffer[i] = 255 & Math.floor(128 * Math.max(0, Math.min(this._buffer[i] + 1, 2)));
      }
      var wav = MakeRiff(this._sample_rate, BIT_DEPTH, this._buffer);
      this._audioElement = new Audio();
      this._audioElement.src = wav.dataURI;
      this._audioElement.play();
    }
  };

  SoundEffect.MIN_SAMPLE_RATE = 1;
}

SoundEffect.generate = function(ps) {
/*  window.console.log(ps.wave_type + "\t" + ps.seed);

  var psstring="";
  for (var n in ps) {
    if (ps.hasOwnProperty(n)) {
      psstring = psstring +"result." + n+" = " + ps[n] + ";\n";
    }
  }
window.console.log(ps);
window.console.log(psstring);*/
  function repeat() {
    rep_time = 0;

    fperiod = 100.0 / (ps.p_base_freq * ps.p_base_freq + 0.001);
    period = Math.floor(fperiod);
    fmaxperiod = 100.0 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);

    fslide = 1.0 - Math.pow(ps.p_freq_ramp, 3.0) * 0.01;
    fdslide = -Math.pow(ps.p_freq_dramp, 3.0) * 0.000001;

    square_duty = 0.5 - ps.p_duty * 0.5;
    square_slide = -ps.p_duty_ramp * 0.00005;

    if (ps.p_arp_mod >= 0.0)
      arp_mod = 1.0 - Math.pow(ps.p_arp_mod, 2.0) * 0.9;
    else
      arp_mod = 1.0 + Math.pow(ps.p_arp_mod, 2.0) * 10.0;
    arp_time = 0;
    arp_limit = Math.floor(Math.pow(1.0 - ps.p_arp_speed, 2.0) * 20000 + 32);
    if (ps.p_arp_speed == 1.0)
      arp_limit = 0;
  };

  var rep_time;
  var fperiod, period, fmaxperiod;
  var fslide, fdslide;
  var square_duty, square_slide;
  var arp_mod, arp_time, arp_limit;
  repeat();  // First time through, this is a bit of a misnomer

  // Filter
  var fltp = 0.0;
  var fltdp = 0.0;
  var fltw = Math.pow(ps.p_lpf_freq, 3.0) * 0.1;
  var fltw_d = 1.0 + ps.p_lpf_ramp * 0.0001;
  var fltdmp = 5.0 / (1.0 + Math.pow(ps.p_lpf_resonance, 2.0) * 20.0) *
    (0.01 + fltw);
  if (fltdmp > 0.8) fltdmp = 0.8;
  var fltphp = 0.0;
  var flthp = Math.pow(ps.p_hpf_freq, 2.0) * 0.1;
  var flthp_d = 1.0 + ps.p_hpf_ramp * 0.0003;

  // Vibrato
  var vib_phase = 0.0;
  var vib_speed = Math.pow(ps.p_vib_speed, 2.0) * 0.01;
  var vib_amp = ps.p_vib_strength * 0.5;

  // Envelope
  var env_vol = 0.0;
  var env_stage = 0;
  var env_time = 0;
  var env_length = [
    Math.floor(ps.p_env_attack * ps.p_env_attack * 100000.0),
    Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000.0),
    Math.floor(ps.p_env_decay * ps.p_env_decay * 100000.0)
  ];
  var env_total_length = env_length[0] + env_length[1] + env_length[2];

  // Phaser
  var phase = 0;
  var fphase = Math.pow(ps.p_pha_offset, 2.0) * 1020.0;
  if (ps.p_pha_offset < 0.0) fphase = -fphase;
  var fdphase = Math.pow(ps.p_pha_ramp, 2.0) * 1.0;
  if (ps.p_pha_ramp < 0.0) fdphase = -fdphase;
  var iphase = Math.abs(Math.floor(fphase));
  var ipp = 0;
  var phaser_buffer = [];
  for (var i = 0; i < 1024; ++i)
    phaser_buffer[i] = 0.0;

  // Noise
  var noise_buffer = [];
  for (var i = 0; i < 32; ++i)
    noise_buffer[i] = Math.random() * 2.0 - 1.0;

  // Repeat
  var rep_limit = Math.floor(Math.pow(1.0 - ps.p_repeat_speed, 2.0) * 20000
                             + 32);
  if (ps.p_repeat_speed == 0.0)
    rep_limit = 0;

  //var gain = 2.0 * Math.log(1 + (Math.E - 1) * ps.sound_vol);
  //var gain = 2.0 * ps.sound_vol;
  var gain = Math.exp(ps.sound_vol) - 1;

  var num_clipped = 0;

  // ...end of initialization. Generate samples.

  var sample_sum = 0;
  var num_summed = 0;
  var summands = Math.floor(44100 / ps.sample_rate);

  var buffer_i = 0;
  var buffer_length = Math.ceil(env_total_length / summands);
  var buffer_complete = false;

  var sound;
  if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
    // Assume 4x gets close enough to MIN_SAMPLE_RATE
    sound = new SoundEffect(4 * buffer_length, SoundEffect.MIN_SAMPLE_RATE);
  } else {
    sound = new SoundEffect(buffer_length, ps.sample_rate)
  }
  var buffer = sound.getBuffer();

  for (var t = 0;; ++t) {

    // Repeats
    if (rep_limit != 0 && ++rep_time >= rep_limit)
      repeat();

    // Arpeggio (single)
    if (arp_limit != 0 && t >= arp_limit) {
      arp_limit = 0;
      fperiod *= arp_mod;
    }

    // Frequency slide, and frequency slide slide!
    fslide += fdslide;
    fperiod *= fslide;
    if (fperiod > fmaxperiod) {
      fperiod = fmaxperiod;
      if (ps.p_freq_limit > 0.0)
        buffer_complete = true;
    }

    // Vibrato
    var rfperiod = fperiod;
    if (vib_amp > 0.0) {
      vib_phase += vib_speed;
      rfperiod = fperiod * (1.0 + Math.sin(vib_phase) * vib_amp);
    }
    period = Math.floor(rfperiod);
    if (period < 8) period = 8;

    square_duty += square_slide;
    if (square_duty < 0.0) square_duty = 0.0;
    if (square_duty > 0.5) square_duty = 0.5;

    // Volume envelope
    env_time++;
    if (env_time > env_length[env_stage]) {
      env_time = 1;
      env_stage++;
      while (env_stage < 3 && env_length[env_stage] === 0)
	env_stage++;
      if (env_stage === 3)
        break;
    }
    if (env_stage === 0)
      env_vol = env_time / env_length[0];
    else if (env_stage === 1)
      env_vol = 1.0 + Math.pow(1.0 - env_time / env_length[1],
                               1.0) * 2.0 * ps.p_env_punch;
    else  // env_stage == 2
      env_vol = 1.0 - env_time / env_length[2];

    // Phaser step
    fphase += fdphase;
    iphase = Math.abs(Math.floor(fphase));
    if (iphase > 1023) iphase = 1023;

    if (flthp_d != 0.0) {
      flthp *= flthp_d;
      if (flthp < 0.00001)
        flthp = 0.00001;
      if (flthp > 0.1)
        flthp = 0.1;
    }

    // 8x supersampling
    var sample = 0.0;
    for (var si = 0; si < 8; ++si) {
      var sub_sample = 0.0;
      phase++;
      if (phase >= period) {
        phase %= period;
        if (ps.wave_type === NOISE)
          for (var i = 0; i < 32; ++i)
            noise_buffer[i] = Math.random() * 2.0 - 1.0;
      }

      // Base waveform
      var fp = phase / period;
      if (ps.wave_type === SQUARE) {
        if (fp < square_duty)
          sub_sample = 0.5;
        else
          sub_sample = -0.5;
      } else if (ps.wave_type === SAWTOOTH) {
        sub_sample = 1.0 - fp * 2;
      } else if (ps.wave_type === SINE) {
        sub_sample = Math.sin(fp * 2 * Math.PI);
      } else if (ps.wave_type === NOISE) {
        sub_sample = noise_buffer[Math.floor(phase * 32 / period)];
      } else if (ps.wave_type === TRIANGLE) {
        sub_sample = Math.abs(1 - fp * 2) - 1;
      } else if (ps.wave_type === BREAKER) {
        sub_sample = Math.abs(1 - fp * fp * 2) - 1;
      } else {
        throw new Exception('bad wave type! ' + ps.wave_type);
      }

      // Low-pass filter
      var pp = fltp;
      fltw *= fltw_d;
      if (fltw < 0.0) fltw = 0.0;
      if (fltw > 0.1) fltw = 0.1;
      if (ps.p_lpf_freq != 1.0) {
        fltdp += (sub_sample - fltp) * fltw;
        fltdp -= fltdp * fltdmp;
      } else {
        fltp = sub_sample;
        fltdp = 0.0;
      }
      fltp += fltdp;

      // High-pass filter
      fltphp += fltp - pp;
      fltphp -= fltphp * flthp;
      sub_sample = fltphp;

      // Phaser
      phaser_buffer[ipp & 1023] = sub_sample;
      sub_sample += phaser_buffer[(ipp - iphase + 1024) & 1023];
      ipp = (ipp + 1) & 1023;

      // final accumulation and envelope application
      sample += sub_sample * env_vol;
    }

    // Accumulate samples appropriately for sample rate
    sample_sum += sample;
    if (++num_summed >= summands) {
      num_summed = 0;
      sample = sample_sum / summands;
      sample_sum = 0;
    } else {
      continue;
    }

    sample = sample / 8 * masterVolume;
    sample *= gain;

    buffer[buffer_i++] = sample;

    if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
    }
  }

  if (summands > 0) {
    sample = sample_sum / summands;

    sample = sample / 8 * masterVolume;
    sample *= gain;

    buffer[buffer_i++] = sample;

    if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
    }
  }

  return sound;
};

if (typeof exports != 'undefined') {
  // For node.js
  var RIFFWAVE = require('./riffwave').RIFFWAVE;
  exports.Params = Params;
  exports.generate = generate;
}

var sfxCache = {};
var cachedSeeds = [];
var CACHE_MAX = 50;

function cacheSeed(seed){
  if (seed in sfxCache) {
    return sfxCache[seed];
  }

  var params = generateFromSeed(seed);
  params.sample_rate = SAMPLE_RATE;
  params.bit_depth = BIT_DEPTH;

  var sound = SoundEffect.generate(params);
  sfxCache[seed] = sound;
  cachedSeeds.push(seed);

  while (cachedSeeds.length>CACHE_MAX) {
    var toRemove=cachedSeeds[0];
    cachedSeeds = cachedSeeds.slice(1);
    delete sfxCache[toRemove];
  }

  return sound;
}


function playSound(seed,ignore) {
  if (ignore!==true){
    pushSoundToHistory(seed);
  }
  if (muted){
    return;
  }
  checkAudioContextExists();
  if (unitTesting) return;
  var sound = cacheSeed(seed);
  sound.play();
}



function killAudioButton(){
  var mb = document.getElementById("muteButton");
  var umb = document.getElementById("unMuteButton");
  if (mb){
    mb.remove();
    umb.remove();
  }
}

function showAudioButton(){
  var mb = document.getElementById("muteButton");
  var umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="block"; 
    umb.style.display="none";
  }
}


function toggleMute() {
  if (muted===0){
    muteAudio();
  } else {
    unMuteAudio();
  }
}

function muteAudio() {
  muted=1; 
  var mb = document.getElementById("muteButton");
  var umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="none"; 
    umb.style.display="block";
  }
}
function unMuteAudio() {
  muted=0; 
  var mb = document.getElementById("muteButton");
  var umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="block"; 
    umb.style.display="none";
  }
}
</script>
<script>
//This script has just the CodeMirror bits to make shared & exported games work, without loading the entire thing
//from https://github.com/Auroriax/PuzzleScript/commit/463e8069218dbde0901627e8dac124d2856eb394
function CodeMirror(place, options) {};

CodeMirror.defineMode = function(name, mode) {};

var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

</script>
<script>
colorPalettesAliases = {
	1 : "mastersystem",
	2 : "gameboycolour",
	3 : "amiga",
	4 : "arnecolors",
	5 : "famicom",
	6 : "atari",
	7 : "pastel",
	8 : "ega",
	9 : "amstrad",
	10 : "proteus_mellow",
	11 : "proteus_rich",
	12 : "proteus_night",
	13 : "c64",
	14 : "whitingjp"
};

colorPalettes = {
	mastersystem : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#555555",
	darkgrey		: "#555500",
	lightgrey		: "#AAAAAA",
	gray			: "#555555",
	darkgray		: "#555500",
	lightgray		: "#AAAAAA",
	red				: "#FF0000",
	darkred			: "#AA0000",
	lightred		: "#FF5555",
	brown			: "#AA5500",
	darkbrown		: "#550000",
	lightbrown		: "#FFAA00",
	orange			: "#FF5500",
	yellow 			: "#FFFF55",
	green			: "#55AA00",
	darkgreen		: "#005500",
	lightgreen		: "#AAFF00",
	blue			: "#5555AA",
	lightblue		: "#AAFFFF",
	darkblue		: "#000055",
	purple			: "#550055",
	pink			: "#FFAAFF"
	},

	gameboycolour : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#7F7F7C",
	darkgrey		: "#3E3E44",
	lightgrey		: "#BAA7A7",
	gray			: "#7F7F7C",
	darkgray		: "#3E3E44",
	lightgray		: "#BAA7A7",
	red				: "#A7120C",
	darkred			: "#880606",
	lightred		: "#BA381F",
	brown			: "#57381F",
	darkbrown		: "#3E2519",
	lightbrown		: "#8E634B",
	orange			: "#BA4B32",
	yellow 			: "#C0BA6F",
	green			: "#517525",
	darkgreen		: "#385D12",
	lightgreen		: "#6F8E44",
	blue			: "#5D6FA7",
	lightblue		: "#8EA7A7",
	darkblue		: "#4B575D",
	purple			: "#3E3E44",
	pink			: "#BA381F"
	},

	amiga : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#BBBBBB",
	darkgrey		: "#333333",
	lightgrey		: "#FFEEDD",
	gray			: "#BBBBBB",
	darkgray		: "#333333",
	lightgray		: "#FFEEDD",
	red				: "#DD1111",
	darkred			: "#990000",
	lightred		: "#FF4422",
	brown			: "#663311",
	darkbrown		: "#331100",
	lightbrown		: "#AA6644",
	orange			: "#FF6644",
	yellow 			: "#FFDD66",
	green			: "#448811",
	darkgreen		: "#335500",
	lightgreen		: "#88BB77",
	blue			: "#8899DD",
	lightblue		: "#BBDDEE",
	darkblue		: "#666688",
	purple			: "#665555",
	pink			: "#997788"
	},

	arnecolors : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#9d9d9d",
	darkgrey		: "#697175",
	lightgrey		: "#cccccc",
	gray			: "#9d9d9d",
	darkgray		: "#697175",
	lightgray		: "#cccccc",
	red				: "#be2633",
	darkred			: "#732930",
	lightred		: "#e06f8b",
	brown			: "#a46422",
	darkbrown		: "#493c2b",
	lightbrown		: "#eeb62f",
	orange			: "#eb8931",
	yellow 			: "#f7e26b",
	green			: "#44891a",
	darkgreen		: "#2f484e",
	lightgreen		: "#a3ce27",
	blue			: "#1d57f7",
	lightblue		: "#B2DCEF",
	darkblue		: "#1B2632",
	purple			: "#342a97",
	pink			: "#de65e2"
	},
	famicom : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7c7c7c",
	darkgrey		: "#080808",
	lightgrey		: "#bcbcbc",
	gray			: "#7c7c7c",
	darkgray		: "#080808",
	lightgray		: "#bcbcbc",
	red				: "#f83800",
	darkred			: "#881400",
	lightred		: "#f87858",
	brown			: "#AC7C00",
	darkbrown		: "#503000",
	lightbrown		: "#FCE0A8",
	orange			: "#FCA044",
	yellow 			: "#F8B800",
	green			: "#00B800",
	darkgreen		: "#005800",
	lightgreen		: "#B8F8B8",
	blue			: "#0058F8",
	lightblue		: "#3CBCFC",
	darkblue		: "#0000BC",
	purple			: "#6644FC",
	pink			: "#F878F8"
	},

	atari : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#909090",
	darkgrey		: "#404040",
	lightgrey		: "#b0b0b0",
	gray			: "#909090",
	darkgray		: "#404040",
	lightgray		: "#b0b0b0",
	red				: "#A03C50",
	darkred			: "#700014",
	lightred		: "#DC849C",
	brown			: "#805020",
	darkbrown		: "#703400",
	lightbrown		: "#CB9870",
	orange			: "#CCAC70",
	yellow 			: "#ECD09C",
	green			: "#58B06C",
	darkgreen		: "#006414",
	lightgreen		: "#70C484",
	blue			: "#1C3C88",
	lightblue		: "#6888C8",
	darkblue		: "#000088",
	purple			: "#3C0080",
	pink			: "#B484DC"
	},
	pastel : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#3e3e3e",
	darkgrey		: "#313131",
	lightgrey		: "#9cbcbc",
	gray			: "#3e3e3e",
	darkgray		: "#313131",
	lightgray		: "#9cbcbc",
	red				: "#f56ca2",
	darkred			: "#a63577",
	lightred		: "#ffa9cf",
	brown			: "#b58c53",
	darkbrown		: "#787562",
	lightbrown		: "#B58C53",
	orange			: "#EB792D",
	yellow 			: "#FFe15F",
	green			: "#00FF4F",
	darkgreen		: "#2b732c",
	lightgreen		: "#97c04f",
	blue			: "#0f88d3",
	lightblue		: "#00fffe",
	darkblue		: "#293a7b",
	purple			: "#ff6554",
	pink			: "#eb792d"
	},
	ega : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#555555",
	darkgrey		: "#555555",
	lightgrey		: "#aaaaaa",
	gray			: "#555555",
	darkgray		: "#555555",
	lightgray		: "#aaaaaa",
	red				: "#ff5555",
	darkred			: "#aa0000",
	lightred		: "#ff55ff",
	brown			: "#aa5500",
	darkbrown		: "#aa5500",
	lightbrown		: "#ffff55",
	orange			: "#ff5555",
	yellow 			: "#ffff55",
	green			: "#00aa00",
	darkgreen		: "#00aaaa",
	lightgreen		: "#55ff55",
	blue			: "#5555ff",
	lightblue		: "#55ffff",
	darkblue		: "#0000aa",
	purple			: "#aa00aa",
	pink			: "#ff55ff"
	},


	proteus_mellow : {
	black   		: "#3d2d2e",
	white			: "#ddf1fc",
	grey			: "#9fb2d4",
	darkgrey		: "#7b8272",
	lightgrey		: "#a4bfda",
	gray			: "#9fb2d4",
	darkgray		: "#7b8272",
	lightgray		: "#a4bfda",
	red				: "#9d5443",
	darkred			: "#8c5b4a",
	lightred		: "#94614c",
	brown			: "#89a78d",
	darkbrown		: "#829e88",
	lightbrown		: "#aaae97",
	orange			: "#d1ba86",
	yellow 			: "#d6cda2",
	green			: "#75ac8d",
	darkgreen		: "#8fa67f",
	lightgreen		: "#8eb682",
	blue			: "#88a3ce",
	lightblue		: "#a5adb0",
	darkblue		: "#5c6b8c",
	purple			: "#d39fac",
	pink			: "#c8ac9e"
	},
	

	proteus_night : {
	black   		: "#010912",
	white			: "#fdeeec",
	grey			: "#051d40",
	darkgrey		: "#091842",
	lightgrey		: "#062151",
	gray			: "#051d40",
	darkgray		: "#091842",
	lightgray		: "#062151",
	red				: "#ad4576",
	darkred			: "#934765",
	lightred		: "#ab6290",
	brown			: "#61646b",
	darkbrown		: "#3d2d2d",
	lightbrown		: "#8393a0",
	orange			: "#0a2227",
	yellow 			: "#0a2541",
	green			: "#75ac8d",
	darkgreen		: "#0a2434",
	lightgreen		: "#061f2e",
	blue			: "#0b2c79",
	lightblue		: "#809ccb",
	darkblue		: "#08153b",
	purple			: "#666a87",
	pink			: "#754b4d"
	},
	


	proteus_rich: {
	black   		: "#6f686f",
	white			: "#d1b1e2",
	grey			: "#b9aac1",
	darkgrey		: "#8e8b84",
	lightgrey		: "#c7b5cd",
	gray			: "#b9aac1",
	darkgray		: "#8e8b84",
	lightgray		: "#c7b5cd",
	red				: "#a11f4f",
	darkred			: "#934765",
	lightred		: "#c998ad",
	brown			: "#89867d",
	darkbrown		: "#797f75",
	lightbrown		: "#ab9997",
	orange			: "#ce8c5c",
	yellow 			: "#f0d959",
	green			: "#75bc54",
	darkgreen		: "#599d79",
	lightgreen		: "#90cf5c",
	blue			: "#8fd0ec",
	lightblue		: "#bcdce7",
	darkblue		: "#0b2c70",
	purple			: "#9b377f",
	pink			: "#cd88e5"
	},
	

	
amstrad : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7f7f7f",
	darkgrey		: "#636363",
	lightgrey		: "#afafaf",
	gray			: "#7f7f7f",
	darkgray		: "#636363",
	lightgray		: "#afafaf",
	red				: "#ff0000",
	darkred			: "#7f0000",
	lightred		: "#ff7f7f",
	brown			: "#ff7f00",
	darkbrown		: "#7f7f00",
	lightbrown		: "#ffff00",
	orange			: "#ff007f",
	yellow 			: "#ffff7f",
	green			: "#01ff00",
	darkgreen		: "#007f00",
	lightgreen		: "#7fff7f",
	blue			: "#0000ff",
	lightblue		: "#7f7fff",
	darkblue		: "#00007f",
	purple			: "#7f007f",
	pink			: "#ff7fff"
	},
c64 : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#6C6C6C",
	darkgrey		: "#444444",
	lightgrey		: "#959595",
	gray			: "#6C6C6C",
	darkgray		: "#444444",
	lightgray		: "#959595",
	red				: "#68372B",
	darkred			: "#3f1e17",
	lightred		: "#9A6759",
	brown			: "#433900",
	darkbrown		: "#221c02",
	lightbrown		: "#6d5c0d",
	orange			: "#6F4F25",
	yellow 			: "#B8C76F",
	green			: "#588D43",
	darkgreen		: "#345129",
	lightgreen		: "#9AD284",
	blue			: "#6C5EB5",
	lightblue		: "#70A4B2",
	darkblue		: "#352879",
	purple			: "#6F3D86",
	pink			: "#b044ac"
},
whitingjp : {
  black       : "#202527",
  white       : "#eff8fd",
  grey        : "#7b7680",
  darkgrey    : "#3c3b44",
  lightgrey   : "#bed0d7",
  gray        : "#7b7680",
  darkgray    : "#3c3b44",
  lightgray   : "#bed0d7",
  red         : "#bd194b",
  darkred     : "#6b1334",
  lightred    : "#ef2358",
  brown       : "#b52e1c",
  darkbrown   : "#681c12",
  lightbrown  : "#e87b45",
  orange      : "#ff8c10",
  yellow      : "#fbd524",
  green       : "#36bc3c",
  darkgreen   : "#317610",
  lightgreen  : "#8ce062",
  blue        : "#3f62c6",
  lightblue   : "#57bbe0",
  darkblue    : "#2c2fa0",
  purple      : "#7037d9",
  pink        : "#ec2b8f"
}
};







</script>
<script>
// Functions to create and render text and sprites

// Create and return a graphic sprite canvas
function createSprite(name,spritegrid, colors, size) {
	colors ||= [state.bgcolor, state.fgcolor];

	var canvas = makeSpriteCanvas(name);
	var context = canvas.getContext('2d');

    canvas.width = spritegrid.reduce((acc, row) => Math.max(acc, row.length), 0) * pixelSize;
    canvas.height = spritegrid.length * pixelSize;

    renderSprite(context, spritegrid, colors, 0, 0, 0, size);

    return canvas;
}

// Create and return a text sprite canvas
function createTextSprite(name, text, colors, scale) {
	colors ||= [state.bgcolor, state.fgcolor];

	var canvas = makeSpriteCanvas(name);
	var context = canvas.getContext('2d');

    drawTextWithFont(context, text, colors, 
        0.5 * cellwidth, 0.5 * cellheight, 
        scale ? (scale * cellheight) : (cellheight / text.length));

    return canvas;
}

// Create and return a custom instructions sprite canvas
function createCanvasSprite(name, vector) {
    const canvas = makeSpriteCanvas(name);
    const context = canvas.getContext('2d');

    if (vector.w) canvas.width *= vector.w;
    if (vector.h) canvas.height *= vector.h;
    context.scale(cellwidth, cellheight);

    function addInstr(json) {
        for (const instr of json) {
            try {
                for (const [key, value] of Object.entries(instr)) {
                    if (key === "!include") {
                        const include = state.objects[value.toLowerCase()];
                        if (include) {
                            addInstr(include.vector.data);
                        } else {
                            logWarningNoLine("include object '" + value + "' not found");
                        }
                    } else if (context[key] instanceof Function) {
                        context[key].apply(context, value);
                    } else {
                        context[key] = value;
                    }
                }
            } catch (error) { // does this ever happen???
                console.log(error);
                logErrorNoLine(`Oops! Looks like there's something wrong with this bit of JSON: "${JSON.stringify(instr)}"`, true);
                logErrorNoLine(`The system returned this error message: ${error}`, true);
            }
        }
    }

    addInstr(vector.data);
    return canvas;
}

// Create and return a SVG template sprite canvas
function createSvgSprite(name, vector) {
    const canvas = makeSpriteCanvas(name);
    if (vector.w) canvas.width *= vector.w;
    if (vector.h) canvas.height *= vector.h;
    const context = canvas.getContext('2d');
    const body = vector.data.join("\n");
    const svg = body;
    const blob = new Blob([svg], {type: 'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const image = document.createElement('img');
    image.src = url;
    image.addEventListener('load', function () {
        context.drawImage(image, 0, 0);
        URL.revokeObjectURL(url);
        redraw();
    }, false);
    return canvas;
}

// draw the pixels of the sprite grid data into the context at a cell position, 
function renderSprite(context, spritegrid, colors, padding, x, y, size) {
    colors ||= ['#00000000', state.fgcolor];

    const rc = { 
        x: x * cellwidth, // global
        y: y * cellheight, 
        w: size || spritegrid[0].length, 
        h: size || spritegrid.length,
    };

    context.clearRect(rc.x, rc.y, rc.w, rc.h);

    // always assume square pixels at this stage?
    const pixh = ("scanline" in state.metadata) ? pixelSize / 2 : pixelSize;

    context.fillStyle = state.fgcolor;
    spritegrid.forEach((row,y) => {
        row.forEach((col,x) => {
            if (col >= 0) {
                context.fillStyle = colors[col];
                context.fillRect(rc.x + x * pixelSize, rc.y + y * pixelSize, pixelSize, pixh);
            }            
        });
    });
}

function drawTextWithFont(ctx, text, color, x, y, height) {
    const fontSize = state.metadata.font_size ? Math.max(0, parseFloat(state.metadata.font_size)) : 1;
    const pixelsize = height * fontSize;
    const fontname = (state.metadata.custom_font && loadedCustomFont) ? "PuzzleCustomFont" : "Monospace";
    ctx.font = `${pixelsize}px ${fontname}`;
    ctx.fillStyle = color;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillText(text, x, y);
    //console.log(`ctx=${ctx} color=${color} x=${x} y=${y} height=${height} font=${ctx.font} text=${text} `);

}

// create a single text sheet canvas containing all the character glyphs
var textsheetCanvas = null;

function regenText() {
    textsheetCanvas ||= document.createElement('canvas');

    var textsheetSize = Math.ceil(Math.sqrt(fontKeys.length));

    textsheetCanvas.width = textsheetSize * cellwidth;
    textsheetCanvas.height = textsheetSize * cellheight * 2;

    var textsheetContext = textsheetCanvas.getContext('2d');

    for (var n = 0; n < fontKeys.length; n++) {
        var key = fontKeys[n];
        if (font.hasOwnProperty(key)) {
            fontstr = font[key].split('\n').map(a=>a.trim().split('').map(t=>parseInt(t)));
            fontstr.shift();

            var textX = (n % textsheetSize)|0;
            var textY = (n / textsheetSize)|0;

            renderSprite(textsheetContext, fontstr, undefined, 1, textX, textY);
            renderSprite(textsheetContext, fontstr, ['#00000000', '#000000'], 1, textX, textY + textsheetSize);
        }
    }
}

var editor_s_grille=[[0,1,1,1,0],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[0,1,1,1,0]];

var spriteImages;

function createVectorSprite(name, vector) {
    const canvas = (vector.type === 'canvas') ? createCanvasSprite(name, vector)
        : vector.type === 'svg' ? createSvgSprite(name, vector)
        : null;
    return canvas;
}

function regenSpriteImages() {
	if (textMode) {
        spriteImages = [];
		regenText();
		return;
	} 
    
    if (IDE===true) {
        textImages['editor_s'] = createSprite('chars', editor_s_grille, undefined, 5);
    }
    
    if (state.levels.length===0) {
        return;
    }
    spriteImages = [];
    
    objectSprites.forEach((s,i) => {
        if (s) {
            spriteImages[i] =
                    s.text ? createTextSprite('t' + i.toString(), s.text, s.colors, s.scale)
                : s.vector ? createVectorSprite('v' + i.toString(), s.vector)
            : createSprite(i.toString(), s.dat, s.colors, state.sprite_size);
        }
    });

    if (canOpenEditor) {
    	generateGlyphImages();
    }
}

var glyphImagesCorrespondance;
var glyphImages;
var glyphHighlight;
var glyphHighlightDiff;
var glyphHighlightResize;
var glyphPrintButton;
var glyphMouseOver;
var glyphSelectedIndex=0;
var editorRowCount=1;
var editorGlyphMovements=[];

// create or reuse a canvas by this name
var canvasdict={};
function makeSpriteCanvas(name) {
    var canvas;
    if (name in canvasdict) {
        canvas = canvasdict[name];
    } else {
        canvas = document.createElement('canvas');
        canvasdict[name]=canvas;
    }
	canvas.width = cellwidth;
	canvas.height = cellheight;
	return canvas;
}


function generateGlyphImages() {
    if (cellwidth===0||cellheight===0) {
        return;
    }
	glyphImagesCorrespondance=[];
	glyphImages=[];
	
    seenobjects = {};
	for (var n of state.glyphOrder) {
		if (n.length==1 && state.glyphDict.hasOwnProperty(n)) {            
			var g=state.glyphDict[n];

            /* hide duplicate entries from editor palette*/
            var trace = g.join(",");
            if (seenobjects.hasOwnProperty(trace)){
                continue;
            }
            
			var sprite = makeSpriteCanvas("C"+n)
			var spritectx = sprite.getContext('2d');
			glyphImagesCorrespondance.push(n);
            seenobjects[trace]=true;

			for (var i=0;i<g.length;i++){
				var id = g[i];
				if (id===-1) {
					continue;
                }
				spritectx.drawImage(spriteImages[id], 0, 0);
			}
			glyphImages.push(sprite);
		}
	}

	if (IDE) {
		//make highlight thingy
		glyphHighlight = makeSpriteCanvas("highlight");
		var spritectx = glyphHighlight.getContext('2d');
		spritectx.fillStyle = '#FFFFFF';

        const hlwid = 3;
        spritectx.fillRect(0, 0, cellwidth, hlwid);
        spritectx.fillRect(0, 0, hlwid, cellheight);

        spritectx.fillRect(0, cellheight - hlwid, cellwidth, hlwid);
        spritectx.fillRect(cellwidth - hlwid, 0, hlwid, cellheight);

		glyphPrintButton = textImages['editor_s'];

		//make diff highlighter thingy
		glyphHighlightDiff = makeSpriteCanvas("glyphHighlightDiff");
		var spritectx = glyphHighlightDiff.getContext('2d');
        
		spritectx.fillStyle =  state.bgcolor;

		spritectx.fillRect(0,0,cellwidth,2);
		spritectx.fillRect(0,0,2,cellheight);
		
		spritectx.fillRect(0,cellheight-2,cellwidth,2);
		spritectx.fillRect(cellwidth-2,0,2,cellheight);

		spritectx.fillStyle = state.fgcolor;

		spritectx.fillRect(0,0,cellwidth,1);
		spritectx.fillRect(0,0,1,cellheight);
		
		spritectx.fillRect(0,cellheight-1,cellwidth,1);
		spritectx.fillRect(cellwidth-1,0,1,cellheight);

		glyphPrintButton = textImages['editor_s'];

		//make highlight thingy
		glyphHighlightResize = makeSpriteCanvas("highlightresize");
		var spritectx = glyphHighlightResize.getContext('2d');
		spritectx.fillStyle = '#FFFFFF';
		
        const rswid = 3;
        const minx = ~~(cellwidth / 2 - 1);
        const miny = ~~(cellheight / 2 - 1);
		spritectx.fillRect(minx, 0, rswid, cellheight);
		spritectx.fillRect(0, miny, cellwidth, rswid);

		//make highlight thingy
		glyphMouseOver = makeSpriteCanvas("glyphMouseOver");
		var spritectx = glyphMouseOver.getContext('2d');
		spritectx.fillStyle = 'yellow';
		const mowid = 3;  // was 2

        spritectx.fillRect(0, 0, cellwidth, mowid);
        spritectx.fillRect(0, 0, mowid, cellheight);

        spritectx.fillRect(0, cellheight - mowid, cellwidth, mowid);
        spritectx.fillRect(cellwidth - mowid, 0, mowid, cellheight);

        //make movement glyphs

        const coords = [
            //0 up
            [ [3,2],[5,0],[7,2]],
            //1 down
            [ [3,8],[5,10],[7,8]],
            //2 left
            [ [2,3],[0,5],[2,7]],
            //3 right
            [ [7,3],[10,5],[7,7]],
            //4 action
            [ [3,5],[5,7],[7,5],[5,3]],
            //5 rigid
            [ [3,3],[5,3],[5,4],[4,4],[4,5],[3,5]],
            //6 lclick
            [ [4,4],[1,4],[1,7]],
            //7 rclick
            [ [6,4],[9,4],[9,7]],
        ];

        for (var i=0;i<coords.length;i++){
            editorGlyphMovements[i]=makeSpriteCanvas("editorGlyphMovements"+i);
            var path = coords[i];

            var spritectx = editorGlyphMovements[i].getContext('2d');
            spritectx.lineWidth=1;
            
            
		    spritectx.fillStyle =  state.bgcolor;
		    spritectx.strokeStyle = state.fgcolor;


            spritectx.beginPath();       // Start a new path
            spritectx.moveTo(path[0][0]*cellwidth/10.0, path[0][1]*cellheight/10.0);    
            for (var j=1;j<path.length;j++){
                spritectx.lineTo(path[j][0]*cellwidth/10.0, path[j][1]*cellheight/10.0);   
            }
            spritectx.closePath();
            spritectx.fill();
            spritectx.stroke();          // Render the path        
        }
	}
}

var canvas;
var ctx;


var x;
var y;
var cellwidth;
var cellheight;
var xoffset;
var yoffset;
let pixelSize;

// takes a level argument, not an event
window.addEventListener('resize', (e) => canvasResize(), false);
canvas = document.getElementById('gameCanvas');
ctx = canvas.getContext('2d');
x = 0;
y = 0;

// length of visible row for mouse wheel
function glyphCount() {
    return state.glyphOrder.filter(g => g.length == 1).length;
}

function redraw() {
    if (cellwidth===0||cellheight===0) {
        return;
    }
    if (debugSwitch.includes('perf')) console.log(`Redraw: ${JSON.stringify(perfCounters)}`);

    if (textMode)
        redrawTextMode();
    else redrawCellGrid(curLevel);
}

// option to draw custom font text in cells could be a prelude setting if desired
const textModeLine = true;

function redrawTextMode() {
    const lineColor = j => lineColorOverride[j] || state.fgcolor;
    ctx.fillStyle = state.bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if(state.metadata.custom_font === undefined || !loadedCustomFont) { 
        const textsheetSize = Math.ceil(Math.sqrt(fontKeys.length));
        for (var i = 0; i < TITLE_WIDTH; i++) {
            for (var j = 0; j < TITLE_HEIGHT; j++) {
                ctx.fillStyle = lineColor(j);
                var ch = titleImage[j].charAt(i);
                if (ch in font) {
                    var index = fontIndex[ch];
                    var textX = (index % textsheetSize)|0;
                    var textY = (index / textsheetSize)|0;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        textsheetCanvas,
                        textX * textcellwidth,
                        textY * textcellheight,
                        textcellwidth, textcellheight,
                        xoffset + i * cellwidth,
                        yoffset + j * cellheight,
                        cellwidth, cellheight
                    );
                    ctx.imageSmoothingEnabled = true;
                }
            }
        }
    } else if (textModeLine) {
        for(let j = 0; j < TITLE_HEIGHT; j++) {
            drawTextWithFont(ctx, titleImage[j], lineColor(j), 
                xoffset + (TITLE_WIDTH/2+0.5) * cellwidth, yoffset + (j+0.5) * cellheight, cellheight);
        }
    } else {
        for (var i = 0; i < TITLE_WIDTH; i++) {
            for(let j = 0; j < TITLE_HEIGHT; j++) {
                drawTextWithFont(ctx, titleImage[j].slice(i, i+1), lineColor(j), 
                    xoffset + (i+0.5) * cellwidth, yoffset + (j+0.5) * cellheight, cellheight);
            }
        }
    }
}
   
// redraw the cell grid including all modes and animations
function redrawCellGrid(curlevel) {
    //var curlevel = level;
    if (diffToVisualize!==null){
        curlevel = new Level(-1,diffToVisualize.width,diffToVisualize.height,diffToVisualize.layerCount,diffToVisualize.objects);
        curlevel.movements = diffToVisualize.movements;
        curlevel.rigidMovementAppliedMask = diffToVisualize.rigidMovementAppliedMask;
    }
    ctx.fillStyle = state.bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let minMaxIJ = [ 0, 0, screenwidth, screenheight ];

    var cameraOffset = {
        x: 0,
        y: 0
    };

    if (flickscreen) {
        var playerPositions = getPlayerPositions();
        if (playerPositions.length>0) {
            var playerPosition=playerPositions[0];
            var px = (playerPosition/(curlevel.height))|0;
            var py = (playerPosition%curlevel.height)|0;

            const screenx = (px / screenwidth) | 0;
            const screeny = (py / screenheight) | 0;
            const mini = screenx * screenwidth;
            const minj = screeny * screenheight;
            minMaxIJ = [mini, minj, Math.min(mini + screenwidth, curlevel.width), Math.min(minj + screenheight, curlevel.height)];

            oldflickscreendat = minMaxIJ;
        } else if (oldflickscreendat.length>0){
            minMaxIJ = oldflickscreendat;
        }
    } else if (zoomscreen) {
        var playerPositions = getPlayerPositions();
        if (playerPositions.length>0) {
            const playerPosition = playerPositions[0];
            const px = (playerPosition / (curlevel.height)) | 0;
            const py = (playerPosition % curlevel.height) | 0;
            const mini = Math.max(Math.min(px - ((screenwidth / 2) | 0), curlevel.width - screenwidth), 0);
            const minj = Math.max(Math.min(py - ((screenheight / 2) | 0), curlevel.height - screenheight), 0);
            minMaxIJ = [mini, minj, Math.min(mini + screenwidth, curlevel.width), Math.min(minj + screenheight, curlevel.height)];
            oldflickscreendat = minMaxIJ;
        }  else if (oldflickscreendat.length>0){
            minMaxIJ = oldflickscreendat;
        }         
    } else if (smoothscreen) {
        if (cameraPositionTarget !== null) {
            ['x', 'y'].forEach(function (coord) {
                var cameraTargetVector = cameraPositionTarget[coord] - cameraPosition[coord];

                if (cameraTargetVector === 0) {
                    return;
                } else if (Math.abs(cameraTargetVector) < (0.5 / cellwidth)) {
                    // Canvas doesn't actually render subpixels, but when the camera is less than half a subpixel away from target, snap to target
                    cameraPosition[coord] = cameraPositionTarget[coord]
                    return
                }

                cameraPosition[coord] += cameraTargetVector * state.metadata.smoothscreen.cameraSpeed;
                //console.log(coord + " "+ cameraPosition[coord])
                cameraOffset[coord] = cameraPosition[coord] % 1;
            })
            const mini = Math.max(Math.min(Math.floor(cameraPosition.x) - Math.floor(screenwidth / 2), curlevel.width - screenwidth), 0);
            const minj = Math.max(Math.min(Math.floor(cameraPosition.y) - Math.floor(screenheight / 2), curlevel.height - screenheight), 0);
            minMaxIJ = [mini, minj, Math.min(mini + screenwidth, curlevel.width), Math.min(minj + screenheight, curlevel.height)];
            oldflickscreendat = minMaxIJ;
        } else if (oldflickscreendat.length>0) {
            minMaxIJ = oldflickscreendat;
        }

    }
    
    // used in function isInside
    screenOffsetX = minMaxIJ[0];
    screenOffsetY = minMaxIJ[1];

    var renderBorderSize = smoothscreen ? 1 : 0;

////////////////////////////////////////////////////////////////////////////////
    class RenderOrder {
        constructor(minMax) {
            this.minMax = minMax;
            // the iteration limits still used by smooth screen renderer
            this.iter = [
                Math.max(this.minMax[0] - renderBorderSize, 0),  // globals
                Math.max(this.minMax[1] - renderBorderSize, 0),
                Math.min(this.minMax[2] + renderBorderSize, curlevel.width),
                Math.min(this.minMax[3] + renderBorderSize, curlevel.height)
            ];
        }
        getIter() {
            return this.iter;
        }
        
        // the position indexes to render, taking into account layer groups, zoomscreen etc
        getPosIndexes(group) {  // todo:
            const ch = curlevel.height; // global
            const funcs = {      // outer loop            inner loop
                downright: i => [ i[0],   i[2],    1, ch, i[1],   i[3],    1,  1 ],
                downleft:  i => [ i[2]-1, i[0]-1, -1, ch, i[1],   i[3],    1,  1 ],
                upright:   i => [ i[0],   i[2],    1, ch, i[3]-1, i[1]-1, -1,  1 ],
                upleft:    i => [ i[2]-1, i[0]-1, -1, ch, i[3]-1, i[1]-1, -1,  1 ],
                rightdown: i => [ i[1],   i[3],    1,  1, i[0],   i[2],    1, ch ],
                leftdown:  i => [ i[3]-1, i[1]-1, -1,  1, i[0],   i[2],    1, ch ],
                rightup:   i => [ i[1],   i[3],    1,  1, i[2]-1, i[0]-1, -1, ch ],
                leftup:    i => [ i[3]-1, i[1]-1, -1,  1, i[2]-1, i[0]-1, -1, ch ],
            };
            
            function doIter (i0, i1, ix, im, j0, j1, jx, jm) {
                const posindexes = [];
                for (let i = i0; i != i1; i += ix) {
                    for (let j = j0; j != j1; j += jx) {
                        posindexes.push(i * im + j * jm);
                    }
                }
                return posindexes;
            }
            
            return doIter( ...funcs[group.dirFirst + group.dirSecond](this.iter) );
        }
        getDrawPos(posindex, obj) {
            const ij = { 
                x: ~~(posindex / curlevel.height), 
                y: posindex % curlevel.height 
            }; // globals
            const offs = { 
                x: obj.spriteoffset.x, 
                y: obj.spriteoffset.y + (obj.spritematrix.length == 0 ? 0 : state.sprite_size - obj.spritematrix.length)
            };
            return {
                x: xoffset + (ij.x - this.minMax[0]-cameraOffset.x) * cellwidth + offs.x * ~~(cellwidth / state.sprite_size),
                y: yoffset + (ij.y - this.minMax[1]-cameraOffset.y) * cellheight + offs.y * ~~(cellheight / state.sprite_size)
            };

        }
    }

    var tweening = state.metadata.tween_length && currentMovedEntities;
    // global flag to force redraw
    isAnimating = state.metadata.smoothscreen || tweening || Object.keys(seedsToAnimate).length > 0;

    const render = new RenderOrder(minMaxIJ);
    if (!levelEditorOpened)
        setClip(render);
    if (tweening) 
        drawObjectsTweening(render.getIter());
    else drawObjects(render);

    if (state.metadata.status_line)
        drawTextWithFont(ctx, statusText, state.fgcolor, 
            xoffset + screenwidth * cellwidth / 2, yoffset + screenheight * cellheight + textcellheight * 0.6, textcellheight * 0.6);

    if (diffToVisualize)
        drawDiffToVisualize();
    if (smoothscreen) {
        if (state.metadata.smoothscreen.debug)
            drawSmoothScreenDebug(ctx);
        ctx.restore();
    }

    if (levelEditorOpened)
        drawEditorIcons(minMaxIJ[0], minMaxIJ[1]);

    //----- functions -----
    // Default draw loop, including when animating
    function drawObjects(render) {
        showLayerNo = Math.max(0, Math.min(curlevel.layerCount - 1, showLayerNo));
        const tween = 1 - clamp(tweentimer/animateinterval, 0, 1);  // range 1 => 0
        if (tween == 0) 
            seedsToAnimate = {};

        // Decision required whether to follow P:S pivot (top left)
        const spriteScaler = state.metadata.sprite_size ? { 
            scale: state.sprite_size, 
            pivotx: 0.0, // todo
            pivoty: 1.0 
        } : null;

        // draw each group of objects in all the places they occur, in specified order
        for (const group of state.collisionLayerGroups) {
            for (const posindex of render.getPosIndexes(group)) {
                const posmask = curlevel.getCellInto(posindex,_o12);    
                for (let k = group.firstObjectNo; k < group.firstObjectNo + group.numObjects; ++k) {
                    const animate = (isAnimating) ? seedsToAnimate[posindex+','+k] : null;
                    if (posmask.get(k) || animate) {
                        const obj = state.objects[state.idDict[k]];
                        if (showLayers && obj.layer != showLayerNo)
                            continue;

                        let spriteScale = 1;
                        //if (spriteScaler) spriteScale *= Math.max(obj.spritematrix.length, obj.spritematrix[0].length) / spriteScaler.scale;
                        //if (obj.scale) spriteScale *= obj.scale;
                        const drawpos = render.getDrawPos(posindex, obj);
                        const vector = obj.vector;
                        const params = {
                            x: 0, y: 0,
                            scalex: 1.0, scaley: 1.0,
                            alpha: 1.0,
                            angle: vector ? vector.angle : 0.0,
                        };
                        if (animate) 
                            params = calcAnimate(animate.seed.split(':').slice(1), animate.kind, animate.dir, params, tween);

                        // size of the sprite in pixels
                        const spriteSize = vector ? {
                            w: (vector.w || 1) * cellwidth,
                            h: (vector.h || 1) * cellheight,
                        } : {
                            w: obj.spritematrix.reduce((acc, row) => Math.max(acc, row.length), 0) * pixelSize,
                            h: obj.spritematrix.length * pixelSize,
                        };

                        // calculate the destination rectangle
                        const rc = { 
                            x: Math.floor(drawpos.x + params.x * cellwidth), 
                            y: Math.floor(drawpos.y + params.y * cellheight),
                            w: params.scalex * spriteSize.w * spriteScale, 
                            h: params.scaley * spriteSize.h * spriteScale 
                        };
                        //console.log(`draw obj:${state.idDict[k]} dp,sz,rc:`, drawpos, spriteSize, rc);
                        ctx.globalAlpha = params.alpha;
                        if (vector) {
                            // https://stackoverflow.com/questions/8168217/html-canvas-how-to-draw-a-flipped-mirrored-image
                            const rcw = vector && vector.flipx ? -rc.w : rc.w;
                            const rch = vector && vector.flipy ? -rc.h : rc.h;
                            ctx.translate(rc.x + rc.w/2, rc.y + rc.h/2);
                            ctx.rotate(params.angle * Math.PI / 180);
                            ctx.scale(vector.flipx ? -1 : 1, vector.flipy ? -1 : 1); //@@
                            ctx.drawImage(
                                spriteImages[k], 0, 0, spriteSize.w, spriteSize.h, 
                                -rcw/2, -rch/2, rcw, rch);
                        } else if (params.angle != 0) {
                            ctx.translate(rc.x + rc.w/2, rc.y + rc.h/2);
                            ctx.rotate(params.angle * Math.PI / 180);
                            ctx.drawImage(
                                spriteImages[k], 0, 0, spriteSize.w, spriteSize.h, 
                                -rc.w/2, -rc.h/2, rc.w, rc.h);
                        } else {
                            ctx.drawImage(
                                spriteImages[k], 0, 0, spriteSize.w, spriteSize.h, 
                                rc.x, rc.y, rc.w, rc.h);
                        }
                        ctx.globalAlpha = 1;
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                    }
                }
            }
        }
    } 

    // update animation parameters based on kind and dir, based on tween curve
    function calcAnimate(afx, kind, dir, params, tween) {
        const tween_table = {
            move:   { slide: [-1,0],    zoom: [0,1],       turn: [0,.25],       fade: [0,1] },
            cant:   { slide: [0,.2,0],  zoom: [1,1.2,1],   turn: [0,.1,0],      fade: [1,.5,1] },
            hit:    { slide: [0,.2,0],  zoom: [1,1.2,1],   turn: [0,-.1,.1,0],  fade: [1,.5,1] },
            create: { slide: [1,0],     zoom: [0,1],       turn: [-.125,0],     fade: [0,1] },
            destroy:{ slide: [0,1],     zoom: [1,0],       turn: [0,.125],      fade: [1,0] },
        }
    
        // tweening funcs
        const tfuncs = {
            slide: (p,t) => { 
                const delta = [1,2,4,8].includes(dir) ? dirMasksDelta[dir] : [ 0, -1 ]; // up
                p.x = t * delta[0]; 
                p.y = t * delta[1]; 
            },
            zoom: (p,t) => { 
                p.scalex = p.scaley = t; 
                p.x = p.y = 0.5 - p.scalex/2;  
            },
            fade: (p,t) => { p.alpha = t; },
            turn: (p,t) => { p.angle = t * 360; },
        }

        // param funcs
        const pfuncs = {
            ease: (p,a,t) => { tween = easingFunction(a)(tween); },
            tween: (p,a,t) => { tween = a; },  // wrong!?
        }
        
        for (x of afx) {
            const xs = x.split('=');
            if (tfuncs[xs[0]]) {
                if (kind == 'move' && ![1,2,4,8].includes(dir))
                    kind = 'hit';
                const tweens = xs[1] ? xs[1].split(',').map(p => parseFloat(p) || 0)
                    : tween_table[kind][xs[0]];
                const twx = (1 - tween) * (tweens.length - 1);
                const tdiv = ~~twx;
                const tmod = twx - tdiv;
                const t = tweens[tdiv] + (tweens[tdiv + 1] - tweens[tdiv]) * tmod;
                tfuncs[xs[0]](params, t);
            } else if (pfuncs[xs[0]]) {
                pfuncs[xs[0]](params, xs[1], t);
            }

        }
        return params;
    }

    // Draw loop used when tweening
    function drawObjectsTweening(iter) {
        // assume already validated
        const easing = state.metadata.tween_easing || 'linear';
        const snap = state.metadata.tween_snap || state.sprite_size;
        let tween = EasingFunctions[easing](1-clamp(tweentimer/tweeninterval, 0, 1));
        tween = Math.floor(tween * snap) / snap;

        for (var k = 0; k < state.idDict.length; k++) {
            var object = state.objects[state.idDict[k]];
            var layerID = object.layer;

            for (var i = iter[0]; i < iter[2]; i++) {
                for (var j = iter[1]; j < iter[3]; j++) {
                    var posIndex = j + i * curlevel.height;
                    var posMask = curlevel.getCellInto(posIndex,_o12);                
                
                    if (posMask.get(k) != 0) {                  

                        var x = xoffset + (i-minMaxIJ[0]-cameraOffset.x) * cellwidth;
                        var y = yoffset + (j-minMaxIJ[1]-cameraOffset.y) * cellheight;

                        if (currentMovedEntities && currentMovedEntities["p"+posIndex+"-l"+layerID]) {
                            var dir = currentMovedEntities["p"+posIndex+"-l"+layerID];

                            if (dir != 16) { //Cardinal directions
                                var delta = dirMasksDelta[dir];
            
                                x -= cellwidth*delta[0]*tween
                                y -= cellheight*delta[1]*tween
                            } else if (dir == 16) { //Action button
                                ctx.globalAlpha = 1-tween;
                            }
                        }
                        
                        ctx.drawImage(
                            spriteImages[k], 0, 0, cellwidth, cellheight,
                            Math.floor(x), Math.floor(y), cellwidth, cellheight);
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }
    }

    function drawDiffToVisualize() {
        //find previous state (this is never called on the very first state, the one before player inputs are applied, so there is always a previous state)
        var prevstate_lineNumberIndex=diffToVisualize.lineNumber-1;
        for (;prevstate_lineNumberIndex>=-1;prevstate_lineNumberIndex--)
        {
            if (debug_visualisation_array[diffToVisualize.turnIndex].hasOwnProperty(prevstate_lineNumberIndex)){
                break;
            }
        }

        var prev_state = debug_visualisation_array[diffToVisualize.turnIndex][prevstate_lineNumberIndex];
        var prevlevel = new Level(-1,prev_state.width,prev_state.height,prev_state.layerCount,prev_state.objects);
        prevlevel.movements = prev_state.movements;
        prevlevel.rigidMovementAppliedMask = prev_state.rigidMovementAppliedMask;
    
        for (var i = minMaxIJ[0]; i < minMaxIJ[2]; i++) {
            for (var j = minMaxIJ[1]; j < minMaxIJ[3]; j++) {
                var posIndex = j + i * curlevel.height;
                var movementbitvec_PREV = prevlevel.getMovements(posIndex);
                var movementbitvec = curlevel.getMovements(posIndex);
                
                var posMask_PREV = prevlevel.getCellInto(posIndex,_o11); 
                var posMask = curlevel.getCellInto(posIndex,_o12); 
                if (!movementbitvec.equals(movementbitvec_PREV) || !posMask.equals(posMask_PREV)){
                    ctx.drawImage(glyphHighlightDiff, xoffset + (i-minMaxIJ[0]) * cellwidth, yoffset + (j-minMaxIJ[1]) * cellheight);

                }
            }
        }
    
        //draw movements!
        for (var i = minMaxIJ[0]; i < minMaxIJ[2]; i++) {
            for (var j = minMaxIJ[1]; j < minMaxIJ[3]; j++) {
                var posIndex = j + i * curlevel.height;
                var movementbitvec = curlevel.getMovements(posIndex);
                for (var layer=0;layer<curlevel.layerCount;layer++) {
                    var layerMovement = movementbitvec.getshiftor(MOV_MASK, MOV_BITS * layer);
                    const k = [ 1, 2, 4, 8, 16, -1, 19, 20 ].indexOf(layerMovement);
                    if (k >= 0) {
                        ctx.drawImage(editorGlyphMovements[k], xoffset + (i - minMaxIJ[0]) * cellwidth, yoffset + (j - minMaxIJ[1]) * cellheight);
                    }
                }                             
            }
        }
    
        //draw rigid applciations!
        for (var i = minMaxIJ[0]; i < minMaxIJ[2]; i++) {
            for (var j = minMaxIJ[1]; j < minMaxIJ[3]; j++) {
                var posIndex = j + i * curlevel.height;
                var rigidbitvec = curlevel.getRigids(posIndex);
                for (var layer=0;layer<curlevel.layerCount;layer++) {
                    var layerRigid = rigidbitvec.getshiftor(MOV_MASK, MOV_BITS * layer);
                    if (layerRigid!==0) {
                        ctx.drawImage(editorGlyphMovements[5], xoffset + (i-minMaxIJ[0]) * cellwidth, yoffset + (j-minMaxIJ[1]) * cellheight);                            
                    }
                }                             
            }
        }
    }
}

function drawSmoothScreenDebug(ctx) {
    ctx.save();

    var smoothscreenConfig = state.metadata.smoothscreen;
    var boundarySize = smoothscreenConfig.boundarySize;

    var playerPositions = getPlayerPositions();
    if (playerPositions.length > 0) {
        var playerPosition = {
            x: (playerPositions[0]/(curLevel.height))|0,
            y: (playerPositions[0]%curLevel.height)|0
        };

        var playerOffsetX = playerPosition.x - cameraPosition.x;
        var playerOffsetY = playerPosition.y - cameraPosition.y;

        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(
            xoffset + (Math.floor(screenwidth / 2) + playerOffsetX + 0.5) * cellwidth,
            yoffset + (Math.floor(screenheight / 2) + playerOffsetY + 0.5) * cellheight,
            cellwidth / 4,
            0, 2* Math.PI
        );
        ctx.fill()
    }

    var targetOffsetX = cameraPositionTarget.x - cameraPosition.x;
    var targetOffsetY = cameraPositionTarget.y - cameraPosition.y;

    ctx.fillStyle = '#0000ff';
    ctx.beginPath();
    ctx.arc(
        xoffset + (Math.floor(screenwidth / 2) + targetOffsetX) * cellwidth,
        yoffset + (Math.floor(screenheight / 2) + targetOffsetY) * cellheight,
        cellwidth / 8,
        0, 2* Math.PI
    );
    ctx.fill()

    ctx.strokeStyle = '#0000ff';
    ctx.lineWidth = cellwidth / 16;
    ctx.strokeRect(
        xoffset + (Math.floor(screenwidth / 2) + targetOffsetX - Math.floor(boundarySize.width / 2)) * cellwidth,
        yoffset + (Math.floor(screenheight / 2) + targetOffsetY - Math.floor(boundarySize.height / 2)) * cellheight,
        boundarySize.width * cellwidth,
        boundarySize.height * cellheight
    );

    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(
        xoffset + Math.floor(screenwidth / 2) * cellwidth,
        yoffset + Math.floor(screenheight / 2) * cellheight,
        cellwidth / 4,
        0, 2* Math.PI
    );
    ctx.fill()

    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = cellwidth / 8;
    ctx.strokeRect(
        xoffset + (Math.floor(screenwidth / 2) - Math.floor(boundarySize.width / 2)) * cellwidth,
        yoffset + (Math.floor(screenheight / 2) - Math.floor(boundarySize.height / 2)) * cellheight,
        boundarySize.width * cellwidth,
        boundarySize.height * cellheight
    );

    ctx.restore()
}

function setClip(tween) {
    const rc = {
        x: xoffset,
        y: yoffset,
        w: (tween.iter[2] - tween.iter[0]) * cellwidth,
        h: (tween.iter[3] - tween.iter[1]) * cellheight + statusLineHeight,
    };
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(rc.x, rc.y);
    ctx.lineTo(rc.x + rc.w, rc.y);
    ctx.lineTo(rc.x + rc.w, rc.y + rc.h);
    ctx.lineTo(rc.x, rc.y + rc.h);
    ctx.clip();
}

function drawEditorIcons(mini,minj) {
    // major rework using objects
    const inRect = (pt,rc) => pt.x >= rc.x && pt.x < rc.x + rc.w && pt.y >= rc.y && pt.y < rc.y + rc.h;
    const cellSize = { w: cellwidth, h: cellheight };
    // glyph panel rectangle in cells, origin same as main board
    const panelRect = { x: 0, y: -editorRowCount - 1, w: screenwidth + 1, h: editorRowCount };
    // mouse position rebased to within panel
    const mousePos = { x: mouseCoordX, y: mouseCoordY };
    const mousePanelPos = inRect(mousePos, panelRect) ? { x: mousePos.x - panelRect.x, y: mousePos.y - panelRect.y } : { x: NaN, y: NaN };
    // index into glyphs
    const mouseIndex = mousePanelPos.x + mousePanelPos.y * panelRect.w;
    const drawOffset = { x: xoffset, y: yoffset - cellSize.h * (1 + panelRect.h) };
    const cellPos = (n) => ({ x: n % panelRect.w, y: ~~(n / panelRect.w) });
    const drawPos = (n) => ({ x: drawOffset.x + cellPos(n).x * cellSize.w, y: drawOffset.y + cellPos(n).y * cellSize.h });

    let dp0 = drawPos(0)
    dp0.x -= cellSize.w;  // special
	ctx.drawImage(glyphPrintButton, dp0.x, dp0.y);
	if (mousePos.x == panelRect.x - 1 && mousePos.y == panelRect.y) 
		ctx.drawImage(glyphMouseOver, dp0.x, dp0.y);

    glyphImages.forEach((glyph,index) => {
		ctx.drawImage(glyph, drawPos(index).x, drawPos(index).y);
		if (index == mouseIndex)
			ctx.drawImage(glyphMouseOver, drawPos(index).x, drawPos(index).y);
		if (index == glyphSelectedIndex) 
			ctx.drawImage(glyphHighlight, drawPos(index).x, drawPos(index).y);
	});

    let tooltip_string = '';
    let tooltip_objects = null;
    if (mouseIndex >= 0 && mouseIndex < glyphImagesCorrespondance.length) {
        // prepare tooltip: legend for highlighted editor icon
        const identifier_index = glyphImagesCorrespondance[mouseIndex]
        tooltip_string = identifier_index 
        if (identifier_index in state.synonymsDict){
            tooltip_string += " = " + state.synonymsDict[identifier_index];
        } else if (identifier_index in state.aggregatesDict){
            tooltip_string += " = " + state.aggregatesDict[identifier_index].join(" and ");
        }
    } else if (mousePos.x >= 0 && mousePos.x < screenwidth && mousePos.y >= 0 && mousePos.y < screenheight) {
        // prepare tooltip: content of a level's cell
        const posMask = curLevel.getCellInto((mousePos.y + minj) + (mousePos.x + mini) * curLevel.height, _o12); //???
        tooltip_objects = state.idDict.filter( (x,k) => (posMask.get(k) != 0) )
        // prepare tooltip: object names
        tooltip_string = tooltip_objects ? tooltip_objects.join(', ') : '';
    }

    // show tooltip
    if (tooltip_string) {
        ctx.fillStyle = state.fgcolor;
        ctx.font = `${cellheight/2}px Monospace`;
        ctx.textAlign = "center";
        ctx.fillText(tooltip_string, xoffset + screenwidth * cellwidth / 2, yoffset-0.3*cellheight);
    }



    if (mouseCoordX >= -1 && mouseCoordY >= -1 && mouseCoordX <= screenwidth && mouseCoordY <= screenheight) {
        if (mouseCoordX == -1 || mouseCoordY == -1 || mouseCoordX == screenwidth || mouseCoordY === screenheight) {
			ctx.drawImage(glyphHighlightResize,
				xoffset+mouseCoordX*cellwidth,
				yoffset+mouseCoordY*cellheight
				);								
		} else {
			ctx.drawImage(glyphHighlight,
				xoffset+mouseCoordX*cellwidth,
				yoffset+mouseCoordY*cellheight
				);				
		}
	}

}

var lastDownTarget;

var oldcellwidth=0;
var oldcellheight=0;
var oldtextmode=-1;
var oldfgcolor=-1;
var forceRegenImages=false;

var textcellwidth = 0;
var textcellheight = 0;
let statusLineHeight = 0;

// recalculate screen layout and then call redraw
function canvasResize(level) {
    level ||= curLevel;
    canvas.width = canvas.parentNode.clientWidth;
    canvas.height = canvas.parentNode.clientHeight;

    screenwidth = level.width;        // board size, used to calculate cell size
    screenheight = level.height;
    if (!state) throw 'oops!';

    flickscreen=state.metadata.flickscreen!==undefined;
    zoomscreen=state.metadata.zoomscreen!==undefined;
    smoothscreen=state.metadata.smoothscreen!==undefined;
    if (textMode) {
        screenwidth = TITLE_WIDTH;
        screenheight = TITLE_HEIGHT;
    } else if (flickscreen) {
        screenwidth=state.metadata.flickscreen[0];
        screenheight=state.metadata.flickscreen[1];
    } else if (zoomscreen) {
        screenwidth=state.metadata.zoomscreen[0];
        screenheight=state.metadata.zoomscreen[1];
    } else if (smoothscreen) {
        screenwidth=state.metadata.smoothscreen.screenSize.width;
        screenheight=state.metadata.smoothscreen.screenSize.height;
    }

    // If we need a status line, this will reduce the cell height to allow room
    statusLineHeight = state.metadata.status_line ? canvas.height / TITLE_HEIGHT : 0;
    if (levelEditorOpened) {
        // glyph display is level width + 1
        editorRowCount = Math.ceil(glyphCount()/(screenwidth + 1));
        //editorRowCount = Math.ceil(glyphImages.length/(screenwidth + 1));
        cellwidth = canvas.width / (screenwidth + 2);
        cellheight = (canvas.height - statusLineHeight) / (screenheight + 2 + editorRowCount);
    } else {
        cellwidth = canvas.width / screenwidth;
        cellheight = (canvas.height - statusLineHeight) / screenheight;
    }

    // round the cell size as a multiple of sprite size
    let w = h = state.sprite_size || 5;
    if (textMode) {
        w= 5 + 1;
        const xchar = font['X'].split('\n').map(a=>a.trim());
        h = xchar.length;        
    }
    cellwidth = w * Math.max( ~~(cellwidth / w),1);
    cellheight = h * Math.max(~~(cellheight / h),1);
    
    if (cellwidth / w > cellheight / h  || (textMode && state.metadata.custom_font !== undefined && loadedCustomFont)) {
        cellwidth = cellheight * w / h;
    } else {
        cellheight = cellwidth * h / w;
    }
    pixelSize = cellheight / h;
    
    // calculate an XY offset to position the board on the screen
    xoffset = 0;
    yoffset = 0;
    if (levelEditorOpened && !textMode) {
        xoffset = (canvas.width - cellwidth * (screenwidth + 2)) / 2;
        yoffset = (canvas.height - statusLineHeight - cellheight * (screenheight + 2 + editorRowCount)) / 2;
    	xoffset+=cellwidth;
    	yoffset+=cellheight*(1+editorRowCount);
    } else {
        xoffset = (canvas.width - cellwidth * screenwidth) / 2;
        yoffset = (canvas.height - statusLineHeight - cellheight * screenheight) / 2;
    }

    // tidy up for export to globals
    cellwidth = cellwidth|0;
    cellheight = cellheight|0;
    xoffset = xoffset|0;
    yoffset = yoffset|0;

    if (textMode) {
        textcellwidth = cellwidth;
        textcellheight = cellheight;
    }

    if (debugSwitch.includes('cell')) {
        const ele = document.getElementById('debug');
        ele.innerHTML = `canvas=${canvas.width},${canvas.height} cell=${cellwidth},${cellheight} text=${textcellwidth},${textcellheight} offset=${xoffset},${yoffset} pixel=${pixelSize}`;
    }
    
    if (oldcellwidth!=cellwidth||oldcellheight!=cellheight||oldtextmode!=textMode||textMode||oldfgcolor!=state.fgcolor||forceRegenImages){
    	forceRegenImages=false;
    	regenSpriteImages();
    }

    oldcellheight=cellheight;
    oldcellwidth=cellwidth;
    oldtextmode=textMode;
    oldfgcolor=state.fgcolor;

    redraw();
}

//Source: https://gist.github.com/gre/1650294
/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 */

// return an easing function by name or no if valid, else default to linear
function easingFunction(ease) {
    const e = ease in EasingFunctions ? ease
        : ease in easingAliases ? easingAliases[ease].toLowerCase()
        : 'linear';
    return EasingFunctions[e];
}

EasingFunctions = {
    // no easing, no acceleration
    linear: t => t,
    // accelerating from zero velocity
    easeinquad: t => t*t,
    // decelerating to zero velocity
    easeoutquad: t => t*(2-t),
    // acceleration until halfway, then deceleration
    easeinoutquad: t => t<.5 ? 2*t*t : -1+(4-2*t)*t,
    // accelerating from zero velocity 
    easeincubic: t => t*t*t,
    // decelerating to zero velocity 
    easeoutcubic: t => (--t)*t*t+1,
    // acceleration until halfway, then deceleration 
    easeinoutcubic: t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1,
    // accelerating from zero velocity 
    easeinquart: t => t*t*t*t,
    // decelerating to zero velocity 
    easeoutquart: t => 1-(--t)*t*t*t,
    // acceleration until halfway, then deceleration
    easeinoutquart: t => t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t,
    // accelerating from zero velocity
    easeinquint: t => t*t*t*t*t,
    // decelerating to zero velocity
    easeoutquint: t => 1+(--t)*t*t*t*t,
    // acceleration until halfway, then deceleration 
    easeinoutquint: t => t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t
  }

  easingAliases = {
      1: "linear",
      2: "easeInQuad",
      3: "easeOutQuad",
      4: "easeInOutQuad",
      5: "easeInCubic",
      6: "easeOutCubic",
      7: "easeInOutCubic",
      8: "easeInQuart",
      9: "easeOutQuart",
      10: "easeInOutQuart",
      11: "easeInQuint",
      12: "easeOutQuint",
      13: "easeInOutQuint"
  }
</script>
<script>
var onLevelRestarted = new Event("levelRestarted");

var RandomGen = new RNG();

function getIntroScreen(text) {
	return {
		lines: [
			"", 
			"==================", 
			"", 
			"Puzzle Script Next",
			"Version 3.0b",
			"", 
			"==================", 
			"", 
			text
		], 
		options: []
	};
}

function getMessageScreen(text) {
	return {
		lines: [
			"", "", "", "", "", "", "", "", "", "", 
			text
		], 
		options: [ 10 ]
	};
}

function getStartScreen(texts) {
	const lines = [
		"", "", "", "", "", "",
		...texts,
	];
	return {
		lines: lines, 
		options: fillRange(6, lines.length),
	};
}

function getPauseScreen(state) {
	const lines = [
		"",
		"-< GAME PAUSED >-",
		state.levels[curLevelNo].title || "",
		"",
		"resume game",
		!state.metadata.norestart ? "replay level from the start" : null,
		state.metadata.level_select ? "go to level select screen" : null,
		"exit to title screen",
	].filter(l => l != null);

	return {
		lines: lines,
		options: fillRange(4, lines.length),
	};
}

function getLevelSelectScreen(inserts) {
	const lines = [
		"[ ESC: Back ]                ",
		"Level Select",
		""
	];
	const options = [ ];
	inserts.forEach(ins => {
		options.push(lines.length);
		lines.push(ins);
	});
	return { lines: lines, options: options };
}

const MENUITEM_CONTINUE = 'Continue';
const MENUITEM_LEVELSELECT = 'Level Select';
const MENUITEM_NEWGAME = 'New Game';
const MENUITEM_STARTGAME = 'Start Game';

const TITLE_WIDTH = 34;
const TITLE_HEIGHT = 13;

var titleImage=[];
var textMode=true;
var titleScreen=true;
var titleMode=0;//1 means title screen with options, 2 means level select, 3 means pause screen
var titleSelection=0;
var titleSelected=false;
var hoverSelection=-1; //When mouse controls are enabled, over which row the mouse is hovering. -1 when disabled.
let lineColorOverride = [];		// a sparse array of line numbers and colours to use
let linkStack = [];				// where a link goto came from

// restore saved level, checkpoint, solved sections on startup
function doSetupTitleScreenLevelContinue(){
    try {
        if (storage_has(document.URL)) {
            if (storage_has(document.URL+'_checkpoint')) {
                var backupStr = storage_get(document.URL+'_checkpoint');
                curlevelTarget = JSON.parse(backupStr);
                
                var arr = [];
                for(var p in Object.keys(curlevelTarget.dat)) {
                    arr[p] = curlevelTarget.dat[p];
                }
                curlevelTarget.dat = new Int32Array(arr);
            }
            curLevelNo = storage_get(document.URL); 
			if (storage_has(document.URL+"_sections")) {
				solvedSections = JSON.parse(storage_get(document.URL + "_sections"));
			}
		}
    } catch(ex) {
    }
}

doSetupTitleScreenLevelContinue();

function showContinueOptionOnTitleScreen(){
	return hasStartedTheGame() && !hasFinishedTheGame();
}

function hasStartedTheGame() {
	return (curLevelNo>0||curlevelTarget!==null)&&(curLevelNo in state.levels);
}

function hasFinishedTheGame() {
	return state.metadata.level_select && solvedSections.length == state.sections.length
		|| curLevelNo >= state.levels.length - 1; 
}

function hasSolvedAtLeastOneSection() {
	return state.metadata.level_select && solvedSections.length > 0;
}

// call this before a new compile
function unloadGame() {
	state=introState;
	curLevel = new Level(0, 5, 5, 2, null, null);
	curLevel.objects = new Int32Array(0);
	generateTitleScreen();
	canvasResize();
	//redraw();
	titleMode = 0;
	titleSelected=true;
}

function isContinueOptionSelected() {
	return !state.metadata.continue_is_level_select && titleSelection == MENUITEM_CONTINUE;
}

function isNewGameOptionSelected() {
	return titleSelection == MENUITEM_NEWGAME || titleSelection == MENUITEM_STARTGAME;
}

function isLevelSelectOptionSelected() {
	return state.metadata.continue_is_level_select && titleSelection == MENUITEM_CONTINUE || titleSelection == MENUITEM_LEVELSELECT;
}

function generateTitleScreen(hoverLine, scrollIncrement, selectLine) {
	if (debugSwitch.includes('menu')) console.log(`generateTitleScreen()`, hoverLine, scrollIncrement, selectLine);
	lineColorOverride = [];
  	tryLoadCustomFont();

	titleMode=showContinueOptionOnTitleScreen()?1:0;

	if (state.levels.length===0) {
		titleImage = fillAndHighlight(getIntroScreen("Please select a game"));
		return;
  	}

    if (isSitelocked()) {
		titleImage = fillAndHighlight(getIntroScreen("This game is sitelocked!"));
		return;
	}

	if (titleMode===0) {
		const screen = getStartScreen([ MENUITEM_STARTGAME ]);
		titleImage = selectLine ? fillAndHighlight(screen, -1, -1, screen.options[0]) : fillAndHighlight(screen, screen.options[0]);
		titleSelection = selectLine ? MENUITEM_STARTGAME : null;
	} else {
		const playedGameBefore = hasStartedTheGame() || hasSolvedAtLeastOneSection()
		const options = [];
		options.push(playedGameBefore && !hasFinishedTheGame() ? MENUITEM_CONTINUE : MENUITEM_NEWGAME);
		if(state.metadata.level_select && (!state.metadata.continue_is_level_select || !playedGameBefore))
			options.push(MENUITEM_LEVELSELECT);
		if (playedGameBefore && !hasFinishedTheGame()) {
			options.push(MENUITEM_NEWGAME);
		}

		const screen = getStartScreen(options);
		if (levelSelectScrollPos == 0)
			levelSelectScrollPos = screen.options[0];
		else if (scrollIncrement && screen.options.includes(levelSelectScrollPos + scrollIncrement))
			levelSelectScrollPos += scrollIncrement;

		titleImage = fillAndHighlight(screen, levelSelectScrollPos, hoverLine, selectLine);
		const select = selectLine || hoverLine;
		titleSelection = screen.options.includes(select) ? options[screen.options.indexOf(select)] : false;  // todo: ???
	}

	const setImage = (n,text) => {
		if (!text) throw "image";
		titleImage[n] = text.padEnd(TITLE_WIDTH);
		if (state.metadata.keyhint_color) 
			lineColorOverride[n] = state.metadata.keyhint_color;
	}
	if (state.metadata.text_controls) {
		const text = wordwrap(state.metadata.text_controls, TITLE_WIDTH, true);
		text.slice(0, 3).forEach((t,x) => {
			setImage(10 + x, t);
		})
	} else {
		const tclick = state.metadata.mouse_drag || state.metadata.mouse_rdrag ? " Click, Tap, or Drag to interact" : " Click or Tap to interact";
		setImage(10, IsMouseGameInputEnabled() ? tclick : " Arrow keys or WASD to move");
		setImage(11, (state.metadata.noaction ? " X to select" : " X to action") + (state.metadata.norestart ? "" : ", R to restart"));
		const tundo = IsMouseGameInputEnabled() ? " Z or Middle Mouse Button to undo" : " Z to undo";
		setImage(12, (state.metadata.noundo ? " " : tundo));
	}

	const title = state.metadata.title || "PuzzleScript Next Game";

	const titleSplit = wordwrap(title, TITLE_WIDTH);
	const maxl = state.metadata.author ? 2 : 4;
	if (titleSplit.length > maxl) {
		titleSplit.splice(maxl);
		if (!hoverLine)
			logWarning(`Game title is too long to fit on screen, truncating to ${maxl} lines.`, state.metadata_lines.title, true);
	}
	titleSplit.forEach((line,x) => {
		titleImage[1 + x] = centerText(line.trim(), TITLE_WIDTH);
		if (state.metadata.title_color)
			lineColorOverride[1 + x] = state.metadata.title_color;
	});

	if (state.metadata.author) {
		const split = wordwrap("by " + state.metadata.author, TITLE_WIDTH);
		if (split.length > 2){
			split.splice(2);
			if (!hoverLine)
				logWarning("Author list too long to fit on screen, truncating to 2 lines.",state.metadata_lines.author, true);
		}
		split.forEach((line, x) => { 
			titleImage[3 + x]=line.trim().padStart(TITLE_WIDTH);
			if (state.metadata.author_color)
				lineColorOverride[3 + x] = state.metadata.author_color;
		});
	}
	redraw();
}

function goToPauseScreen() {
	// todo: de-yuck!
	levelSelectScrollPos = 0;
	titleSelected = false;
	timer = 0;
	quittingTitleScreen = false;
	quittingMessageScreen = false;
	titleMode = 3;
	titleScreen = true;
	textMode = true;
    againing = false;
	messagetext = "";
	statusText = "";

	generatePauseScreen();
}

let selectOption;
function generatePauseScreen(hoverLine, scrollIncrement, selectLine) {
	if (debugSwitch.includes('menu')) console.log(`generatePauseScreen()`, hoverLine, scrollIncrement, selectLine);
	const screen = getPauseScreen(state);

	if (levelSelectScrollPos == 0)
		levelSelectScrollPos = screen.options[0];
	else if (scrollIncrement && screen.options.includes(levelSelectScrollPos + scrollIncrement))
		levelSelectScrollPos += scrollIncrement;

	titleImage = fillAndHighlight(screen, levelSelectScrollPos, hoverLine, selectLine);
	selectOption = selectLine - screen.options[0];
	redraw();
}

function selectPauseScreen(lineNo) { 
	const options = [
		() => {
			titleScreen = false;
			if (state.levels[curLevelNo].message) {
				drawMessageScreen(state.levels[curLevelNo].message);
			} else {
				textMode = false;
				canvasResize();
			}
		},
		!state.metadata.norestart ? () => {
			DoRestart(true);
			textMode = false;
			titleScreen = false;
			canvasResize();
		} : null,
		state.metadata.level_select ? () => {
			gotoLevelSelectScreen();
			//redraw();
		} : null,
		() => {
			goToTitleScreen();
			//redraw();
		}
	].filter(l => l != null);

	options[selectOption]();
}

function centerText(text, len, fill = " ") {
	return !text ? fill.repeat(len)
		: text.length >= len ? text.slice(0, len)
		: (fill.repeat(~~((len - text.length) / 2)) + text).padEnd(len, fill);
}

function padToSize(textLines, width, height) {
	const lines = textLines.map(l => l.padEnd(width));
	while (lines.length < height) 
		lines.push("");
	return lines;
}

// return an array filled with integers from start to finish-1
function fillRange(start, finish) {
	return Array(finish - start).fill().map((item, index) => start + index);
};

function fillAndHighlight(image, highlight, hover, select) {
	const ll = image.lines.map((l,x) => 
		x == select && image.options.includes(x) ? centerText(`# ${l} #`, TITLE_WIDTH, "#") :
		x == hover && image.options.includes(x) ? centerText(`> ${l} <`, TITLE_WIDTH) : 
		x == highlight && image.options.includes(x) ? centerText(`# ${l} #`, TITLE_WIDTH) :
		centerText(l, TITLE_WIDTH));
	return padToSize(ll, TITLE_WIDTH, TITLE_HEIGHT);
}

let levelSelectScrollPos = 0;
let levelHighlightLine = 0;

function gotoLevelSelectScreen() {
	if(!state.metadata.level_select) {
		goToTitleScreen();
		return;
	}
	levelSelectScrollPos = 0;
	levelHighlightLine = 0;
	titleSelected = false;
	timer = 0;
	quittingTitleScreen = false;
	quittingMessageScreen = false;
	titleMode = 2;
	titleScreen = true;
	textMode = true;
    againing = false;
	messagetext = "";
	statusText = "";

	if (titleSelection == false) {
		for(var i = 0; i < state.sections.length; i++) {
			if(state.sections[i].firstLevel > curLevelNo) {
				titleSelection = Math.max(0,i-1);
				break;
			}
		}
  	}
  
  	state.metadata = deepClone(state.default_metadata);
  	twiddleMetadataExtras();

	generateLevelSelectScreen();
}

function generateLevelSelectScreen(hoverLine, scrollIncrement, selectLine) { 
	if (debugSwitch.includes('menu')) console.log('generateLevelSelectScreen()', hoverLine, scrollIncrement, selectLine);
	lineColorOverride = [];

	var unlockedUntil = -1;
	if (state.metadata.level_select_lock) {
		// find last solved section:
		let unsolvedSections = 0;
		for(var i = 0; i < state.sections.length; i++) {
			if(solvedSections.indexOf(state.sections[i].name) >= 0) {
				unlockedUntil = i;
			} else {
				unsolvedSections++;
			}
		}
		if(state.metadata.level_select_unlocked_ahead !== undefined) {
			unlockedUntil += Number(state.metadata.level_select_unlocked_ahead);
		} else if (state.metadata.level_select_unlocked_rollover !== undefined) {
			unlockedUntil = solvedSections.length + Number(state.metadata.level_select_unlocked_rollover) - 1;
		} else {
			unlockedUntil += 1;
		}
	}

	amountOfLevelsOnScreen = Math.min(9, state.sections.length);
	if (levelHighlightLine == 0)
		levelHighlightLine = 3;
	else if (levelHighlightLine > 3 && scrollIncrement < 0)
		levelHighlightLine--;
	else if (levelHighlightLine < 3 + amountOfLevelsOnScreen - 1 && scrollIncrement > 0)
		levelHighlightLine++;
	else if (levelSelectScrollPos > 0 && (selectLine == 2 || scrollIncrement < 0))
		levelSelectScrollPos--;
	else if (levelSelectScrollPos + amountOfLevelsOnScreen < state.sections.length && (selectLine == 12 || scrollIncrement > 0))
		levelSelectScrollPos++;

	const solved_symbol = state.metadata.level_select_solve_symbol || "?";

	titleSelection = selectLine == 0 ? 0 : null;
	const lines = state.sections.map((section,i) => {
		const solved = (solvedSections.indexOf(section.name) >= 0);
		//const selected = (i == titleSelection);
		const locked = (unlockedUntil >= 0 && i > unlockedUntil);
		let name = locked ? "*".repeat(section.name.length) : section.name.substring(0, 24);
		if (i == selectLine + levelSelectScrollPos - 3 && !locked) {
			if (i >= levelSelectScrollPos && i < levelSelectScrollPos + amountOfLevelsOnScreen)
				titleSelection = i;
			return (solved ? solved_symbol : " ") + "#" + name.padEnd(24, "#");
		}
		return (solved ? solved_symbol : " ") + " " + name.padEnd(24);
	});

	const showLines = lines.slice(levelSelectScrollPos,levelSelectScrollPos + amountOfLevelsOnScreen);
	const screen = getLevelSelectScreen(showLines);
	console.log(screen, levelSelectScrollPos, levelHighlightLine, hoverLine, selectLine, titleSelection);
	titleImage = fillAndHighlight(screen, levelHighlightLine, hoverLine, selectLine);

	titleImage[0] = (hoverLine == 0 ? "[  ESC:Back  ]" : " [ ESC:Back ] ").padEnd(TITLE_WIDTH);
	if (levelSelectScrollPos > 0)
		titleImage[2] = (hoverLine == 2 ? "[  PREV  ]" : "[ PREV ] ").padStart(TITLE_WIDTH);
	if (levelSelectScrollPos + amountOfLevelsOnScreen < lines.length)
		titleImage[12] = (hoverLine == 12 ? "[  NEXT  ]" : "[ NEXT ] ").padStart(TITLE_WIDTH);
	redraw();
}

// go to level: <-1 for level index, >0 for section index, -9999 had compile error
function gotoLevel(index) {
	if (debugSwitch.includes('load')) console.log(`gotoLevel(${index})`);
	if (solving) return;
	if (index == -9999) return;  // It's an invalid GOTO
  
	againing = false;
	messagetext = "";
	statusText = "";

	curLevelNo = (index >= 0) ? state.sections[index].firstLevel : -1 - index;

	loadLevelFromStateOrTarget();

	updateLocalStorage();
	resetFlickDat();
	canvasResize();	
	clearInputHistory();
}
  
function gotoLink() {
	if (debugSwitch.includes('load')) console.log('gotoLink()', `stack:`, linkStack);
  	if (solving) return;
	for (const position of playerPositions) {
		const level = state.levels[curLevelNo];
		const objids = level.getObjects(position);
		for (const link of state.links // use the most recent visible link definition
				.slice(0, level.linksTop)
				.reverse()) {
			if (objids.includes(link.object)) {
				const linkEntry = { 
					backup: backupLevel(), 		// will restore to this
					backupTop: backups.length 	// will prune to this
				};
				linkStack.push(linkEntry);
				gotoLevel(link.targetNo);
				return;
			}
		}
  	}  
}

function returnLink() {
	if (debugSwitch.includes('load')) console.log('returnLink()', `stack:`, linkStack);
	const linkEntry = linkStack.pop();
	const level = state.levels[linkEntry.backup.levelNo];
	backups = backups.slice(0, linkEntry.backupTop);
	if (verbose_logging)
		consolePrint(`Returning to level ${linkEntry.backup.levelNo} (${htmlJump(level.lineNumber)}).`, true, level.lineNumber);
	restoreLevel(linkEntry.backup);
	updateLocalStorage();
	resetFlickDat();
	canvasResize();	
	clearInputHistory();
}

let introState = {
  	title: "Empty Game",
  	attribution: "polyomino",
    objectCount: 2,
    metadata:[],
    levels:[],
	collisionLayerGroups: [],
    bgcolor:"#000000",
    fgcolor:"#FFFFFF"
};

var state = introState;

function deepClone(item) {
    if (!item) { return item; } // null, undefined values check

    var types = [ Number, String, Boolean ], 
        result;

    // normalizing primitives if someone did new String('aaa'), or new Number('444');
    types.forEach(function(type) {
        if (item instanceof type) {
            result = type( item );
        }
    });

    if (typeof result == "undefined") {
        if (Object.prototype.toString.call( item ) === "[object Array]") {
            result = [];
            item.forEach(function(child, index, array) { 
                result[index] = deepClone( child );
            });
        } else if (typeof item == "object") {
            // testing that this is DOM
            if (item.nodeType && typeof item.cloneNode == "function") {
                var result = item.cloneNode( true );    
            } else if (!item.prototype) { // check that this is a literal
                if (item instanceof Date) {
                    result = new Date(item);
                } else {
                    // it is an object literal
                    result = {};
                    for (var i in item) {
                        result[i] = deepClone( item[i] );
                    }
                }
            } else {
                // depending what you would like here,
                // just keep the reference, or create new object
/*                if (false && item.constructor) {
                    // would not advice to do that, reason? Read below
                    result = new item.constructor();
                } else */{
                    result = item;
                }
            }
        } else {
            result = item;
        }
    }

    return result;
}

function wordwrap( str, width, handleNewlines = false ) {
 
    width = width || 75;
    var cut = true;
 
	if (!str) return [ ];
 
	var regex = '.{1,' +width+ '}(\\s|$)' + (cut ? '|.{' +width+ '}|.+$' : '|\\S+?(\\s|$)');

	if (!handleNewlines) {
	
		return str.match( RegExp(regex, 'g') );
	} else {
		splitNewlines = str.split("\\n");
		var splitString  = [];
	
		splitNewlines.forEach(splitStr => {
			splitString = splitString.concat(splitStr.match( RegExp(regex, 'g') ));
		}) 
		
		//console.log(splitString);
		return splitString;
	}
 
}

var splitMessage=[];
function drawMessageScreen(message) {
	lineColorOverride = [];
	tryLoadCustomFont();
	titleMode=0;
	textMode=true;

	const screen = getMessageScreen(
		quittingMessageScreen ? "" 
		: state.metadata.text_message_continue ? state.metadata.text_message_continue
		: IsMouseGameInputEnabled() ? "Click or X to continue" : "X to continue");

	titleImage = fillAndHighlight(screen);
	if (state.metadata.keyhint_color)
		lineColorOverride[screen.options[0]] = state.metadata.keyhint_color;

	const splitMessage = wordwrap(message, TITLE_WIDTH, true);

	const lines = splitMessage.map(m => {
		return state.metadata.message_text_align == 'left' ? m.padEnd(TITLE_WIDTH)
		: state.metadata.message_text_align == 'right' ? m.padStart(TITLE_WIDTH)
		: centerText(m, TITLE_WIDTH);
	})

	lines.length = Math.min(lines.length, 12);
	const offset = 5 - ~~(lines.length / 2);

	lines.forEach((line,x) => {
		titleImage[x + offset] = line;
	})
 
  	canvasResize();
}

var loadedLevelSeed=0;

// workhorse to load and setup a new level
function loadLevelFromLevelDat(state,leveldat,randomseed,clearinputhistory) {	
	if (debugSwitch.includes('load')) console.log(`loadLevelFromLevelDat()`, leveldat);
	if (randomseed==null) {
		randomseed = (Math.random() + Date.now()).toString();
	}
	loadedLevelSeed = randomseed;
	RandomGen = new RNG(loadedLevelSeed);
	forceRegenImages=true;			// forces canvasResize to generate images
	ignoreNotJustPressedAction=true;
	titleScreen=false;
	titleMode=showContinueOptionOnTitleScreen()?1:0;
	titleSelection=0;
  	titleSelected=false;
  	dragging = false;
  	rightdragging = false;
  	state.metadata = deepClone(state.default_metadata);
    againing=false;
    if (leveldat===undefined) {
    	consolePrint("Trying to access a level that doesn't exist.",true);
		goToTitleScreen();
    	return;
    }
    if (leveldat.message) {
      	// This "level" is actually a message.
		if (verbose_logging)
			consolePrint(`Showing message (${htmlJump(leveldat.lineNumber)})`, true, leveldat.lineNumber);
      	ignoreNotJustPressedAction=true;
	  	tryPlayShowMessageSound();
	  	twiddleMetadataExtras();
      	drawMessageScreen(leveldat.message);
		messageselected = false;
      	canvasResize();
      	clearInputHistory();
    } else if (leveldat.target != undefined) {  // could be zero
		if (verbose_logging)
			consolePrint(`GOTO (${htmlJump(leveldat.lineNumber)})`, true, leveldat.lineNumber);
      	// This "level" is actually a goto.
      	//tryPlayGotoSound();
      	setSectionSolved(state.levels[Number(curLevelNo)].section)
      	gotoLevel(leveldat.target);
    } else {
      	titleMode=0;
      	textMode=false;
    	curLevel = leveldat.clone();
		if (verbose_logging)
			consolePrint(`Loading level ${leveldat.section || ''} (${htmlJump(leveldat.lineNumber)}).`, true, leveldat.lineNumber);  //todo:
    	RebuildLevelArrays();
        if (state!==undefined) {
	        if (state.metadata.flickscreen!==undefined){
	            oldflickscreendat=[
	            	0,
	            	0,
	            	Math.min(state.metadata.flickscreen[0],curLevel.width),
	            	Math.min(state.metadata.flickscreen[1],curLevel.height)
	            ];
	        } else if (state.metadata.zoomscreen!==undefined){
	            oldflickscreendat=[
	            	0,
	            	0,
	            	Math.min(state.metadata.zoomscreen[0],curLevel.width),
	            	Math.min(state.metadata.zoomscreen[1],curLevel.height)
	            ];
	        } else if (state.metadata.smoothscreen!==undefined){
	            oldflickscreendat=[
	            	0,
	            	0,
	            	Math.min(state.metadata.smoothscreen.screenSize.width,curLevel.width),
	            	Math.min(state.metadata.smoothscreen.screenSize.height,curLevel.height)
	            ];
	        }
        }

      	initSmoothCamera();
      	twiddleMetadataExtras();

		if (!state.metadata.allow_undo_level)
	    	backups = [];
		restartTarget=backupLevel();
		keybuffer=[];

	    if ('run_rules_on_level_start' in state.metadata) {
			runrulesonlevelstart_phase=true;
			processInput(-1,true);
			runrulesonlevelstart_phase=false;
	    }
	}

	if (clearinputhistory===true){
		clearInputHistory();
	}
}

function loadLevelFromStateTarget(state,levelindex,target,randomseed) { 
	if (debugSwitch.includes('load')) console.log(`loadLevelFromStateTarget(${levelindex},${target})`);
    var leveldat = target;    
  	curLevelNo=levelindex;
  	curlevelTarget=target;
    if (leveldat.message===undefined) {
      	if (levelindex=== 0){ 
			tryPlayStartGameSound();
			//tryPlayStartLevelSound();     
		} else {
			tryPlayStartLevelSound();     
		}
    }
    loadLevelFromLevelDat(state,state.levels[levelindex],randomseed);
    restoreLevel(target, true);
    restartTarget=target;
}

function loadLevelFromState(state,levelindex,randomseed) {  
	if (debugSwitch.includes('load')) console.log(`loadLevelFromState(${levelindex})`);
	var leveldat = state.levels[levelindex];    
	curLevelNo=levelindex;
	curlevelTarget=null;
    if (leveldat!==undefined && leveldat.message===undefined) {
		document.dispatchEvent(new CustomEvent("psplusLevelLoaded", {detail: levelindex}));
      	if (levelindex=== 0){ 
      		tryPlayStartLevelSound();
    	} else {
      		tryPlayStartLevelSound();     
    	}
	}

    loadLevelFromLevelDat(state,leveldat,randomseed);
}

var objectSprites = [
{
    color: '#423563',
    dat: [
        [1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1],
        [1, 0, 0, 0, 1],
        [1, 0, 0, 0, 1],
        [1, 1, 1, 1, 1]
    ]
},
{
    color: '#252342',
    dat: [
        [0, 0, 1, 0, 0],
        [1, 1, 1, 1, 1],
        [0, 0, 1, 0, 0],
        [0, 1, 1, 1, 0],
        [0, 1, 0, 1, 0]
    ]
}
];

loadedCustomFont = false;

function tryLoadCustomFont() {
	if(state == null || state.metadata == null || state.metadata.custom_font == undefined || loadedCustomFont) {
		return;
	}

	var custom_font = new FontFace('PuzzleCustomFont', 'url('+state.metadata.custom_font+')');
	custom_font.load().then(function(loaded_face) {
		document.fonts.add(loaded_face);
		loadedCustomFont = true;
		canvasResize();
	}).catch(function(error) {alert("Unable to load font!");});
}

tryLoadCustomFont();

generateTitleScreen();
if (titleMode>0){
	titleSelection=0;
}

canvasResize();

function tryPlaySimpleSound(soundname) {
  if (state.sfx_Events[soundname]!==undefined) {
    var seed = state.sfx_Events[soundname];
		playSeed(seed,true);
  }
}
function tryPlayTitleSound() {
  tryPlaySimpleSound("titlescreen");
}

function tryPlayStartGameSound() {
  tryPlaySimpleSound("startgame");
}

function tryPlayEndGameSound() {
  tryPlaySimpleSound("endgame");
}

function tryPlayCancelSound() {
  tryPlaySimpleSound("cancel");
}

function tryPlayStartLevelSound() {
  tryPlaySimpleSound("startlevel");
}

function tryPlayEndLevelSound() {
  tryPlaySimpleSound("endlevel");
}

function tryPlayUndoSound(){
  tryPlaySimpleSound("undo");
}

function tryPlayRestartSound(){
  tryPlaySimpleSound("restart");
}

function tryPlayShowMessageSound(){
  tryPlaySimpleSound("showmessage");
}

function tryPlayCloseMessageSound(){
  tryPlaySimpleSound("closemessage");
}

var backups=[];
var restartTarget;

// create backup of level data for undo, restart, etc
function backupLevel() {
	const ret = level4Serialization();
	if (state.metadata.runtime_metadata_twiddling !== undefined) {
      	var metadata = deepClone(state.metadata)
      	delete metadata.custom_font;
      	ret.metadata = metadata;
    }
	return ret;
}

function level4Serialization() {
	var ret = {
		dat : Array.from(curLevel.objects),
		width : curLevel.width,
		height : curLevel.height,
		oldflickscreendat: oldflickscreendat.concat([]),
    	cameraPositionTarget: Object.assign({}, cameraPositionTarget),
		levelNo: curLevelNo,
	};
	return ret;
}


// major function to set up game state on start of run
function setGameState(_state, command, randomseed) {
	if (debugSwitch.includes('load')) console.log(`setGameState(${command})`);  //todo:
	oldflickscreendat = [];
	linkStack = [];
	timer = 0;
	autotick = 0;
	winning = false;
	againing = false;
	messageselected = false;
	STRIDE_MOV = _state.STRIDE_MOV;
	STRIDE_OBJ = _state.STRIDE_OBJ;

	sfxCreateMask = new BitVec(STRIDE_OBJ);		// doc: mask for objects that were created
	sfxDestroyMask = new BitVec(STRIDE_OBJ);		// doc: mask for objects that were destroyed

	if (command === undefined) {
		command = ["restart"];
	}
	if ((state.levels.length === 0 || _state.levels.length === 0) && command.length > 0 && command[0] === "rebuild") {
		command = ["restart"];
	}
	if (randomseed === undefined) {
		randomseed = null;
	}
	RandomGen = new RNG(randomseed);

	state = _state;

    if (command[0]!=="rebuild"){
      backups=[];
    }
    //set sprites
    objectSprites = [];
    for (const n in state.objects) {
        if (state.objects.hasOwnProperty(n)) {
            const object = state.objects[n];
			objectSprites[object.id] = {
                dat: object.spritematrix,
                colors: object.colors,
				text: object.spritetext,
                vector: object.vector,
				scale: object.scale,
            };
        }
    }
    if (state.metadata.realtime_interval!==undefined) {
      autotick=0;
      autotickinterval=state.metadata.realtime_interval*1000;
    } else {
      autotick=0;
      autotickinterval=0;
    }

	// set defaults and stay DRY
	twiddleMetadataExtras();
    
	if (throttle_movement && autotickinterval===0) {
      logWarning("throttle_movement is designed for use in conjunction with realtime_interval. Using it in other situations makes games gross and unresponsive, broadly speaking.  Please don't.");
    }
    norepeat_action = state.metadata.norepeat_action!==undefined;

    switch(command[0]){
    	case "restart":
    	{
		    winning=false;
		    timer=0;
		    titleScreen=true;
		    tryPlayTitleSound();
		    textMode=true;
		    titleSelection=0;
		    titleSelected=false;
		    quittingMessageScreen=false;
		    quittingTitleScreen=false;
			titleMode = showContinueOptionOnTitleScreen() ? 1 : 0;

			if (state.metadata.skip_title_screen!==undefined) {
				consolePrint("skip_title_screen enabled, proceeding to do exactly as it says on the tin.")
				if(state.metadata["continue_is_level_select"] !== undefined) {
					gotoLevelSelectScreen();
				}
				else if(titleMode <= 1) {
					nextLevel();
				} else if(titleMode == 2) {
					gotoLevel(titleSelection);
				}
			} else {
				generateTitleScreen();
			}

		    break;
		}
		case "rebuild":
		{
			//do nothing
			break;
		}
		case "loadFirstNonMessageLevel":{
			for (var i=0;i<state.levels.length;i++){
				if (state.levels[i].message){
					continue;
				}
				var targetLevel = i;
				curLevelNo=targetLevel;
				curlevelTarget=null;
			    winning=false;
			    timer=0;
			    titleScreen=false;
			    textMode=false;
			    //titleSelection=showContinueOptionOnTitleScreen()?1:0;
			    titleSelected=false;
			    quittingMessageScreen=false;
			    quittingTitleScreen=false;
			    titleMode = 0;
				showLayers = false;
				loadLevelFromState(state,targetLevel,randomseed);
				break;
			}
			break;	
		}
		case "loadLevel":
		{
			var targetLevel = command[1];
			curLevelNo=targetLevel;
			curlevelTarget=null;
		    winning=false;
		    timer=0;
		    titleScreen=false;
		    textMode=false;
		    //titleSelection=showContinueOptionOnTitleScreen()?1:0;
		    titleSelected=false;
		    quittingMessageScreen=false;
		    quittingTitleScreen=false;
		    titleMode = 0;
			showLayers = false;
			loadLevelFromState(state,targetLevel,randomseed);
			break;
		}
		case "levelline":
		{
			var targetLine = command[1];
			for (var i=state.levels.length-1;i>=0;i--) {
				var level= state.levels[i];
				if(level.lineNumber<=targetLine+1) {
					curLevelNo=i;
					curlevelTarget=null;
				    winning=false;
				    timer=0;
				    titleScreen=false;
				    textMode=false;
				    //titleSelection=showContinueOptionOnTitleScreen()?1:0;
				    titleSelected=false;
				    quittingMessageScreen=false;
				    quittingTitleScreen=false;
				    titleMode = 0;
					showLayers = false;
					loadLevelFromState(state,i);
					break;
				}
			}
			break;
		}
	}

	if(command[0] !== "rebuild") {
		clearInputHistory();
	}
	canvasResize();

	if (state.sounds.length==0){
		killAudioButton();
	} else {
		showAudioButton();
	}
}

function RebuildLevelArrays() {
  curLevel.movements = new Int32Array(curLevel.n_tiles * STRIDE_MOV);

    curLevel.rigidMovementAppliedMask = [];
    curLevel.rigidGroupIndexMask = [];
	curLevel.rowCellContents = [];
	curLevel.rowCellContents_Movements = [];
	curLevel.colCellContents = [];
	curLevel.colCellContents_Movements = [];
	curLevel.mapCellContents = new BitVec(STRIDE_OBJ);
	curLevel.mapCellContents_Movements = new BitVec(STRIDE_MOV);

	//I have these to avoid dynamic allocation - I generate 3 because why not, 
	//but according to my tests I never seem to call this while a previous copy is still in scope
	_movementVecs = [new BitVec(STRIDE_MOV),new BitVec(STRIDE_MOV),new BitVec(STRIDE_MOV)];
	_rigidVecs = [new BitVec(STRIDE_MOV),new BitVec(STRIDE_MOV),new BitVec(STRIDE_MOV)];

	_o1 = new BitVec(STRIDE_OBJ);
	_o2 = new BitVec(STRIDE_OBJ);
	_o2_5 = new BitVec(STRIDE_OBJ);
	_o3 = new BitVec(STRIDE_OBJ);
	_o4 = new BitVec(STRIDE_OBJ);
	_o5 = new BitVec(STRIDE_OBJ);
	_o6 = new BitVec(STRIDE_OBJ);
	_o7 = new BitVec(STRIDE_OBJ);
	_o8 = new BitVec(STRIDE_OBJ);
	_o9 = new BitVec(STRIDE_OBJ);
	_o10 = new BitVec(STRIDE_OBJ);
	_o11 = new BitVec(STRIDE_OBJ);
	_o12 = new BitVec(STRIDE_OBJ);
	_m1 = new BitVec(STRIDE_MOV);
	_m2 = new BitVec(STRIDE_MOV);
	_m3 = new BitVec(STRIDE_MOV);
	

    for (var i=0;i<curLevel.height;i++) {
      curLevel.rowCellContents[i]=new BitVec(STRIDE_OBJ);        
    }
    for (var i=0;i<curLevel.width;i++) {
      curLevel.colCellContents[i]=new BitVec(STRIDE_OBJ);        
    }

    for (var i=0;i<curLevel.height;i++) {
    	curLevel.rowCellContents_Movements[i]=new BitVec(STRIDE_MOV);	    	
    }
    for (var i=0;i<curLevel.width;i++) {
    	curLevel.colCellContents_Movements[i]=new BitVec(STRIDE_MOV);	    	
    }

    for (var i=0;i<curLevel.n_tiles;i++)
    {
        curLevel.rigidMovementAppliedMask[i]=new BitVec(STRIDE_MOV);
        curLevel.rigidGroupIndexMask[i]=new BitVec(STRIDE_MOV);
    }
}

let messagetext="";			// text for command message
let statusText = "";  		// text for status line
let gosubTarget = -1;  		// name of target gosub
var currentMovedEntities = {};
var newMovedEntities = {};

function applyDiff(diff, level_objects) {

	var index=0;
	
	while (index<diff.dat.length){
		var start_index = diff.dat[index];
		var copy_length = diff.dat[index+1];
		if (copy_length===0){
			break;//tail of buffer is all 0s
		}
		for (var j=0;j<copy_length;j++){
			level_objects[start_index+j]=diff.dat[index+2+j];
		}
		index += 2 + copy_length;
	}
}

function unconsolidateDiff(before,after) {

	// If before is not a diff, return it, otherwise generate a complete 'before' 
	// state from the 'after' state and the 'diff' (remember, the diffs are all 
	// backwards...).
	if (!before.hasOwnProperty("diff")) {
		return before;
	}

	var after_objects = new Int32Array(after.dat);
	applyDiff(before, after_objects);

	return {
		dat: after_objects,
		width: before.width,
		height: before.height,
		oldflickscreendat: before.oldflickscreendat
	}
}

function restoreLevel(lev, snapCamera, resetTween = true, resetAutoTick = true) {
	if (debugSwitch.includes('load')) console.log(`restoreLevel()`, lev);
	var diffing = lev.hasOwnProperty("diff");

	oldflickscreendat=lev.oldflickscreendat.concat([]);

	if (resetTween) {
		currentMovedEntities = {};
		//console.log("Wiped movedEntities (level)")
	}

	const switchLevel = lev.levelNo >= 0 && lev.levelNo != curLevelNo;
	if (switchLevel) {
		curLevelNo = lev.levelNo;
		curLevel = state.levels[curLevelNo].clone();
	}

	if (diffing){
		applyDiff(lev, curLevel.objects);
	} else {	
		curLevel.objects = new Int32Array(lev.dat);
	}

	if (switchLevel || curLevel.width !== lev.width || curLevel.height !== lev.height) {
		if (debugSwitch.includes('load')) console.log(`Restore level: from ${curLevel.width}x${curLevel.height} to ${lev.width}x${lev.height}`)
		curLevel.width = lev.width;
		curLevel.height = lev.height;
		curLevel.n_tiles = lev.width * lev.height;
		RebuildLevelArrays();
		//regenerate all other stride-related stuff
	} else {
	// layercount doesn't change

		for (var i=0;i<curLevel.n_tiles;i++) {
			curLevel.movements[i]=0;
			curLevel.rigidMovementAppliedMask[i].setZero();
			curLevel.rigidGroupIndexMask[i].setZero();
		}	

	    for (var i=0;i<curLevel.height;i++) {
	    	var rcc = curLevel.rowCellContents[i];
	    	rcc.setZero();
	    }
	    for (var i=0;i<curLevel.width;i++) {
	    	var ccc = curLevel.colCellContents[i];
	    	ccc.setZero();
	    }
	}

    if (lev.cameraPositionTarget) {
      	cameraPositionTarget = Object.assign({}, lev.cameraPositionTarget);

      	if (snapCamera) {
        	cameraPosition = Object.assign({}, cameraPositionTarget)
      	}
    }
    
    if (state.metadata.runtime_metadata_twiddling !== undefined) {
		if (lev.metadata === undefined) {
			lev.metadata = deepClone(state.default_metadata);
			consolePrint("RUNTIME METADATA TWIDDLING: Reloaded level state that did not have saved metadata. "+
			"Likely this state was recovered from a CHECKPOINT. Using the default metadata instead.", true);
		}
	 	state.metadata = deepClone(lev.metadata);
     	twiddleMetadataExtras(resetAutoTick);
    }

    againing=false;
	messagetext = "";  //fix for hang
    curLevel.commandQueue=[];
    curLevel.commandQueueSourceRules=[];
}

// globals
var zoomscreen=false;
var flickscreen=false;
var smoothscreen=false;
var screenwidth=0;
var screenheight=0;

//compresses 'before' into diff
function consolidateDiff(before,after){
	if (before.width !== after.width || before.height!==after.height || before.dat.length!==after.dat.length){
		return before;
	}
	if (before.hasOwnProperty("diff")||after.hasOwnProperty("diff")){
		return before;
	}
	//only generate diffs if level size is bigger than this
	if (before.dat.length<1024){
		return before;
	}
	//diff structure: repeating ( start,length, [ data ] )
	var result = new Int32Array(128);
	var position=0;
	var chain=false;
	var chain_start_idx_in_diff=-1;
	var before_dat = before.dat;
	var after_dat = after.dat;
	for (var i=0;i<before_dat.length;i++){
		if (chain===false){
			if (before_dat[i]!==after_dat[i]){
				chain=true;
				chain_start_idx_in_diff = position;

				if (result.length<position+4){
					var doubled = new Int32Array(2*result.length);
					doubled.set(result);
					result = doubled;
				}

				result[position+0]=i;
				result[position+1]=1;
				result[position+2]=before_dat[i];
				position+=3;
			}
		} else {
			if (before_dat[i]!==after_dat[i]){
				
				if (position+1>=result.length){
					if (result.length<position+4){
						var doubled = new Int32Array(2*result.length);
						doubled.set(result);
						result = doubled;
					}	
				}
				result[chain_start_idx_in_diff+1]++;
				result[position]=before_dat[i];
				position++;
			} else {
				chain=false;
			}
		}
	}
	return {		
		diff : true,
		dat : result,
		width : before.width,
		height : before.height,
		oldflickscreendat: before.oldflickscreendat
	}
}

function addUndoState(bak){
	backups.push(bak);
	if(backups.length>2 && !backups[backups.length-1].hasOwnProperty("diff")){
		backups[backups.length-3]=consolidateDiff(backups[backups.length-3],backups[backups.length-2]);
	}
}

function DoRestart(force) {
	if (restarting===true){
		return;
	}
	if (force!==true && ('norestart' in state.metadata)) {
		return;
	}
	restarting=true;
	if (force!==true) {
		addUndoState(backupLevel());
	}

	if (verbose_logging) {
		consolePrint("--- restarting ---",true);
	}

	restoreLevel(restartTarget, true);
	tryPlayRestartSound();
	document.dispatchEvent(new CustomEvent("psplusLevelRestarted", {detail: curLevelNo}));

	if ('run_rules_on_level_start' in state.metadata) {
    	processInput(-1,true);
  }
  
  twiddleMetadataExtras();
	
	curLevel.commandQueue=[];
	curLevel.commandQueueSourceRules=[];
	restarting=false;
}

function backupDiffers(){
	if (backups.length==0){
		return true;
	}
	var bak = backups[backups.length-1];

	if (bak.hasOwnProperty("diff")){
		return bak.dat.length!==0 && bak.dat[1]!==0;//if it's empty or if it's all 0s
	} else {
		for (var i=0;i<curLevel.objects.length;i++) {
			if (curLevel.objects[i]!==bak.dat[i]) {
				return true;
			}
		}
		return false;
	}
}

function DoUndo(force,ignoreDuplicates, resetTween = true, resetAutoTick = true, forceSFX = false) {
  if ((!levelEditorOpened)&&('noundo' in state.metadata && force!==true)) {
    return;
  }

  if (ignoreDuplicates){
    while (backupDiffers()==false){
      backups.pop();
    }
  }

  if (verbose_logging) {
    consolePrint(backups.length > 0 ? "--- undoing ---" : "Nothing to undo.",true);
  }

  if (backups.length>0) {
    var torestore = backups[backups.length-1];
    restoreLevel(torestore, null, resetTween, resetAutoTick);
    backups = backups.splice(0,backups.length-1);
	// look for undo across link
	if (linkStack.length > 0 && linkStack.at(-1).backupTop == backups.length)
	  linkStack.pop();
    if (! force || forceSFX) {
      tryPlayUndoSound();
    }
  }
}

// static data used here and elsewhere

// maps between mask values and movement names
var dirMaskName = {
	1: 'up',
	2: 'down',
	3: 'no',
	4: 'left',
	8: 'right',
	15: '?',
	16: 'action',
	18: 'random',
	32: 'lclick',
	64: 'rclick',
	// todo: ??: 'mclick',
	// todo: ??: 'reaction',
};

var dirMasks = {
	'up': 1,
	'down': 2,
	'no': 3,
	'left': 4,
	'randomdir': 5,
	'right': 8,
	'moving': 15,
	'action': 16,
	'random': 18,
	'lclick': 32,
	'rclick': 64,
	// todo: 'mclick': ??,
	// todo: 'reaction': ??,
	'': 0
};

// X and Y increments for each move (in mask form)
var dirMasksDelta = {
	1: [0, -1],
	2: [0, 1],
	3: [0, 0],
	4: [-1, 0],
	8: [1, 0],
	15: [0, 0],
	16: [0, 0],
	18: [0, 0],
	32: [0, 0],
	64: [0, 0]
};

// utility functions
function getObject(objid) {
	return state.objects[state.idDict[objid]];
}

// get movement in layer from movement mask
function getLayerMovement(movmask, layer) {
	return movmask.getshiftor(MOV_MASK, MOV_BITS * layer);
}

// update position index by x and y
function deltaPositionIndex(level, positionIndex, x, y) {
	return positionIndex + y + x * level.height;
}

function getPlayerPositions() {
    var result=[];
    var playerMask = state.playerMask;
    for (var i=0;i<curLevel.n_tiles;i++) {
        curLevel.getCellInto(i,_o11);
        if (playerMask.anyBitsInCommon(_o11)) {
            result.push(i);
        }
    }
    return result;
}

function getLayersOfMask(cellMask) {
    var layers=[];
    for (var i=0;i<state.objectCount;i++) {
        if (cellMask.get(i)) {
            var n = state.idDict[i];
            var o = state.objects[n];
            layers.push(o.layer)
        }
    }
    return layers;
}

function moveEntitiesAtIndex(positionIndex, entityMask, dirMask) {
    var cellMask = curLevel.getCell(positionIndex);
    cellMask.iand(entityMask);
    var layers = getLayersOfMask(cellMask);

    var movementMask = curLevel.getMovements(positionIndex);
    for (var i=0;i<layers.length;i++) {
      movementMask.ishiftor(dirMask, MOV_BITS * layers[i]);
    }
    curLevel.setMovements(positionIndex, movementMask);

	var colIndex=(positionIndex/curLevel.height)|0;
	var rowIndex=(positionIndex%curLevel.height);
	curLevel.colCellContents_Movements[colIndex].ior(movementMask);
	curLevel.rowCellContents_Movements[rowIndex].ior(movementMask);
	curLevel.mapCellContents_Movements.ior(movementMask);
}


function startMovement(dir) {
  var movedany=false;
    var playerPositions = getPlayerPositions();
    for (var i=0;i<playerPositions.length;i++) {
        var playerPosIndex = playerPositions[i];
        moveEntitiesAtIndex(playerPosIndex,state.playerMask,dir);
    }
    return playerPositions;
}

var seedsToPlay_CanMove=[];
var seedsToPlay_CantMove=[];
var seedsToAnimate={};  // doc: "positition,layer": { kind:, seed:, dir: }

function repositionEntitiesOnLayer(positionIndex,layer,dirMask) 
{
    var delta = dirMasksDelta[dirMask];

    var dx = delta[0];
    var dy = delta[1];
    var tx = ((positionIndex/curLevel.height)|0);
    var ty = ((positionIndex%curLevel.height));
    var maxx = curLevel.width-1;
    var maxy = curLevel.height-1;

    if ( (tx===0&&dx<0) || (tx===maxx&&dx>0) || (ty===0&&dy<0) || (ty===maxy&&dy>0)) {
      return false;
    }

    var targetIndex = (positionIndex+delta[1]+delta[0]*curLevel.height);

    var layerMask = state.layerMasks[layer];
    var targetMask = curLevel.getCellInto(targetIndex,_o7);
	var sourceMask = curLevel.getCellInto(positionIndex,_o8);

    if (layerMask.anyBitsInCommon(targetMask) && (dirMask < 16)) {		// tofix: 16
        return false;
    }

	// for each sound movement event, which applies to a single object and layer
	for (let i=0;i<state.sfx_MovementMasks[layer].length;i++) {
		const fx = state.sfx_MovementMasks[layer][i];
		if (sourceMask.get(fx.objId)) {
      		var movementMask = curLevel.getMovements(positionIndex);
      		var directionMask = fx.directionMask;
			// does it match any movement at this location?
      		if (movementMask.anyBitsInCommon(directionMask)) {  // bug: two objects at location can cause false trigger
    			if (verbose_logging) 
					consolePrint(`Object "${state.idDict[fx.objId]}" has moved, playing seed "${fx.seed}".`)
				if (fx.seed.startsWith('afx')) {
					const object = getObject(fx.objId);
					const move = getLayerMovement(movementMask, object.layer);
					const position = deltaPositionIndex(curLevel, positionIndex, dirMasksDelta[move][0], dirMasksDelta[move][1])
					seedsToAnimate[position+','+fx.objId] = { 
						kind: 'move', 
						seed: fx.seed, 
						dir: move 
					};
				}
				else if (seedsToPlay_CanMove.indexOf(fx.seed)===-1)
					seedsToPlay_CanMove.push(fx.seed);
      		}
    	}
  	}

    var movingEntities = sourceMask.clone();
    sourceMask.iclear(layerMask);
    movingEntities.iand(layerMask);
    targetMask.ior(movingEntities);

    curLevel.setCell(positionIndex, sourceMask);
	curLevel.setCell(targetIndex, targetMask);
	
    var colIndex=(targetIndex/curLevel.height)|0;
	var rowIndex=(targetIndex%curLevel.height);
	
    curLevel.colCellContents[colIndex].ior(movingEntities);
    curLevel.rowCellContents[rowIndex].ior(movingEntities);
	//corresponding movement stuff in setmovements
    return true;
}

function repositionEntitiesAtCell(positionIndex) {
    var movementMask = curLevel.getMovements(positionIndex);
    if (movementMask.iszero())
        return false;

    var moved=false;
    for (var layer=0;layer<curLevel.layerCount;layer++) {
        var layerMovement = movementMask.getshiftor(MOV_MASK, MOV_BITS * layer);
        if (layerMovement!==0) {
            var thismoved = repositionEntitiesOnLayer(positionIndex,layer,layerMovement);
            if (thismoved) {
				if (state.metadata.tween_length) {
					var delta = dirMasksDelta[layerMovement];
					var targetIndex = (positionIndex+delta[1]+delta[0]*curLevel.height);

					newMovedEntities["p"+targetIndex+"-l"+layer] = layerMovement;
				}

                movementMask.ishiftclear(layerMovement, MOV_BITS * layer);
				moved = true;
            }
        }
    }

    curLevel.setMovements(positionIndex, movementMask);

    return moved;
}


function Level(lineNumber, width, height, layerCount, objects, section) {
	this.lineNumber = lineNumber;
	this.width = width;
	this.height = height;
	this.n_tiles = width * height;
	this.objects = objects;
	this.section = section;
	this.layerCount = layerCount;
	this.commandQueue = [];
	this.commandQueueSourceRules = [];
}

Level.prototype.delta_index = function(direction)
{
	const [dx, dy] = dirMasksDelta[direction]
	return dx*this.height + dy
}

Level.prototype.clone = function() {
	var clone = new Level(this.lineNumber, this.width, this.height, this.layerCount, null, this.section);
	clone.objects = new Int32Array(this.objects);
	return clone;
}

Level.prototype.getCell = function(index) {
  return new BitVec(this.objects.subarray(index * STRIDE_OBJ, index * STRIDE_OBJ + STRIDE_OBJ));
}

Level.prototype.getCellInto = function(index,targetarray) {
  for (var i=0;i<STRIDE_OBJ;i++) {
    targetarray.data[i]=this.objects[index*STRIDE_OBJ+i]; 
  }
  return targetarray;
}

Level.prototype.setCell = function(index, vec) {
  for (var i = 0; i < vec.data.length; ++i) {
    this.objects[index * STRIDE_OBJ + i] = vec.data[i];
  }
}

var _movementVecs;
var _movementVecIndex=0;
Level.prototype.getMovements = function(index) {
  var _movementsVec=_movementVecs[_movementVecIndex];
  _movementVecIndex=(_movementVecIndex+1)%_movementVecs.length;

  for (var i=0;i<STRIDE_MOV;i++) {
		_movementsVec.data[i]= this.movements[index*STRIDE_MOV+i];	
  }
  return _movementsVec;
}

Level.prototype.getRigids = function(index) {
	return this.rigidMovementAppliedMask[index].clone();
}

Level.prototype.getMovementsInto = function(index,targetarray) {
	var _movementsVec=targetarray;

	for (var i=0;i<STRIDE_MOV;i++) {
		_movementsVec.data[i]=this.movements[index*STRIDE_MOV+i];	
	}
	return _movementsVec;
}

Level.prototype.setMovements = function(index, vec) {
	for (var i = 0; i < vec.data.length; ++i) {
		this.movements[index * STRIDE_MOV + i] = vec.data[i];
	}

	var targetIndex = index*STRIDE_MOV + i;
		
	//corresponding object stuff in repositionEntitiesOnLayer
	var colIndex=(index/this.height)|0;
	var rowIndex=(index%this.height);
	curLevel.colCellContents_Movements[colIndex].ior(vec);
	curLevel.rowCellContents_Movements[rowIndex].ior(vec);
	curLevel.mapCellContents_Movements.ior(vec);


}

// return a list of object names at index
Level.prototype.getObjects = function(index) {
	const bitmask = this.getCell(index);
	const objs = [];
	for (let bit = 0; bit < 32 * STRIDE_OBJ; ++bit) {
		if (bitmask.get(bit)) {
			objs.push(state.idDict[bit])
		}
	}
	return objs;
}

var ellipsisPattern = ['ellipsis'];

function BitVec(init) {
	this.data = new Int32Array(init);
	return this;
}

BitVec.prototype.format = function() {
	return '[' + [...this.data].map(d => `${d.toString(16)}h`).join(',') + ']';
}

BitVec.prototype.cloneInto = function(target) {
  for (var i=0;i<this.data.length;++i) {
    target.data[i]=this.data[i];
  }
  return target;
}
BitVec.prototype.clone = function() {
  return new BitVec(this.data);
}

BitVec.prototype.iand = function(other) {
  for (var i = 0; i < this.data.length; ++i) {
    this.data[i] &= other.data[i];
  }
}


BitVec.prototype.inot = function() {
	for (var i = 0; i < this.data.length; ++i) {
		this.data[i] = ~this.data[i];
	}
}

BitVec.prototype.ior = function(other) {
  for (var i = 0; i < this.data.length; ++i) {
    this.data[i] |= other.data[i];
  }
}

BitVec.prototype.iclear = function(other) {
  for (var i = 0; i < this.data.length; ++i) {
    this.data[i] &= ~other.data[i];
  }
}

BitVec.prototype.ibitset = function(ind) {
  this.data[ind>>5] |= 1 << (ind & 31);
}

BitVec.prototype.ibitclear = function(ind) {
  this.data[ind>>5] &= ~(1 << (ind & 31));
}

BitVec.prototype.get = function(ind) {
  return (this.data[ind>>5] & 1 << (ind & 31)) !== 0;
}

BitVec.prototype.getshiftor = function(mask, shift) {
  var toshift = shift & 31;
  var ret = this.data[shift>>5] >>> (toshift);
  if (toshift) {
    ret |= this.data[(shift>>5)+1] << (32 - toshift);
  }
  return ret & mask;
}

BitVec.prototype.ishiftor = function(mask, shift) {
  var toshift = shift&31;
  var low = mask << toshift;
  this.data[shift>>5] |= low;
  if (toshift) {
    var high = mask >> (32 - toshift);
    this.data[(shift>>5)+1] |= high;
  }
}

BitVec.prototype.ishiftclear = function(mask, shift) {
  var toshift = shift & 31;
  var low = mask << toshift;
  this.data[shift>>5] &= ~low;
  if (toshift){
    var high = mask >> (32 - (shift & 31));
    this.data[(shift>>5)+1] &= ~high;
  }
}

BitVec.prototype.equals = function(other) {
  if (this.data.length !== other.data.length)
    return false;
  for (var i = 0; i < this.data.length; ++i) {
    if (this.data[i] !== other.data[i])
      return false;
  }
  return true;
}

BitVec.prototype.setZero = function() {
  for (var i = 0; i < this.data.length; ++i) {
    this.data[i]=0;
  }
}

BitVec.prototype.iszero = function() {
  for (var i = 0; i < this.data.length; ++i) {
    if (this.data[i])
      return false;
  }
  return true;
}

BitVec.prototype.bitsSetInArray = function(arr) {
  for (var i = 0; i < this.data.length; ++i) {
    if ((this.data[i] & arr[i]) !== this.data[i]) {
      return false;
    }
  }
  return true;
}

BitVec.prototype.bitsClearInArray = function(arr) {
  for (var i = 0; i < this.data.length; ++i) {
    if (this.data[i] & arr[i]) {
      return false;
    }
  }
  return true;
}

BitVec.prototype.anyBitsInCommon = function(other) {
  return !this.bitsClearInArray(other.data);
}

function Rule(rule) {
	this.direction = rule[0]; 		/* direction rule scans in */
	this.patterns = rule[1];		/* lists of CellPatterns to match */
	this.hasReplacements = rule[2];
	this.lineNumber = rule[3];		/* rule source for debugging */
	this.ellipsisCount = rule[4];		/* number of ellipses present */
	this.groupNumber = rule[5];		/* execution group number of rule */
	this.isRigid = rule[6];
	this.commands = rule[7];		/* cancel, restart, sfx, etc */
	this.isRandom = rule[8];
	this.cellRowMasks = rule[9];
    this.cellRowMasks_Movements = rule[10];
    this.isGlobal = rule[11];
    this.isOnce = rule[12];
	this.ruleMask = this.cellRowMasks.reduce( (acc, m) => { acc.ior(m); return acc }, new BitVec(STRIDE_OBJ) );

	/*I tried out doing a ruleMask_movements as well along the lines of the above,
	but it didn't help at all - I guess because almost every tick there are movements 
	somewhere on the board - move filtering works well at a row/col level, but is pretty 
	useless (or worse than useless) on a boardwide level*/

	this.cellRowMatches = [];
	for (var i=0;i<this.patterns.length;i++) {
		this.cellRowMatches.push(this.generateCellRowMatchesFunction(this.patterns[i],this.ellipsisCount[i]));
	}
	/* TODO: eliminate isRigid, groupNumber, isRandom
	from this class by moving them up into a RuleGroup class */
}


Rule.prototype.generateCellRowMatchesFunction = function(cellRow,ellipsisCount)  {
	if (ellipsisCount===0) {
		var cr_l = cellRow.length;

		/*
		hard substitute in the first one - if I substitute in all of them, firefox chokes.
		*/
		var fn = "";
		var mul = STRIDE_OBJ === 1 ? '' : '*'+STRIDE_OBJ;	
		for (var i = 0; i < STRIDE_OBJ; ++i) {
			fn += 'var cellObjects' + i + ' = objects[i' + mul + (i ? '+'+i: '') + '];\n';
		}
		mul = STRIDE_MOV === 1 ? '' : '*'+STRIDE_MOV;
		for (var i = 0; i < STRIDE_MOV; ++i) {
			fn += 'var cellMovements' + i + ' = movements[i' + mul + (i ? '+'+i: '') + '];\n';
		}
		fn += "return "+cellRow[0].generateMatchString('0_');// cellRow[0].matches(i)";
		for (var cellIndex=1;cellIndex<cr_l;cellIndex++) {
			fn+="&&cellRow["+cellIndex+"].matches(i+"+cellIndex+"*d, objects, movements)";
		}
		fn+=";";

		if (fn in matchCache) {
			return matchCache[fn];
		}
		return matchCache[fn] = new Function("cellRow","i", 'd', 'objects', 'movements',fn);
	} else if (ellipsisCount===1){
		var cr_l = cellRow.length;

		var fn = "var result = [];\n"
		fn += "if(cellRow[0].matches(i, objects, movements)";
		var cellIndex=1;
		for (;cellRow[cellIndex]!==ellipsisPattern;cellIndex++) {
			fn+="&&cellRow["+cellIndex+"].matches(i+"+cellIndex+"*d, objects, movements)";
		}
		cellIndex++;
		fn+=") {\n";
		fn+="\tfor (var k=kmin;k<kmax;k++) {\n"
		fn+="\t\tif(cellRow["+cellIndex+"].matches((i+d*(k+"+(cellIndex-1)+")), objects, movements)";
		cellIndex++;
		for (;cellIndex<cr_l;cellIndex++) {
			fn+="&&cellRow["+cellIndex+"].matches((i+d*(k+"+(cellIndex-1)+")), objects, movements)";			
		}
		fn+="){\n";
		fn+="\t\t\tresult.push([i,k]);\n";
		fn+="\t\t}\n"
		fn+="\t}\n";				
		fn+="}\n";		
		fn+="return result;"


		if (fn in matchCache) {
			return matchCache[fn];
		}
		//console.log(fn.replace(/\s+/g, ' '));
		return matchCache[fn] = new Function("cellRow","i","kmax","kmin", 'd', "objects", "movements",fn);
	} else { //ellipsisCount===2
		var cr_l = cellRow.length;

		var ellipsis_index_1=-1;
		var ellipsis_index_2=-1;
		for (var cellIndex=0;cellIndex<cr_l;cellIndex++) {
			if (cellRow[cellIndex]===ellipsisPattern) {
				if (ellipsis_index_1===-1) {
					ellipsis_index_1=cellIndex;
				} else {
					ellipsis_index_2=cellIndex;
					break;
				}
			}
		}

		var fn = "var result = [];\n"
		fn += "if(cellRow[0].matches(i, objects, movements)";

		for (var idx=1;idx<ellipsis_index_1;idx++) {
			fn+="&&cellRow["+idx+"].matches(i+"+idx+"*d, objects, movements)";
		}
		fn+=") {\n";

		//try match middle part
		fn+="	for (var k1=k1min;k1<k1max;k1++) {\n"
		fn+="		if(cellRow["+(ellipsis_index_1+1)+"].matches((i+d*(k1+"+(ellipsis_index_1+1-1)+")), objects, movements)";
		for (var idx=ellipsis_index_1+2;idx<ellipsis_index_2;idx++) {
			fn+="&&cellRow["+idx+"].matches((i+d*(k1+"+(idx-1)+")), objects, movements)";			
		}
		fn+="		){\n";
		//try match right part

		fn+="			for (var k2=k2min;k1+k2<kmax && k2<k2max;k2++) {\n"
		fn+="				if(cellRow["+(ellipsis_index_2+1)+"].matches((i+d*(k1+k2+"+(ellipsis_index_2+1-2)+")), objects, movements)";
		for (var idx=ellipsis_index_2+2;idx<cr_l;idx++) {
			fn+="&&cellRow["+idx+"].matches((i+d*(k1+k2+"+(idx-2)+")), objects, movements)";			
		}
		fn+="				){\n";
		fn+="					result.push([i,k1,k2]);\n";
		fn+="				}\n"
		fn+="			}\n"
		fn+="		}\n"
		fn+="	}\n";				
		fn+="}\n";		
		fn+="return result;"


		if (fn in matchCache) {
			return matchCache[fn];
		}
		//console.log(fn.replace(/\s+/g, ' '));
		return matchCache[fn] = new Function("cellRow","i","kmax","kmin", "k1max","k1min","k2max","k2min", 'd', "objects", "movements",fn);

	}
//say cellRow has length 3, with a split in the middle
/*
function cellRowMatchesWildcardFunctionGenerate(direction,cellRow,i, maxk, mink) {
  var result = [];
  var matchfirsthalf = cellRow[0].matches(i);
  if (matchfirsthalf) {
    for (var k=mink;k<maxk;k++) {
      if (cellRow[2].matches((i+d*(k+0)))) {
        result.push([i,k]);
      }
    }
  }
  return result;
}
*/
  

}

let MOV_BITS = 5;		// doc: no of bits to hold movement as mask
let MOV_MASK = 0x1f;	// doc: bit mask to match
var STRIDE_OBJ = 1;	    // doc: size of BitVec to hold objects, at 32 bits per
var STRIDE_MOV = 1;		// doc: size of BitVec to hold movements, at MOV_BITS bits per

function CellPattern(row) {
  this.objectsPresent = row[0];
  this.objectsMissing = row[1];
  this.anyObjectsPresent = row[2];
  this.movementsPresent = row[3];
  this.movementsMissing = row[4];
  this.matches = this.generateMatchFunction();
  this.replacement = row[5];
};

function CellReplacement(row) {
  this.objectsClear = row[0];
  this.objectsSet = row[1];
  this.movementsClear = row[2];
  this.movementsSet = row[3];
  this.movementsLayerMask = row[4];
  this.randomEntityMask = row[5];
  this.randomDirMask = row[6];
};


var matchCache = {};



CellPattern.prototype.generateMatchString = function() {
  var fn = "(true";
  for (var i = 0; i < Math.max(STRIDE_OBJ, STRIDE_MOV); ++i) {
    var co = 'cellObjects' + i;
    var cm = 'cellMovements' + i;
    var op = this.objectsPresent.data[i];
    var om = this.objectsMissing.data[i];
    var mp = this.movementsPresent.data[i];
    var mm = this.movementsMissing.data[i];
    if (op) {
      if (op&(op-1))
        fn += '\t\t&& ((' + co + '&' + op + ')===' + op + ')\n';
      else
        fn += '\t\t&& (' + co + '&' + op + ')\n';
    }
    if (om)
      fn += '\t\t&& !(' + co + '&' + om + ')\n';
    if (mp) {
      if (mp&(mp-1))
        fn += '\t\t&& ((' + cm + '&' + mp + ')===' + mp + ')\n';
      else
        fn += '\t\t&& (' + cm + '&' + mp + ')\n';
    }
    if (mm)
      fn += '\t\t&& !(' + cm + '&' + mm + ')\n';
  }
  for (var j = 0; j < this.anyObjectsPresent.length; j++) {
    fn += "\t\t&& (0";
    for (var i = 0; i < STRIDE_OBJ; ++i) {
      var aop = this.anyObjectsPresent[j].data[i];
      if (aop)
        fn += "|(cellObjects" + i + "&" + aop + ")";
    }
    fn += ")";
  }
  fn += '\t)';
  return fn;
}

CellPattern.prototype.generateMatchFunction = function() {
	var i;
	var fn = '';
	var mul = STRIDE_OBJ === 1 ? '' : '*'+STRIDE_OBJ;	
	for (var i = 0; i < STRIDE_OBJ; ++i) {
		fn += '\tvar cellObjects' + i + ' = objects[i' + mul + (i ? '+'+i: '') + '];\n';
	}
	mul = STRIDE_MOV === 1 ? '' : '*'+STRIDE_MOV;
	for (var i = 0; i < STRIDE_MOV; ++i) {
		fn += '\tvar cellMovements' + i + ' = movements[i' + mul + (i ? '+'+i: '') + '];\n';
	}
	fn += "return " + this.generateMatchString()+';';
	if (fn in matchCache) {
		return matchCache[fn];
	}
	//console.log(fn.replace(/\s+/g, ' '));
	return matchCache[fn] = new Function("i", "objects", "movements", fn);
}

var _o1,_o2,_o2_5,_o3,_o4,_o5,_o6,_o7,_o8,_o9,_o10,_o11,_o12;
var _m1,_m2,_m3;

CellPattern.prototype.replace = function(rule, currentIndex) {
  var replace = this.replacement;

  if (replace === null) {
    return false;
  }

  var replace_RandomEntityMask = replace.randomEntityMask;
  var replace_RandomDirMask = replace.randomDirMask;

  var objectsSet = replace.objectsSet.cloneInto(_o1);
  var objectsClear = replace.objectsClear.cloneInto(_o2);

  var movementsSet = replace.movementsSet.cloneInto(_m1);
  var movementsClear = replace.movementsClear.cloneInto(_m2);
  movementsClear.ior(replace.movementsLayerMask);

  if (!replace_RandomEntityMask.iszero()) {
    var choices=[];
    for (var i=0;i<32*STRIDE_OBJ;i++) {
      if (replace_RandomEntityMask.get(i)) {
        choices.push(i);
      }
    }
    var rand = choices[Math.floor(RandomGen.uniform() * choices.length)];
    var n = state.idDict[rand];
    var o = state.objects[n];
    objectsSet.ibitset(rand);
    objectsClear.ior(state.layerMasks[o.layer]);
    movementsClear.ishiftor(MOV_MASK, MOV_BITS * o.layer);
  }
  if (!replace_RandomDirMask.iszero()) {
    for (var layerIndex=0;layerIndex<curLevel.layerCount;layerIndex++){
      if (replace_RandomDirMask.get(MOV_BITS * layerIndex)) {
        var randomDir = Math.floor(RandomGen.uniform()*4);
        movementsSet.ibitset(randomDir + MOV_BITS * layerIndex);
      }
    }
  }
  
  var curCellMask = curLevel.getCellInto(currentIndex,_o2_5);
  var curMovementMask = curLevel.getMovements(currentIndex);

  var oldCellMask = curCellMask.cloneInto(_o3);
  var oldMovementMask = curMovementMask.cloneInto(_m3);

  curCellMask.iclear(objectsClear);
  curCellMask.ior(objectsSet);

  curMovementMask.iclear(movementsClear);
  curMovementMask.ior(movementsSet);

  var rigidchange=false;
  var curRigidGroupIndexMask =0;
  var curRigidMovementAppliedMask =0;
  if (rule.isRigid) {
    var rigidGroupIndex = state.groupNumber_to_RigidGroupIndex[rule.groupNumber];
    rigidGroupIndex++;//don't forget to -- it when decoding :O
    var rigidMask = new BitVec(STRIDE_MOV);
    for (var layer = 0; layer < curLevel.layerCount; layer++) {
      rigidMask.ishiftor(rigidGroupIndex, MOV_BITS * layer);
    }
    rigidMask.iand(replace.movementsLayerMask);
    curRigidGroupIndexMask = curLevel.rigidGroupIndexMask[currentIndex] || new BitVec(STRIDE_MOV);
    curRigidMovementAppliedMask = curLevel.rigidMovementAppliedMask[currentIndex] || new BitVec(STRIDE_MOV);

    if (!rigidMask.bitsSetInArray(curRigidGroupIndexMask.data) &&
      !replace.movementsLayerMask.bitsSetInArray(curRigidMovementAppliedMask.data) ) {
      curRigidGroupIndexMask.ior(rigidMask);
      curRigidMovementAppliedMask.ior(replace.movementsLayerMask);
      rigidchange=true;

    }
  }

  var result = false;

  //check if it's changed
  if (!oldCellMask.equals(curCellMask) || !oldMovementMask.equals(curMovementMask) || rigidchange) { 
		result=true;
		if (rigidchange) {
			curLevel.rigidGroupIndexMask[currentIndex] = curRigidGroupIndexMask;
			curLevel.rigidMovementAppliedMask[currentIndex] = curRigidMovementAppliedMask;
		}

		// were any objects create or destroyed? Add to list for sfx checking
		// - as mask, one bit per object
		// - as list, one entry per object, with position

		var created = curCellMask.cloneInto(_o4);
		created.iclear(oldCellMask);
		sfxCreateMask.ior(created);
		for (let objId = 0; objId < state.objectCount; ++objId) {
			if (created.get(objId))
				sfxCreateList.push({ 
					posIndex: currentIndex, objId: objId
				});
		}

		var destroyed = oldCellMask.cloneInto(_o5);
		destroyed.iclear(curCellMask);
		sfxDestroyMask.ior(destroyed);
		for (let objId = 0; objId < state.objectCount; ++objId) {
			if (destroyed.get(objId))
				sfxDestroyList.push({ 
					posIndex: currentIndex, objId: objId
				});
		}

		curLevel.setCell(currentIndex, curCellMask);
		curLevel.setMovements(currentIndex, curMovementMask);

		var colIndex=(currentIndex/curLevel.height)|0;
		var rowIndex=(currentIndex%curLevel.height);
		curLevel.colCellContents[colIndex].ior(curCellMask);
		curLevel.rowCellContents[rowIndex].ior(curCellMask);
		curLevel.mapCellContents.ior(curCellMask);

	}

  	return result;
}



function matchCellRow(direction, cellRowMatch, cellRow, cellRowMask,cellRowMask_Movements,d, isGlobal) {	
	var result=[];
	
	if ((!cellRowMask.bitsSetInArray(curLevel.mapCellContents.data))||
	(!cellRowMask_Movements.bitsSetInArray(curLevel.mapCellContents_Movements.data))) {
		return result;
	}

  if(isGlobal || state.metadata.local_radius === undefined){
    xmin=0;
    xmax=curLevel.width;
    ymin=0;
    ymax=curLevel.height;
  }
  else{
    var localradius = parseInt(state.metadata.local_radius);
    xmin=Math.max(0, (playerPositions[0]/curLevel.height|0) - localradius);
    xmax=Math.min(curLevel.width, (playerPositions[0]/curLevel.height|0) + localradius +1);
    ymin=Math.max(0, playerPositions[0]%curLevel.height - localradius);
    ymax=Math.min(curLevel.height, playerPositions[0]%curLevel.height + localradius+1);

  }

    var len=cellRow.length;

    switch(direction) {
      case 1://up
      {
        ymin+=(len-1);
        break;
      }
      case 2: //down 
      {
      ymax-=(len-1);
      break;
      }
      case 4: //left
      {
        xmin+=(len-1);
        break;
      }
      case 8: //right
    {
      xmax-=(len-1);  
      break;
    }
      default:
      {
        window.console.log("EEEP "+direction);
      }
    }

    var horizontal=direction>2;
    if (horizontal) {
		for (var y=ymin;y<ymax;y++) {
			if (!cellRowMask.bitsSetInArray(curLevel.rowCellContents[y].data) 
			|| !cellRowMask_Movements.bitsSetInArray(curLevel.rowCellContents_Movements[y].data)) {
				continue;
			}

			for (var x=xmin;x<xmax;x++) {
				var i = x*curLevel.height+y;
				if (cellRowMatch(cellRow,i,d, curLevel.objects, curLevel.movements))
				{
					result.push(i);
				}
			}
		}
	} else {
		for (var x=xmin;x<xmax;x++) {
			if (!cellRowMask.bitsSetInArray(curLevel.colCellContents[x].data)
			|| !cellRowMask_Movements.bitsSetInArray(curLevel.colCellContents_Movements[x].data)) {
				continue;
			}

			for (var y=ymin;y<ymax;y++) {
				var i = x*curLevel.height+y;
				if (cellRowMatch(cellRow,i, d, curLevel.objects, curLevel.movements)) {
					result.push(i);
				}
			}
		}		
	}

  return result;
}


function matchCellRowWildCard(direction, cellRowMatch, cellRow,cellRowMask,cellRowMask_Movements,d,wildcardCount) {
	var result=[];
	if ((!cellRowMask.bitsSetInArray(curLevel.mapCellContents.data))
	|| (!cellRowMask_Movements.bitsSetInArray(curLevel.mapCellContents_Movements.data))) {
		return result;
	}
	
	var xmin=0;
	var xmax=curLevel.width;
	var ymin=0;
	var ymax=curLevel.height;

	var len=cellRow.length-wildcardCount;//remove one to deal with wildcard
    switch(direction) {
      case 1://up
      {
        ymin+=(len-1);
        break;
      }
      case 2: //down 
      {
      ymax-=(len-1);
      break;
      }
      case 4: //left
      {
        xmin+=(len-1);
        break;
      }
      case 8: //right
    {
      xmax-=(len-1);  
      break;
    }
      default:
      {
        window.console.log("EEEP2 "+direction);
      }
    }



    var horizontal=direction>2;
    if (horizontal) {
		for (var y=ymin;y<ymax;y++) {
			if (!cellRowMask.bitsSetInArray(curLevel.rowCellContents[y].data)
			|| !cellRowMask_Movements.bitsSetInArray(curLevel.rowCellContents_Movements[y].data) ) {
				continue;
			}

			for (var x=xmin;x<xmax;x++) {
				var i = x*curLevel.height+y;
				var kmax;

				if (direction === 4) { //left
					kmax=x-len+2;
				} else if (direction === 8) { //right
					kmax=curLevel.width-(x+len)+1;	
				} else {
					window.console.log("EEEP2 "+direction);					
				}

				if (wildcardCount===1) {
				result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, d, curLevel.objects, curLevel.movements));
				} else {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0,kmax,0,kmax,0, d, curLevel.objects, curLevel.movements));
			}
		}
		}
	} else {
		for (var x=xmin;x<xmax;x++) {
			if (!cellRowMask.bitsSetInArray(curLevel.colCellContents[x].data)
			|| !cellRowMask_Movements.bitsSetInArray(curLevel.colCellContents_Movements[x].data)) {
				continue;
			}

			for (var y=ymin;y<ymax;y++) {
				var i = x*curLevel.height+y;
				var kmax;


        if (direction === 2) { // down
          kmax=curLevel.height-(y+len)+1;
        } else if (direction === 1) { // up
          kmax=y-len+2;         
        } else {
          window.console.log("EEEP2 "+direction);
        }
				if (wildcardCount===1) {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, d, curLevel.objects, curLevel.movements));
				} else {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, kmax,0, kmax,0, d, curLevel.objects, curLevel.movements));
				}
			}
    }   
  }

  return result;
}

function generateTuples(lists) {
    var tuples=[[]];

    for (var i=0;i<lists.length;i++)
    {
        var row = lists[i];
        var newtuples=[];
        for (var j=0;j<row.length;j++) {
            var valtoappend = row[j];
            for (var k=0;k<tuples.length;k++) {
                var tuple=tuples[k];
                var newtuple = tuple.concat([valtoappend]);
                newtuples.push(newtuple);
            }
        }
        tuples=newtuples;
    }
    return tuples;
}


Rule.prototype.findMatches = function() {	
	if ( ! this.ruleMask.bitsSetInArray(curLevel.mapCellContents.data) )
		return [];

	const d = curLevel.delta_index(this.direction)

	if (debugSwitch.includes('masks')) console.log(`Findmatches d=${d} dir=${this.direction} levobj=${curLevel.objects} levmov=${curLevel.movements}`);
	var matches=[];
	var cellRowMasks=this.cellRowMasks;
	var cellRowMasks_Movements=this.cellRowMasks_Movements;
    for (var cellRowIndex=0;cellRowIndex<this.patterns.length;cellRowIndex++) {
        var cellRow = this.patterns[cellRowIndex];
        var matchFunction = this.cellRowMatches[cellRowIndex];
        if (this.ellipsisCount[cellRowIndex]===1) {//if ellipsis     
        	var match = matchCellRowWildCard(this.direction,matchFunction,cellRow,cellRowMasks[cellRowIndex],cellRowMasks_Movements[cellRowIndex],d,this.ellipsisCount[cellRowIndex]);  
        } else  if (this.ellipsisCount[cellRowIndex]===0) {
        	var match = matchCellRow(this.direction,matchFunction,cellRow,cellRowMasks[cellRowIndex],cellRowMasks_Movements[cellRowIndex],d, this.isGlobal);               	
        } else { // ellipsiscount===2
        	var match = matchCellRowWildCard(this.direction,matchFunction,cellRow,cellRowMasks[cellRowIndex],cellRowMasks_Movements[cellRowIndex],d,this.ellipsisCount[cellRowIndex]);  
        }
		if (debugSwitch.includes('masks')) {
			const cro = cellRowMasks[cellRowIndex].format();
			const crm = cellRowMasks_Movements[cellRowIndex].format();
			const lvo = curLevel.mapCellContents.format();
			const lvm = curLevel.mapCellContents_Movements.format();
			console.log(`cro=${cro} crm=${crm} lvo=${lvo} lvm=${lvm} => ${match}`);
		}
        if (match.length===0) {
            return [];
        } else {
            matches.push(match);
        }
    }
    return matches;
};

Rule.prototype.directional = function(){
  //Check if other rules in its rulegroup with the same line number.
  for (var i=0;i<state.rules.length;i++){
    var rg = state.rules[i];
    var copyCount=0;
    for (var j=0;j<rg.length;j++){
      if (this.lineNumber===rg[j].lineNumber){
        copyCount++;
      }
      if (copyCount>1){
        return true;
      }
    }
  }

    return false;
}

Rule.prototype.applyAt = function(level,tuple,check,delta) {
	var rule = this;
	//have to double check they apply 
	//(cf test ellipsis bug: rule matches two candidates, first replacement invalidates second)
	if (check)
	{
		for (var cellRowIndex=0; cellRowIndex<this.patterns.length; cellRowIndex++)
		{
			if (this.ellipsisCount[cellRowIndex]===1)
			{
				if ( this.cellRowMatches[cellRowIndex](
						this.patterns[cellRowIndex], 
						tuple[cellRowIndex][0], 
						tuple[cellRowIndex][1]+1, 
							tuple[cellRowIndex][1], 
						delta, level.objects, level.movements
					).length == 0 )
					return false
			} else if (this.ellipsisCount[cellRowIndex]===2){
				if ( this.cellRowMatches[cellRowIndex](
					this.patterns[cellRowIndex], 
						tuple[cellRowIndex][0],  
						tuple[cellRowIndex][1]+tuple[cellRowIndex][2]+1, 
							tuple[cellRowIndex][1]+tuple[cellRowIndex][2], 
						tuple[cellRowIndex][1]+1, 
							tuple[cellRowIndex][1],  
						tuple[cellRowIndex][2]+1, 
							tuple[cellRowIndex][2], 
							delta, level.objects, level.movements
						).length == 0 )
				return false
			} else {
				if ( ! this.cellRowMatches[cellRowIndex](
					this.patterns[cellRowIndex], 
						tuple[cellRowIndex], 
						delta, level.objects, level.movements
						) )
				return false
		}
	}
	}


    var result=false;
	var anyellipses=false;
	const cellIndexes = [];

    //APPLY THE RULE
    for (var cellRowIndex=0;cellRowIndex<rule.patterns.length;cellRowIndex++) {
        var preRow = rule.patterns[cellRowIndex];
    	var ellipse_index=0;

        var currentIndex = rule.ellipsisCount[cellRowIndex]>0 ? tuple[cellRowIndex][0] : tuple[cellRowIndex];
        for (var cellIndex=0;cellIndex<preRow.length;cellIndex++) {
            var preCell = preRow[cellIndex];

            if (preCell === ellipsisPattern) {
            	var k = tuple[cellRowIndex][1+ellipse_index];
				ellipse_index++;
				anyellipses=true;
            	currentIndex += delta*k;
            	continue;
            }

            result = preCell.replace(rule, currentIndex) || result;
			cellIndexes.push(currentIndex);

            currentIndex += delta;
        }
    }

  if (verbose_logging && result){
    var ruleDirection = dirMaskName[rule.direction];
    if (!rule.directional()){
      ruleDirection="";
    }

		var inspect_ID =  addToDebugTimeline(level,rule.lineNumber);
		const locations = cellIndexes.map(i => `(${1 + i % level.width};${1 + ~~(i / level.width)})`).join(', ');
		var gapMessage= (debugSwitch.includes('gaploc')) ? ` at ${locations}` : '';

		//var gapMessage="";
		// var gapcount=0;
		// if (anyellipses){
		// 	var added=0;
		// 	for(var i=0;i<tuple.length;i++){
		// 		var tuples_cellrow = tuple[i];
		// 		//Start at index 1 because index 0 just is the index where the rule starts.
		// 		for (var j=1;j<tuples_cellrow.length;j++){
		// 			added++;
		// 			if (gapMessage.length>0){
		// 				gapMessage+=", ";
		// 			}
		// 			gapMessage+=tuples_cellrow[j];
		// 		}			
		// 	}
		// 	if (added===1){
		// 		gapMessage = " (ellipsis gap of length "+gapMessage+")";
		// 	} else {
		// 		gapMessage = " (ellipsis gaps of length "+gapMessage+")";
		// 	}
		// }
		
		var logString = `<font color="green">Rule <a onclick="jumpToLine(${rule.lineNumber});"  href="javascript:void(0);">${rule.lineNumber}</a> ${ruleDirection} applied${gapMessage}.</font>`;
		consolePrint(logString,false,rule.lineNumber,inspect_ID);
		
	}

    return result;
};

Rule.prototype.tryApply = function(level) {
	perfCounters.rules++;
	const delta = level.delta_index(this.direction);

    //get all cellrow matches
    var matches = this.findMatches();
	perfCounters.matches += matches.length;
    if (matches.length===0) {
      return false;
    }
	perfCounters.matched++;

    var result=false;	
	if (this.hasReplacements) {
	perfCounters.replaces++;
	var tuples = generateTuples(matches);
	    for (var tupleIndex=0;tupleIndex<tuples.length;tupleIndex++) {
	        var tuple = tuples[tupleIndex];
	        var shouldCheck=tupleIndex>0;
	        var success = this.applyAt(level,tuple,shouldCheck,delta);
			if (success) perfCounters.replaced++;
	        result = success || result;
	    }
	}

    if (matches.length>0) {
      this.queueCommands();
    }
    return result;
};

Rule.prototype.queueCommands = function() {
	var commands = this.commands;
	perfCounters.commands += commands.length;	
	if (commands.length==0){
		return;
	}

	//commandQueue is an array of strings, message.commands is an array of array of strings (For messagetext parameter), so I search through them differently
	var preexisting_cancel=curLevel.commandQueue.indexOf("cancel")>=0;
	var preexisting_restart=curLevel.commandQueue.indexOf("restart")>=0;
	
	var currule_cancel = false;
	var currule_restart = false;
	for (var i=0;i<commands.length;i++){
		var cmd = commands[i][0];
		if (cmd==="cancel"){
			currule_cancel=true;
		} else if (cmd==="restart"){
			currule_restart=true;
		}
	}

	//priority cancel > restart > everything else
	//if cancel is the queue from other rules, ignore everything
	if (preexisting_cancel){
		return;
	}
	//if restart is in the queue from other rules, only apply if there's a cancel present here
	if (preexisting_restart && !currule_cancel){
		return;
	}

	//if you are writing a cancel or restart, clear the current queue
	if (currule_cancel || currule_restart){
		curLevel.commandQueue=[];
        curLevel.commandQueueSourceRules=[];
		messagetext="";
		statusText = "";
	}

	for(var i=0;i<commands.length;i++) {
		var command=commands[i];
		var already=false;
		if (command[0] == 'log') {		// log is not queued
			consolePrintFromRule(`${command[1]}`, this, true);
			continue;
		} else if (curLevel.commandQueue.indexOf(command[0])>=0) {
			continue;
		} else if (command[0] == 'gosub') {			// gosub is not queued
			gosubTarget = command[1];
			continue;
		}
		curLevel.commandQueue.push(command[0]);
		curLevel.commandQueueSourceRules.push(this);

		if (verbose_logging) {
			const logString = htmlColor('green', `Rule ${htmlJump(this.lineNumber)} triggers command ${command[0]}.`);
			consolePrint(logString, false, this.lineNumber, null);
		}

		if (command[0] == 'message') {
			messagetext=command[1];
		} else if (command[0] == 'goto') {
			gotoLevel(command[1]);
		} else if (command[0] == 'status') {
			statusText = command[1];
		} else if (command[0] == 'link') {
			gotoLink();
		}		

		if (state.metadata.runtime_metadata_twiddling && twiddleable_params.includes(command[0])) {

			value = command[1];

			if (value == "wipe") {
				delete state.metadata[command[0]]; //value = undefined;
				value = null;
			} else if (value == "default") {
				value = deepClone(state.default_metadata[command[0]]);
			}

			if (value != null) {
				state.metadata[command[0]] = value;
			}
			
			if (command[0] === "zoomscreen" || command[0] === "flickscreen") {
				twiddleMetaData(state, true);
				canvasResize();
			}

			if (command[0] === "smoothscreen") {
				if (value !== undefined) {
					twiddleMetaData(state, true);
					initSmoothCamera()
				} else {
					smoothscreen = false;
				}
				canvasResize();
			}

			twiddleMetadataExtras()

			if (state.metadata.runtime_metadata_twiddling_debug) {
				var log = "Metadata twiddled: Flag "+command[0] + " set to " + value;
				if (value != command[1]) {
					log += " ("+command[1]+")"
				}
				consolePrintFromRule(log,this,true);
			}
    	}   
  	}
};

// despite its name, this function exists to establish default values for prelude settings
function twiddleMetadataExtras(resetAutoTick = true) {
	autotickinterval=state.metadata.realtime_interval ? state.metadata.realtime_interval*1000 : 0;
	if (resetAutoTick || !state.metadata.realtime_interval)
    	autotick=0;
	againinterval = state.metadata.again_interval ? state.metadata.again_interval*1000 : 150;
	tweeninterval = state.metadata.tween_length ? Math.max(state.metadata.tween_length*1000, 0) : 0;
	repeatinterval = state.metadata.key_repeat_interval ? state.metadata.key_repeat_interval*1000 : 200; // was 150, makes for key bounce
	animateinterval = state.metadata.animate_interval ? state.metadata.animate_interval*1000 : 250; // was 150, makes for key bounce
	state.bgcolor = state.metadata.background_color ? colorToHex(colorPalette,state.metadata.background_color) : "#000000";
	state.fgcolor = state.metadata.text_color ? colorToHex(colorPalette,state.metadata.text_color) : "#FFFFFF";
}

function showTempMessage(message) {
if (solving) {return;}

	keybuffer=[];
	textMode=true;
	titleScreen=false;
	quittingMessageScreen=false;
	messageselected=false;
	ignoreNotJustPressedAction=true;
	tryPlayShowMessageSound();
	drawMessageScreen(message);
	canvasResize();
}

function processOutputCommands(commands) {
	for (var i=0;i<commands.length;i++) {
		var command = commands[i];
		if (command.charAt(1)==='f')  {//identifies sfxN
			tryPlaySimpleSound(command);
		}
		if (unitTesting===false) {
			if (command == 'message') {
				showTempMessage(messagetext);
			}
		}
	}
}

function applyRandomRuleGroup(level,ruleGroup) {
	perfCounters.randoms++;
	var propagated=false;

	var matches=[];
	for (var ruleIndex=0;ruleIndex<ruleGroup.length;ruleIndex++) {
		var rule=ruleGroup[ruleIndex];
		var ruleMatches = rule.findMatches();
		if (ruleMatches.length>0) {
	    	var tuples  = generateTuples(ruleMatches);
	    	for (var j=0;j<tuples.length;j++) {
	    		var tuple=tuples[j];
				matches.push([ruleIndex,tuple]);
	    	}
		}		
	}

  if (matches.length===0)
  {
    return false;
  } 

	var match = matches[Math.floor(RandomGen.uniform()*matches.length)];
	var ruleIndex=match[0];
	var rule=ruleGroup[ruleIndex];
	var tuple=match[1];
	var check=false;
	const delta = level.delta_index(rule.direction)
	var modified = rule.applyAt(level,tuple,check,delta);

    rule.queueCommands();

  return modified;
}


function applyRuleGroup(ruleGroup) {
	perfCounters.groups++;
	if (ruleGroup[0].isRandom) {
		return applyRandomRuleGroup(curLevel,ruleGroup);
	}

  	var loopPropagated=false;
    var propagated=true;
    var loopcount=0;
	var nothing_happened_counter = -1;
    while(propagated) {
		loopcount++;
		if (loopcount>200) {
			logErrorCacheable("Got caught looping lots in a rule group :O",ruleGroup[0].lineNumber,true);
			break;
		}
        propagated=false;

        for (var ruleIndex=0;ruleIndex<ruleGroup.length;ruleIndex++) {
            var rule = ruleGroup[ruleIndex];     
			if (rule.tryApply(curLevel)){
				if (!rule.isOnce)
					propagated=true;
				nothing_happened_counter=0;//why am I resetting to 1 rather than 0? because I've just verified that applications of the current rule are exhausted
			} else {
				nothing_happened_counter++;
			}
			if ( nothing_happened_counter === ruleGroup.length)
				break;
        }
        if (propagated) {
        	loopPropagated=true;
			
			if (verbose_logging){
				debugger_turnIndex++;
				addToDebugTimeline(curLevel,-2);//pre-movement-applied debug state
			}
        }
    }

    return loopPropagated;
}

function applyRules(rules, loopPoint, subroutines, startRuleGroupindex, bannedGroup){
	//console.log(`Apply rules rules:${rules.length} objects:${level.objects}`);
	perfCounters.tries++;
    //for each rule
    //try to match it

    playerPositions = getPlayerPositions();
	
	// stack of rule group index to return to at end of subroutine
	const gosubStack = []; // PS>

    //when we're going back in, let's loop, to be sure to be sure
    let loopPropagated = startRuleGroupindex > 0;
    let loopCount = 0;
    for (let ruleGroupIndex = startRuleGroupindex; ruleGroupIndex<rules.length; ) {
		// first process the rule and check for endloop
		if (bannedGroup && bannedGroup[ruleGroupIndex]) {
			//do nothing
		} else {
			const ruleGroup = rules[ruleGroupIndex];
			loopPropagated = applyRuleGroup(ruleGroup) || loopPropagated;
		}
		// loop ends right here
        if (loopPropagated && loopPoint[ruleGroupIndex] >= 0) { 
			if (checkLoop())
				break; 
		} else {
			if (gosubTarget >= 0) {
				gosubStack.push(ruleGroupIndex + 1);  // todo: push loop point
				ruleGroupIndex = gosubTarget;
				gosubTarget = -1;
				if (verbose_logging)
					consolePrint(`Gosub to line ${rules[ruleGroupIndex][0].lineNumber}`);
				//console.log(`gosub group:${ruleGroupIndex} line:${rules[ruleGroupIndex][0].lineNumber}`)
			} else {
				ruleGroupIndex++;
				// note special for loops and gosubs that end after the last rule
				if (ruleGroupIndex == rules.length && loopPropagated && loopPoint[ruleGroupIndex] >= 0) {
					if (checkLoop())
						break; 
				}		

				while (ruleGroupIndex == rules.length || subroutines.find(s => s.groupNumber == ruleGroupIndex)) {
					if (gosubStack.length > 0) {
						ruleGroupIndex = gosubStack.pop();
						if (verbose_logging)
							consolePrint(`Gosub return to line ${rules[ruleGroupIndex][0].lineNumber}`);
						//console.log(`return group:${ruleGroupIndex} line:${rules[ruleGroupIndex][0].lineNumber}`)
					} else {
						ruleGroupIndex = rules.length;	// force exit
						break;
					}
				} 
			}
		}

		if (verbose_logging){
			debugger_turnIndex++;
			addToDebugTimeline(curLevel,-2);//pre-movement-applied debug state
		}

		function checkLoop() {
			ruleGroupIndex = loopPoint[ruleGroupIndex];
			loopPropagated = false;
			loopCount++;
			if (loopCount > 200) {
				var ruleGroup = rules[ruleGroupIndex];
				logErrorCacheable("got caught in an endless startloop...endloop vortex, escaping!", ruleGroup[0].lineNumber, true);
				return true;
			}	
		}
	}
}

//if this returns!=null, need to go back and reprocess
function resolveMovements(level, bannedGroup){
	var moved=true;

    while(moved){
        moved=false;
        for (var i=0;i<level.n_tiles;i++) {
		  moved = repositionEntitiesAtCell(i) || moved;
        }
    }
    var doUndo=false;

	//Search for any rigidly-caused movements remaining
	for (var i=0;i<level.n_tiles;i++) {
		var cellMask = level.getCellInto(i,_o6);
		var movementMask = level.getMovements(i);
		if (!movementMask.iszero()) {
			var rigidMovementAppliedMask = level.rigidMovementAppliedMask[i];
			if (!rigidMovementAppliedMask.iszero()) {
				movementMask.iand(rigidMovementAppliedMask);
				if (!movementMask.iszero()) {
					//find what layer was restricted
					for (var j=0;j<level.layerCount;j++) {
						var layerSection = movementMask.getshiftor(MOV_MASK, MOV_BITS * j);
						if (layerSection!==0) {
							//this is our layer!
							var rigidGroupIndexMask = level.rigidGroupIndexMask[i];
							var rigidGroupIndex = rigidGroupIndexMask.getshiftor(MOV_MASK, MOV_BITS * j);
							rigidGroupIndex--;//group indices start at zero, but are incremented for storing in the bitfield
							var groupIndex = state.rigidGroupIndex_to_GroupIndex[rigidGroupIndex];
							if (bannedGroup[groupIndex]!==true){
								bannedGroup[groupIndex]=true
							//backtrackTarget = rigidBackups[rigidGroupIndex];
							doUndo=true;
							}
							break;
						}
					}
				}
			}
			// go through each of the fx masks to see if it applies to an object in this cell
			for (const fx of state.sfx_MovementFailureMasks) {
				if (cellMask.get(fx.objId)) {
					if (movementMask.anyBitsInCommon(fx.directionMask)) {
						const object = getObject(fx.objId);
						if (verbose_logging) 
							consolePrint(`Object "${state.idDict[object]}" can't move, playing seed "${seedsToPlay_CantMove[i]}"`)
						if (fx.seed.startsWith('afx')) {
							const move = getLayerMovement(movementMask, object.layer);
							seedsToAnimate[i+','+fx.objId] = { 
								kind: 'cant', 
								seed: fx.seed, 
								dir: move 
							};
						}
						else if (seedsToPlay_CantMove.indexOf(fx.seed)===-1)
							seedsToPlay_CantMove.push(fx.seed);
					}
				}
			}
    	}

    	for (var j=0;j<STRIDE_MOV;j++) {
    		level.movements[j+i*STRIDE_MOV]=0;
    	}
	    level.rigidGroupIndexMask[i].setZero();
	    level.rigidMovementAppliedMask[i].setZero();
    }
    return doUndo;
}

var sfxCreateMask=null;			// doc: mask for all objects created
var sfxDestroyMask=null;		// doc: mask for all objects destroyed
var sfxCreateList = []; 		// doc: list of created { posindex:, objmask: }
var sfxDestroyList = [];		// doc: list of destroyed { posindex:, objmask: }

function calculateRowColMasks() {
	for(var i=0;i<curLevel.mapCellContents.length;i++) {
		curLevel.mapCellContents[i]=0;
		curLevel.mapCellContents_Movements[i]=0;	
	}

	for (var i=0;i<curLevel.width;i++) {
		var ccc = curLevel.colCellContents[i];
		ccc.setZero();
		var ccc_Movements = curLevel.colCellContents_Movements[i];
		ccc_Movements.setZero();
	}

	for (var i=0;i<curLevel.height;i++) {
		var rcc = curLevel.rowCellContents[i];
		rcc.setZero();
		var rcc_Movements = curLevel.rowCellContents_Movements[i];
		rcc_Movements.setZero();
	}

	for (var i=0;i<curLevel.width;i++) {
		for (var j=0;j<curLevel.height;j++) {
			var index = j+i*curLevel.height;
			var cellContents=curLevel.getCellInto(index,_o9);
			curLevel.mapCellContents.ior(cellContents);
			curLevel.rowCellContents[j].ior(cellContents);
			curLevel.colCellContents[i].ior(cellContents);

			
			var mapCellContents_Movements=curLevel.getMovementsInto(index,_m1);
			curLevel.mapCellContents_Movements.ior(mapCellContents_Movements);
			curLevel.rowCellContents_Movements[j].ior(mapCellContents_Movements);
			curLevel.colCellContents_Movements[i].ior(mapCellContents_Movements);
		}
	}
}

var playerPositions;
var playerPositionsAtTurnStart;

// acceptable input directions, used here and in inputoutput
var dirNames = ['up', 'left', 'down', 'right', 'action', 'mouse', 'lclick', 'rclick'];  // todo: reaction, mclick

var perfCounters = {};

/* returns a bool indicating if anything changed */
function processInput(dir,dontDoWin,dontModify,bak,coord) {
	//console.log(`Process input (${dir},${dontDoWin},${dontModify},${bak},${coord}) cmds=${level.commandQueue}`)
	perfCounters = {
		start: Date.now(),
		rules: 0,
		matched: 0,
		matches: 0,
		replaces: 0,
		replaced: 0,
		commands: 0,
		randoms : 0,
		groups: 0,
		tries: 0,		
	}
	const ret = procInp(dir, dontDoWin, dontModify, bak, coord);
	perfCounters.elapsed = Date.now() - perfCounters.start;
	return ret;
}
function procInp(dir,dontDoWin,dontModify,bak,coord) {
	if (!dontModify) {
		newMovedEntities = {};
	}

	var startDir = dir;

	againing = false;

	if (bak==undefined) {
		bak = backupLevel();
	}
  
	// this looks dodgy, but playerPositions is not used and dir test always succeeds
  	playerPositions= [];
	playerPositionsAtTurnStart = getPlayerPositions();
	
	if (dir < dirNames.length) {

		if (verbose_logging) { 
			debugger_turnIndex++;
			addToDebugTimeline(curLevel,-2);//pre-movement-applied debug state
		}

		const dirName = dirNames[dir];

		// todo: reaction
		if ([ 0,1,2,3,4 ].includes(dir)) {		// arrows plus action go to player 
			playerPositions = startMovement(dirMasks[dirName]);
		} else if ([ 6,7 ].includes(dir)) {			// clicks go to object(s)
			const mask = curLevel.getCell(coord);
			moveEntitiesAtIndex(coord, mask, dirMasks[dirName]);
		}

		if (verbose_logging) { 
			const inspect_ID = addToDebugTimeline(curLevel, -1);
			if (dir===-1) {
				consolePrint(`Turn starts with no input.`, false, null, inspect_ID)
			} else {
				//  consolePrint('=======================');
				consolePrint(`Turn starts with input of ${dirName}.`, false, null, inspect_ID);
			}
			consolePrint('Applying rules.');
		}
		
        var bannedGroup = [];

        curLevel.commandQueue=[];
        curLevel.commandQueueSourceRules=[];
        var startRuleGroupIndex=0;
        var rigidloop=false;
		const startState = {
			objects: new Int32Array(curLevel.objects),
			movements: new Int32Array(curLevel.movements),
			rigidGroupIndexMask: curLevel.rigidGroupIndexMask.concat([]),
			rigidMovementAppliedMask: curLevel.rigidMovementAppliedMask.concat([]),
			commandQueue: [],
			commandQueueSourceRules: []
		}
	    sfxCreateMask.setZero();
	    sfxDestroyMask.setZero();
		sfxCreateList = [];
		sfxDestroyList = [];
		
		seedsToPlay_CanMove=[];
		seedsToPlay_CantMove=[];
		seedsToAnimate={};
		
		calculateRowColMasks();

		var alreadyResolved=[];
		statusText = "";

        var i=0;
        do {
        //not particularly elegant, but it'll do for now - should copy the world state and check
        //after each iteration
        	rigidloop=false;
        	i++;

			applyRules(state.rules, state.loopPoint, state.subroutines, startRuleGroupIndex, bannedGroup);
			var shouldUndo = resolveMovements(curLevel, bannedGroup);
			
        	if (shouldUndo) {
        		rigidloop=true;

				{
					// trackback
					if (IDE){
						// newBannedGroups is the list of keys of bannedGroup that aren't already in alreadyResolved
						var newBannedGroups = [];
						for (var key in bannedGroup) {
							if (!alreadyResolved.includes(key)) {
								newBannedGroups.push(key);
								alreadyResolved.push(key);
							}
						}
						var bannedLineNumbers = newBannedGroups.map( rgi => state.rules[rgi][0].lineNumber);
						var ts = bannedLineNumbers.length>1 ? "lines " : "line ";
						ts += bannedLineNumbers.map(ln => `<a onclick="jumpToLine(${ln});" href="javascript:void(0);">${ln}</a>`).join(", ");
						consolePrint(`Rigid movement application failed in rule-Group starting from ${ts}, and will be disabled in resimulation. Rolling back...`)
					}
					//don't need to concat or anythign here, once something is restored it won't be used again.
					curLevel.objects = new Int32Array(startState.objects)
					curLevel.movements = new Int32Array(startState.movements)
					curLevel.rigidGroupIndexMask = startState.rigidGroupIndexMask.concat([])
					curLevel.rigidMovementAppliedMask = startState.rigidMovementAppliedMask.concat([])
					// TODO: shouldn't we also save/restore the level data computed by level.calculateRowColMasks() ?
					curLevel.commandQueue = startState.commandQueue.concat([])
					curLevel.commandQueueSourceRules = startState.commandQueueSourceRules.concat([])
					sfxCreateMask.setZero()
					sfxDestroyMask.setZero()
					sfxCreateList = [];
					sfxDestroyList = [];

				}

				if (verbose_logging && rigidloop && i>0){				
					consolePrint('Relooping through rules because of rigid.');
						
					debugger_turnIndex++;
					addToDebugTimeline(curLevel,-2);//pre-movement-applied debug state
				}

        		startRuleGroupIndex=0;//rigidGroupUndoDat.ruleGroupIndex+1;
        	} else {
        		if (verbose_logging){

					var eof_idx = debug_visualisation_array[debugger_turnIndex].length+1;//just need some number greater than any rule group
					var inspect_ID = addToDebugTimeline(curLevel,eof_idx);

					consolePrint(`Processed movements.`,false,null,inspect_ID);
					
					if (state.lateRules.length>0){
											
						debugger_turnIndex++;
						addToDebugTimeline(curLevel,-2);//pre-movement-applied debug state
					
						consolePrint('Applying late rules.');
					}
				}
        		applyRules(state.lateRules, state.lateLoopPoint, state.subroutines, 0);
        		startRuleGroupIndex=0;
        	}
        } while (i < 250 && rigidloop);

        if (i>=250) {
          consolePrint("looped through 250 times, gave up. Too many loops!");
          
          applyRules(state.lateRules, state.lateLoopPoint, state.subroutines, 0);
          startRuleGroupIndex=0;
          
          backups.push(bak);
          DoUndo(true,false);
          return false;
        }

		/// Taken from zarawesome, thank you :)
		if (curLevel.commandQueue.indexOf('undo')>=0) {
			if (verbose_logging) {
				consoleCacheDump();
				consolePrint('UNDO command executed, undoing turn.',true);
			}
			messagetext = "";
			statusText = "";
			DoUndo(true,false, true, true, true);
			return true;
		}

        if (playerPositionsAtTurnStart.length>0 && state.metadata.require_player_movement!==undefined && dir >= 0) {
        	var somemoved=false;
        	for (var i=0;i<playerPositionsAtTurnStart.length;i++) {
        		var pos = playerPositionsAtTurnStart[i];
        		var val = curLevel.getCell(pos);
        		if (state.playerMask.bitsClearInArray(val.data)) {
        			somemoved=true;
        			break;
        		}
        	}
        	if (somemoved===false) {
        		if (verbose_logging){
	    			consolePrint('require_player_movement set, but no player movement detected, so cancelling turn.');
	    			consoleCacheDump();
				}
        		addUndoState(bak);
        		DoUndo(true,false, false);
        		return false;
        	}
        	//play player cantmove sounds here
        }



	    if (curLevel.commandQueue.indexOf('cancel')>=0) {
	    	if (verbose_logging) { 
	    		consoleCacheDump();
	    		var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('cancel')];
	    		consolePrintFromRule('CANCEL command executed, cancelling turn.',r,true);
			}

			if (!dontModify){
			processOutputCommands(curLevel.commandQueue);
			}

			var commandsleft = curLevel.commandQueue.length>1;

    		addUndoState(bak);
    		DoUndo(true,false, false, false);
    		tryPlayCancelSound();
    		return commandsleft;
	    } 

	    if (curLevel.commandQueue.indexOf('restart')>=0) {
			
    		if (verbose_logging && runrulesonlevelstart_phase){
				var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('restart')];
    			logWarning('A "restart" command is being triggered in the "run_rules_on_level_start" section of level creation, which would cause an infinite loop if it was actually triggered, but it\'s being ignored, so it\'s not.',r.lineNumber,true);
    		}

	    	if (verbose_logging) { 
	    		var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('restart')];
	    		consolePrintFromRule('RESTART command executed, reverting to restart state.',r.lineNumber);
	    		consoleCacheDump();
			}
			if (!dontModify){
				processOutputCommands(curLevel.commandQueue);
			}
    		addUndoState(bak);

			if (!dontModify){
	    		DoRestart(true);
			}
    		return true;
		}
		
		if (curLevel.commandQueue.indexOf('quit')>=0 && !solving) {
			if (verbose_logging) { 
				var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('quit')];
				consolePrintFromRule('QUIT command executed, exiting level.',r);
				consoleCacheDump();
			}
			if (state.metadata.level_select !== undefined) {
				gotoLevelSelectScreen();
			} else {
				goToTitleScreen();
			}
			messagetext = "";
			statusText = "";
			canvasResize();	
			return true;
		}

		var save_backup = true;
		if(!winning && curLevel.commandQueue.indexOf('nosave')>=0) {
			if (verbose_logging) { 
				var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('nosave')];
				consolePrintFromRule('NOSAVE command executed, not storing current state to undo queue.',r);
			}
			save_backup = false;
		}
	    
        var modified=false;
	    for (var i=0;i<curLevel.objects.length;i++) {
	    	if (curLevel.objects[i]!==bak.dat[i]) {
				if (dontModify) {
	        		if (verbose_logging) {
	        			consoleCacheDump();
	        		}
	        		addUndoState(bak);
	        		DoUndo(true,false, false);
					return true;
				} else {
					if (dir!==-1 && save_backup) {
						addUndoState(bak);
					} else if (backups.length > 0) {
						// This is for the case that diffs break the undo buffer for real-time games 
						// ( c f https://github.com/increpare/PuzzleScript/pull/796 ),
						// because realtime ticks are ignored when the user presses undo and the backup
						// array reflects this structure.  
						backups[backups.length - 1] = unconsolidateDiff(backups[backups.length - 1], bak);					
	    			}
	    			modified=true;
	    			updateCameraPositionTarget();
	    		}
	    		break;
	    	}
	    }

		if (dontModify && curLevel.commandQueue.indexOf('win')>=0) {	
	    	return true;	
		}
		
		if (dontModify) {		
    		if (verbose_logging) {
    			consoleCacheDump();
    		}
			return false;
		}

		// move completed, survived so far, look at sounds to play
		// move and cant were added during rule processing
        for (var i=0;i<seedsToPlay_CantMove.length;i++) {			
            playSeed(seedsToPlay_CantMove[i]);
        }

        for (var i=0;i<seedsToPlay_CanMove.length;i++) {
            playSeed(seedsToPlay_CanMove[i]);
        }

		// create and destroy were added ???
		for (const entry of state.sfx_CreationMasks) {
			if (sfxCreateMask.get(entry.objId)) {		// mask for objects created vs mask for sfx create event
				if (entry.seed.startsWith('afx')) {
					for (const fx of sfxCreateList) {
						if (fx.objId == entry.objId) {
							if (verbose_logging) consolePrint(`Created object "${state.idDict[entry.objId]}", playing seed "${entry.seed}"`);
							seedsToAnimate[fx.posIndex+','+fx.objId] = { kind: 'create', seed: entry.seed };
						}
					}
				} else {
					if (verbose_logging) consolePrint(`Created object "${state.idDict[entry.objId]}", playing seed "${entry.seed}"`);
					playSeed(entry.seed);
				}
			}
		}
  
		for (const entry of state.sfx_DestructionMasks) {
			if (sfxDestroyMask.get(entry.objId)) {
				if (entry.seed.startsWith('afx')) {
					for (const fx of sfxDestroyList) {
						if (fx.objId == entry.objId) {
							if (verbose_logging) consolePrint(`Destroyed object "${state.idDict[entry.objId]}", playing seed "${entry.seed}"`);
							seedsToAnimate[fx.posIndex+','+fx.objId] = { kind: 'destroy', seed: entry.seed };
						}
					}
				} else {
					if (verbose_logging) consolePrint(`Destroyed object "${state.idDict[entry.objId]}", playing seed "${entry.seed}"`);
					playSeed(entry.seed);
				}
			}
		}
  
		if (!dontModify){
	    	processOutputCommands(curLevel.commandQueue);
		}

	    if (textMode===false) {
	    	if (verbose_logging) { 
	    		consolePrint('Checking win conditions.');
			}
			if (dontDoWin===undefined){
				dontDoWin = false;
			}
	    	checkWin( dontDoWin );
	    }

	    if (!winning) {
			if (curLevel.commandQueue.indexOf('checkpoint')>=0) {
		    	if (verbose_logging) { 
	    			var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('checkpoint')];
		    		consolePrintFromRule('CHECKPOINT command executed, saving current state to the restart state.',r);
				}
				restartTarget=level4Serialization();
				hasUsedCheckpoint=true;
				var backupStr = JSON.stringify(restartTarget);
				storage_set(document.URL+'_checkpoint',backupStr);
				storage_set(document.URL,curLevelNo);				
			}	 

		    if (curLevel.commandQueue.indexOf('again')>=0 && modified) {

	    		var r = curLevel.commandQueueSourceRules[curLevel.commandQueue.indexOf('again')];

		    	//first have to verify that something's changed
		    	var old_verbose_logging=verbose_logging;
		    	var oldmessagetext = messagetext;
		    	verbose_logging=false;
		    	if (processInput(-1,true,true)) {
			    	verbose_logging=old_verbose_logging;

			    	if (verbose_logging) { 
			    		consolePrintFromRule('AGAIN command executed, with changes detected - will execute another turn.',r);
					}

			    	againing=true;
			    	timer=0;
			    } else {		    	
			    	verbose_logging=old_verbose_logging;
					if (verbose_logging) { 
						consolePrintFromRule('AGAIN command not executed, it wouldn\'t make any changes.',r);
					}
			    }
			    verbose_logging=old_verbose_logging;
			    messagetext = oldmessagetext;
		    }   
		}
		
		if (verbose_logging) { 
			consolePrint(`Turn complete.`);    
		}

		currentMovedEntities = newMovedEntities;
		tweentimer = 0;
		
	    curLevel.commandQueue=[];
	    curLevel.commandQueueSourceRules=[];
		if (debugSwitch.includes('anim')) console.log(`Animate: ${JSON.stringify(seedsToAnimate)}`);

    }

  if (verbose_logging) {
    consoleCacheDump();
  }

  if (winning) {
    againing=false;
  }

  return true; // might beneeded for an animation
  //return modified;
}

// play a seed which could be a sound or an animation
function playSeed(seed, ignore) {
	if (seed)
		playSound(seed, ignore);
	// else nothing yet

}

function checkWin(dontDoWin) {

  if (levelEditorOpened) {
    dontDoWin=true;
  }

	if (curLevel.commandQueue.indexOf('win')>=0) {
		if (runrulesonlevelstart_phase){
			consolePrint("Win Condition Satisfied (However this is in the run_rules_on_level_start rule pass, so I'm going to ignore it for you.  Why would you want to complete a level before it's already started?!)");		
		} else {
			if (verbose_logging && !solving) {
				consolePrint("Win Condition Satisfied.");
			}
		}
		if(!dontDoWin){
			DoWin();
		}
		return;
	}

	var won= false;
	if (state.winconditions.length>0)  {
		var passed=true;
		for (var wcIndex=0;wcIndex<state.winconditions.length;wcIndex++) {
			var wincondition = state.winconditions[wcIndex];
			var filter1 = wincondition[1];
			var filter2 = wincondition[2];
			var aggr1 = wincondition[4];
			var aggr2 = wincondition[5];

			var rulePassed=true;
			
			const f1 = aggr1 ? c=>filter1.bitsSetInArray(c) : c=>!filter1.bitsClearInArray(c);
			const f2 = aggr2 ? c=>filter2.bitsSetInArray(c) : c=>!filter2.bitsClearInArray(c);

			switch(wincondition[0]) {
				case -1://NO
				{
					for (var i=0;i<curLevel.n_tiles;i++) {
						var cell = curLevel.getCellInto(i,_o10);
						if ( (f1(cell.data)) &&  
							 (f2(cell.data)) ) {
							rulePassed=false;
							break;
						}
					}

          break;
        }
        case 0://SOME
        {
          var passedTest=false;
          for (var i=0;i<curLevel.n_tiles;i++) {
            var cell = curLevel.getCellInto(i,_o10);
						if ( (f1(cell.data)) &&  
							 (f2(cell.data)) ) {
              passedTest=true;
              break;
            }
          }
          if (passedTest===false) {
            rulePassed=false;
          }
          break;
        }
        case 1://ALL
        {
          for (var i=0;i<curLevel.n_tiles;i++) {
            var cell = curLevel.getCellInto(i,_o10);
						if ( (f1(cell.data)) &&  
							 (!f2(cell.data)) ) {
              rulePassed=false;
              break;
            }
          }
          break;
        }
      }
      if (rulePassed===false) {
        passed=false;
      }
    }
    won=passed;
  }

	if (won) {
		if (runrulesonlevelstart_phase){
			consolePrint("Win Condition Satisfied (However this is in the run_rules_on_level_start rule pass, so I'm going to ignore it for you.  Why would you want to complete a level before it's already started?!)");		
		} else {
			if (verbose_logging && !solving) {
				consolePrint("Win Condition Satisfied.");
			}
		}
		if (!dontDoWin){
			DoWin();
		}
	}
}

function DoWin() {
	if (winning) {
		return;
	}
	againing = false;
	tryPlayEndLevelSound();

	if (linkStack.length > 0) { 		// got here by link so go back there
		returnLink();
		processInput(-1, true);			// allow trigger on rules with no movement
		return;
	}

	if (unitTesting) {
		nextLevel();
		return;
	}

	winning = true;
	timer = 0;
}

function nextLevel() {
	if (debugSwitch.includes('load')) console.log(`nextLevel()`, `curLevelNo=${curLevelNo}`);
	againing=false;
	messagetext="";
	statusText = "";
	if (state && state.levels && (curLevelNo>state.levels.length) ){
		curLevelNo=state.levels.length-1;
	}
  
  	ignoreNotJustPressedAction=true;
	if (titleScreen && titleMode <= 1) {
		linkStack = [];
		backups = [];
		if(isContinueOptionSelected()) {
			// continue
			loadLevelFromStateOrTarget();
		} else if(isNewGameOptionSelected()) {
			// new game
			curLevelNo=0;
			curlevelTarget=null;

			if (state.metadata.level_select === undefined) {
				clearLocalStorage();		//@@???
			}

			loadLevelFromStateOrTarget();
		} else if(isLevelSelectOptionSelected()) {
			// level select
			titleSelection = 0;
			gotoLevelSelectScreen();
		} else {
			throw "next level";
			// settings
			// TODO
		}
	} else {
		if (hasUsedCheckpoint){
			curlevelTarget=null;
			hasUsedCheckpoint=false;
		}

		if (curLevelNo<(state.levels.length-1)) {
			var skip = false;
			var curSection = state.levels[Number(curLevelNo)].section;
			var nextSection = state.levels[Number(curLevelNo)+1].section;
			if(nextSection != curSection) {
				setSectionSolved(state.levels[Number(curLevelNo)].section);
				
				if(solvedSections.length == state.sections.length && state.winSection != undefined) {
					curLevelNo = state.winSection.firstLevel - 1; // it's gonna be increased to match few lines below
				} else if (nextSection == "__WIN__") {
					gotoLevelSelectScreen();
					skip = true;
				}		
			}

			if(!skip) {
				curLevelNo++;
				curlevelTarget=null;
				textMode=false;
				titleScreen=false;
				quittingMessageScreen=false;
	
				loadLevelFromStateOrTarget();
			}
		} else {
			if (solvedSections.length == state.sections.length) {
				if (state.metadata["level_select"] === undefined) {
					// solved all
					try {
						storage_remove(document.URL);
						storage_remove(document.URL + '_checkpoint');
					} catch (ex) {
					}

					curLevelNo = 0;
					curlevelTarget = null;
					goToTitleScreen();
				} else {
					goToTitleScreen();
				}

				tryPlayEndGameSound();
			} else {
				if (state.levels[Number(curLevelNo)].section != null) {
					setSectionSolved(state.levels[Number(curLevelNo)].section);
				}
				gotoLevelSelectScreen();
			}
		}		
		//continue existing game
	}

	updateLocalStorage();
	resetFlickDat();
	canvasResize();	
}

function loadLevelFromStateOrTarget() {
	if (curlevelTarget!==null){			
		loadLevelFromStateTarget(state,curLevelNo,curlevelTarget);
	} else {
		loadLevelFromState(state,curLevelNo);
	}
}

function goToTitleScreen(){
	if (debugSwitch.includes('load')) console.log(`gotoTitleScreen()`);
    againing=false;
	messagetext="";
	statusText = "";
	titleScreen=true;
	textMode=true;
	hoverSelection=-1;
	doSetupTitleScreenLevelContinue();
  //titleSelection=showContinueOptionOnTitleScreen()?1:0;
  
  	state.metadata = deepClone(state.default_metadata);
  	twiddleMetadataExtras();

  	if (canvas!==null){//otherwise triggers error in cat bastard test
		regenSpriteImages();
	}
	
	levelSelectScrollPos = 0;
	generateTitleScreen();
}

function resetFlickDat() {
	if (state!==undefined && state.metadata.flickscreen!==undefined){
		oldflickscreendat=[0,0,Math.min(state.metadata.flickscreen[0],curLevel.width),Math.min(state.metadata.flickscreen[1],curLevel.height)];
	}
}

function updateLocalStorage() {
	if (linkStack.length > 0)
		return;
	try {
		
		storage_set(document.URL,curLevelNo);
		if (curlevelTarget!==null){
			restartTarget=level4Serialization();
			var backupStr = JSON.stringify(restartTarget);
			storage_set(document.URL+'_checkpoint',backupStr);
		} else {
			storage_remove(document.URL+"_checkpoint");
		}		
		
	} catch (ex) {
  }
}

function setSectionSolved(section) {
	if(section == null || section == undefined) {
		return;
	}

	if(section.name == "__WIN__") {
		return;
	}

	if(solvedSections.indexOf(section) >= 0) {
		return;
	}

	try {
		if(!!window.localStorage) {
			solvedSections.push(section);
			storage_set(document.URL + "_sections", JSON.stringify(solvedSections));
		}
	} catch(ex) { }
}

function clearLocalStorage() {
	curLevelNo = 0;
	curlevelTarget = null;
	solvedSections = [];

	try {
		if (!!window.localStorage) {
			storage_remove(document.URL);
			storage_remove(document.URL+'_checkpoint');
			storage_remove(document.URL+'_sections');
		}
	} catch(ex){ }
}

var cameraPositionTarget = null;

var cameraPosition = {
  x: 0,
  y: 0
};

function initSmoothCamera() {
    if (state===undefined || state.metadata.smoothscreen===undefined) {
        return;
    }

    screenwidth=state.metadata.smoothscreen.screenSize.width;
    screenheight=state.metadata.smoothscreen.screenSize.height;

    var boundarySize = state.metadata.smoothscreen.boundarySize;
    var flick = state.metadata.smoothscreen.flick;

    var playerPositions = getPlayerPositions();
    if (playerPositions.length>0) {
        var playerPosition = {
            x: (playerPositions[0]/(curLevel.height))|0,
            y: (playerPositions[0]%curLevel.height)|0
        };

        cameraPositionTarget = {
            x: flick
              ? getFlickCameraPosition(playerPosition.x, curLevel.width, screenwidth, boundarySize.width)
              : getCameraPosition(playerPosition.x, curLevel.width, screenwidth),
            y: flick
              ? getFlickCameraPosition(playerPosition.y, curLevel.height, screenheight, boundarySize.height)
              : getCameraPosition(playerPosition.y, curLevel.height, screenheight)
        };

        cameraPosition.x = cameraPositionTarget.x;
        cameraPosition.y = cameraPositionTarget.y;
    }
}

function getCameraPosition (targetPosition, levelDimension, screenDimension) {
    return Math.min(
        Math.max(targetPosition, Math.floor(screenDimension / 2)),
        levelDimension - Math.ceil(screenDimension / 2)
    );
}

function getFlickCameraPosition (targetPosition, levelDimension, screenDimension, boundaryDimension) {
    var flickGridOffset = (Math.floor(screenDimension / 2) - Math.floor(boundaryDimension / 2));
    var flickGridPlayerPosition = targetPosition - flickGridOffset;
    var flickGridPlayerCell = Math.floor(flickGridPlayerPosition / boundaryDimension);
    var maxFlickGridCell = Math.floor((levelDimension - Math.ceil(screenDimension / 2) - Math.floor(boundaryDimension / 2) - flickGridOffset) / boundaryDimension);

    return Math.min(Math.max(flickGridPlayerCell, 0), maxFlickGridCell) * boundaryDimension + Math.floor(screenDimension / 2);
}

function updateCameraPositionTarget() {
    var smoothscreenConfig = state.metadata.smoothscreen;
    var playerPositions = getPlayerPositions();

    if (!smoothscreenConfig || playerPositions.length === 0) {
        return
    }

    var playerPosition = {
        x: (playerPositions[0]/(curLevel.height))|0,
        y: (playerPositions[0]%curLevel.height)|0
    };

    ['x', 'y'].forEach(function (coord) {
        var screenDimension = coord === 'x' ? screenwidth : screenheight;

        var dimensionName = coord === 'x' ? 'width' : 'height';
        var levelDimension = curLevel[dimensionName];
        var boundaryDimension = smoothscreenConfig.boundarySize[dimensionName];

        var playerVector = playerPosition[coord] - cameraPositionTarget[coord];
        var direction = Math.sign(playerVector);
        var boundaryVector = direction > 0
          ? Math.ceil(boundaryDimension / 2)
          : -(Math.floor(boundaryDimension / 2) + 1);

        if (Math.abs(playerVector) - Math.abs(boundaryVector) >= 0) {
            cameraPositionTarget[coord] = smoothscreenConfig.flick
              ? getFlickCameraPosition(playerPosition[coord], levelDimension, screenDimension, boundaryDimension)
              : getCameraPosition(playerPosition[coord] - boundaryVector + direction, levelDimension, screenDimension);
        }
    })
}


function IsMouseGameInputEnabled() {
	return state.metadata.mouse_left || state.metadata.mouse_up || state.metadata.mouse_drag || state.metadata.mouse_clicks;
}
</script>
<script>
/*
Credits

Brunt of the work by increpare (www.increpare.com), with many contributions by others over the years

This code comes from the PuzzleScriptPlus fork, with major features added by Auroriax, gathered from forks by many others.

This version is PuzzleScriptNext, by Davidus of Polyomino Games.

Color values for named colours from arne, mostly (and a couple from a 32-colour palette attributed to him)
http://androidarts.com/palette/16pal.htm

The editor is a slight modification of codemirror (codemirror.net), which is crazy awesome.
Testing is based on Qunit

For more information see:
    github.com/increpare/PuzzleScript
    github.com/Auroriax/PuzzleScriptNext
    github.com/david-pfx/PuzzleScriptNext

*/

const MAX_ERRORS_FOR_REAL=100;

let compiling = false;
let errorStrings = [];      //also stores warning strings
let errorCount = 0;         //only counts errors
let caseSensitive = false;

// used here and in compiler
const reg_commandwords = /^(afx[\w:=+-.]+|sfx\d+|cancel|checkpoint|restart|win|message|again|undo|nosave|quit|zoomscreen|flickscreen|smoothscreen|again_interval|realtime_interval|key_repeat_interval|noundo|norestart|background_color|text_color|goto|message_text_align|status|gosub|link|log)$/u;
const reg_objectname = /^[\p{L}\p{N}_$]+(:[<>v^]|:[\p{L}\p{N}_$]+)*$/u; // accepted by parser subject to later expansion
const reg_objmodi = /^(canvas|copy|flip|rot|scale|shift|text|translate):/i;

const commandwords_table = ['cancel', 'checkpoint', 'restart', 'win', 'message', 'again', 'undo', 'nosave', 'quit', 'zoomscreen', 'flickscreen', 'smoothscreen', 
    'again_interval', 'realtime_interval', 'key_repeat_interval', 'noundo', 'norestart', 'background_color', 'text_color', 'goto', 'message_text_align', 'status', 'gosub'];
const commandargs_table = ['message', 'goto', 'status', 'gosub', 'log'];
const twiddleable_params = ['background_color', 'text_color', 'key_repeat_interval', 'realtime_interval', 'again_interval', 'flickscreen', 'zoomscreen', 'smoothscreen', 'noundo', 'norestart', 'message_text_align'];
const soundverbs_directional = ['move', 'cantmove'];
const soundverbs_other = [ 'create', 'destroy' ];
let soundverbs_movement = [ 'action' ];  // clicks to be added
let directions_table = ['action', 'up', 'down', 'left', 'right', '^', 'v', '<', '>', 
    'moving', 'stationary', 'parallel', 'perpendicular', 'horizontal', 'orthogonal', 'vertical', 'no', 'randomdir', 'random'];
let directions_only = ['>', '\<', '\^', 'v', 'up', 'down', 'left', 'right', 'action', 'moving', 
    'stationary', 'no', 'randomdir', 'random', 'horizontal', 'vertical', 'orthogonal', 'perpendicular', 'parallel'];
const mouse_clicks_table = ['lclick', 'rclick']; // gets appended

const clockwiseDirections = ['up', 'right', 'down', 'left', '^', '>', 'v', '<' ];

const cwdIndexOf = dir => clockwiseDirections.indexOf(dir) % 4;

function TooManyErrors(){
    consolePrint("Too many errors/warnings; aborting compilation.",true);
    throw new Error("Too many errors/warnings; aborting compilation.");
}

function htmlJump(lineNumber, clss) {	
	return clss ? htmlClass(clss, htmlJump(lineNumber)) 
        : `<a onclick="jumpToLine(${lineNumber});"  href="javascript:void(0);">${lineNumber}</a>`;
}

function htmlColor(color, text) {
	return `<font color="${color}">${text}</font>`;
}

function htmlClass(clss, text) {
	return `<span class="${clss}">${text}</span>`;
}

function errorCase(ident) {
    return caseSensitive ? ident : ident ? ident.toUpperCase() : '<null>';
}

function logErrorCacheable(str, lineNumber,urgent) {
    if (compiling||urgent) {
        if (lineNumber === undefined) {
            return logErrorNoLine(str,urgent);
        }
        var errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="errorText">' + str + '</span>';
         if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
         } else {
            consolePrint(errorString);
            errorStrings.push(errorString);
            errorCount++;
			if (errorStrings.length>MAX_ERRORS_FOR_REAL){
                TooManyErrors();
        }
    }
    }
}

function logError(str, lineNumber,urgent) {
    if (compiling||urgent) {
        if (lineNumber === undefined) {
            return logErrorNoLine(str,urgent);
        }
        var errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="errorText">' + str + '</span>';
         if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
         } else {
            consolePrint(errorString,true);
            errorStrings.push(errorString);
            errorCount++;
			if (errorStrings.length>MAX_ERRORS_FOR_REAL){
                TooManyErrors();
        }
    }
    }
}

function logWarning(str, lineNumber, urgent) {
    if (compiling||urgent) {
        if (lineNumber === undefined) {
            return logWarningNoLine(str,urgent);
        }
        var errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="warningText">' + str + '</span>';
         if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
         } else {
            consolePrint(errorString,true);
            errorStrings.push(errorString);
			if (errorStrings.length>MAX_ERRORS_FOR_REAL){
                TooManyErrors();
        }
    }
    }
}

function logWarningNoLine(str, urgent, increaseErrorCount = false) {
    if (compiling||urgent) {
        var errorString = '<span class="warningText">' + str + '</span>';
         if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
         } else {
            consolePrint(errorString,true);
            errorStrings.push(errorString);
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
        }
        }
        if (increaseErrorCount) {
            errorCount++;
        }
    }
}

function logErrorNoLine(str,urgent) {
    if (compiling||urgent) {
        var errorString = '<span class="errorText">' + str + '</span>';
         if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
         } else {
            consolePrint(errorString,true);
            errorStrings.push(errorString);
        errorCount++;
			if (errorStrings.length>MAX_ERRORS_FOR_REAL){
                TooManyErrors();
    }
        }
    }
}

//for IE support
if (typeof Object.assign != 'function') {
  (function () {
    Object.assign = function (target) {
      'use strict';
      // We must check against these specific cases.
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
 
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  })();
}


var codeMirrorFn = function() {
    'use strict';

    const sectionNames = ['objects', 'legend', 'sounds', 'collisionlayers', 'rules', 'winconditions', 'tags', 'mappings', 'levels'];
    const reg_equalsrow = /[\=]+/;
    const reg_soundevents = /^(sfx\d+|undo|restart|titlescreen|startgame|cancel|endgame|startlevel|endlevel|showmessage|closemessage|pausescreen)\b/i;

    const reg_loopmarker = /^(startloop|endloop)$/;
    const reg_ruledirectionindicators = /^(up|down|left|right|horizontal|vertical|orthogonal|late|rigid)$/;
    const reg_sounddirectionindicators = /^(up|down|left|right|horizontal|vertical|orthogonal)\b/i;

    const keyword_array = [ 'checkpoint', 'objects', 'collisionlayers', 'legend', 'sounds', 'rules', 'winconditions', 'levels',
        '|', '[', ']', 'up', 'down', 'left', 'right', 'late', 'rigid', '^', 'v', '>', '<', 'no', 'randomdir', 'random', 'horizontal', 'vertical',
        'any', 'all', 'no', 'some', 'moving', 'stationary', 'parallel', 'perpendicular', 'action', 'message', 'move', 
        'create', 'destroy', 'cantmove', 'sfx0', 'sfx1', 'sfx2', 'sfx3', 'Sfx4', 'sfx5', 'sfx6', 'sfx7', 'sfx8', 'sfx9', 'sfx10', 
        'cancel', 'checkpoint', 'restart', 'win', 'message', 'again', 'undo', 'restart', 'titlescreen', 'startgame', 'cancel', 'endgame', 
        'startlevel', 'endlevel', 'showmessage', 'closemessage' ];
    const prelude_keywords = ['allow_undo_level', 'auto_level_titles', 'case_sensitive', 'continue_is_level_select', 'debug', 'level_select', 'level_select_lock', 
        'mouse_clicks', 'noaction', 'nokeyboard', 'norepeat_action', 'norestart', 'noundo', 'require_player_movement', 
        'run_rules_on_level_start', 'runtime_metadata_twiddling', 'runtime_metadata_twiddling_debug', 'scanline', 
        'skip_title_screen', 'smoothscreen_debug', 'status_line', 'throttle_movement', 'verbose_logging'];
    const prelude_param_text = ['title', 'author', 'homepage', 'custom_font', 'text_controls', 'text_message_continue', 'debug_switch'];
    const prelude_param_number = ['again_interval', 'animate_interval', 'font_size', 'key_repeat_interval', 
        'level_select_unlocked_ahead', 'level_select_unlocked_rollover', 'local_radius', 'realtime_interval', 
        'tween_length', 'tween_snap'];
    const prelude_param_single = [
        'background_color', 'color_palette', 'flickscreen', 'level_select_solve_symbol', 'keyhint_color', 
        'message_text_align', 'mouse_drag', 'mouse_left', 'mouse_rdrag', 'mouse_right', 'mouse_rup', 'mouse_up',
        'sitelock_hostname_whitelist', 'sitelock_origin_whitelist', 'sprite_size', 'text_color', 'tween_easing', 'zoomscreen',
        'author_color', 'title_color'
    ];
    const prelude_not_implemented = [
        'game_uri', 'level_title_style', 'show_level_title_in_menu', 
    ];
    const prelude_param_multi = ['smoothscreen', 'puzzlescript', 'youtube' ];
    const prelude_tables = [prelude_keywords, prelude_param_text, prelude_param_number, 
        prelude_param_single, prelude_param_multi];
    const color_names = ['black', 'white', 'darkgray', 'lightgray', 'gray', 'grey', 'darkgrey', 'lightgrey',
        'red', 'darkred', 'lightred', 'brown', 'darkbrown', 'lightbrown', 'orange', 'yellow', 'green', 'darkgreen',
        'lightgreen', 'blue', 'lightblue', 'darkblue', 'purple', 'pink', 'transparent'];

    // updated for // comment style
    let reg_notcommentstart = /[^\(]+/;

    // utility functions used by parser

    function hasParts(ident) {
        return ident.split(':').length > 1;
    }

    // recursively expand an object symbol into its ultimate constituents of base objects
    // callback to handle error
    function expandSymbol(state, name, isand, cbError) {
        if (name in state.objects) 
            return [name];
        for (const sym of state.legend_synonyms)
            if (sym[0] == name) 
                return expandSymbol(state, sym[1], isand);
        for (const sym of state.legend_aggregates) {
            if (sym[0] == name) {
                if (!isand)
                    cbError(name);
                return sym.slice(1).flatMap(s => expandSymbol(state, s, false));
            }
        }
        for (const sym of state.legend_properties) {
            if (sym[0] == name) {
                if (isand)
                    cbError(name);
                return sym.slice(1).flatMap(s => expandSymbol(state, s, true));
            }
        }
        logError(`Cannot expand symbol "${errorCase(name)}"`, state.lineNumber);
        return [name];
    }

    function registerOriginalCaseName(state,candname,mixedCase,lineNumber){
        function escapeRegExp(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }

        const nameFinder = state.case_sensitive 
            ? new RegExp("\\b" + escapeRegExp(candname) + "\\b")
            : new RegExp("\\b" + escapeRegExp(candname) + "\\b", "i");
        var match = mixedCase.match(nameFinder);
        if (match!=null){
            state.original_case_names[candname] = match[0];
            state.original_line_numbers[candname] = lineNumber;
        }
    }

    function createAlias(state, alias, candname, lineno) {
        if (debugSwitch.includes('alias')) console.log(`Create '${alias}' as alias for '${candname}'`);
        const synonym = [alias, candname];
        synonym.lineNumber = lineno;
        state.legend_synonyms.push(synonym);
    }

    //----- lexer functions -----

    // class Lexer
    class Lexer {
        tokens = [];

        constructor(stream, state) {
            this.stream = stream;
            this.state = state;
        }

        pushToken(token, kind) {
            this.tokens.push({ 
                text: token, 
                kind: kind, 
                pos: this.stream.pos 
            });
            this.matchPos = this.stream.pos;
        }

        pushTokens(tokens) {
            this.tokens.push(tokens);
        }

        get tokens() {
            return this.tokens;
        }

        pushBack() {
            this.stream.pos = this.matchPos;
        }

        check(regex) {
            const token = this.stream.match(regex, false);
            return !token ? null : token[0];
        }

        matchComment() {
            while (true) {
                const token = matchComment(this.stream, this.state);
                if (token)
                    this.pushToken(token, 'comment');
                else break;
            }
        }
        
        matchEol() { 
            this.matchComment();
            return this.stream.eol(); 
        }

        matchEolSemi() { 
            this.matchComment();
            if (this.state.commentStyle == '//' && this.match(/^;/)) {
                this.pushToken(';', 'SEMICOLON');
                return true;
            }
            return this.stream.eol(); 
        }

        next() {
            return this.stream.next();
        }

        peek() {
            return this.stream.peek();
        }

        match(regex, tolower = false) {
            this.matchPos = this.stream.pos;
            const token = this.stream.match(regex);
            if (token) this.stream.eatSpace();
            return !token ? null : tolower ? token[0].toLowerCase() : token[0];
        }

        matchAll() {
            // bug: Trailing whitespace may interact badly with stream eol/bol?
            return (this.match(/.*/) || '').trim();
        }
        
        matchNotComment() {
            return (this.match(reg_notcommentstart) || '').trim();
        }

        matchToken(tolower) {
            return this.match(/^\S+/, tolower);
        }
    
        matchName(tolower) {
            return this.match(/^[\p{L}\p{N}_$]+/u, tolower);
        }
    
        matchObjectName(tolower) {
            return this.match(/^[\p{L}\p{N}_$]+(:[\p{L}\p{N}_$]+)*/u, tolower);
        }
    
        matchObjectGlyph(tolower) {
            return this.match(/^\S/, tolower);
        }
    }

    // match by regex, eat white space, optional return tolower, with pushback
    let matchPos = 0;
    function matchRegex(stream, regex, tolower) {
        matchPos = stream.pos;
        const match = stream.match(regex);
        if (match) stream.eatSpace();
        return !match ? null : tolower ? match[0].toLowerCase() : match[0];
    }
    
    function pushBack(stream) {
        stream.pos = matchPos;
    }

    ////////////////////////////////////////////////////////////////////////////
    // return any kind of comment if found, or null if not
    // updates eol and commentLevel
    function matchComment(stream, state) {
        stream.match(/\s*/);
        if (stream.eol()) 
            return (state.commentLevel > 0) ? '' : null;
        // set comment style if first time
        if (!state.commentStyle && stream.match(/^(\/\/)|\(/, false)) {
            if (stream.match(/^\//, false)) {
                state.commentStyle = '//';
                reg_notcommentstart = /(.(?!\/\/))+|[^\(]+/;
            } else {
                state.commentStyle = '()';
            }
        }
        // handle // comments
        if (state.commentStyle == '//'){
            if (stream.match('//', false))
                return stream.match(/.*/)[0];
                    }
        // handle () comments
        if (state.commentLevel == 0 && stream.peek() != '(')
            return null;
        const pos = stream.pos;
        do {
            stream.match(/[^\(\)]*/);
            if (stream.eol())
                break;
            if (stream.match('('))
                state.commentLevel++;
            else if (stream.match(')'))
                state.commentLevel--;
        } while (state.commentLevel > 0);
        stream.eatSpace();
        return stream.string.slice(pos, stream.pos);
    }

    function checkEol(stream, state) { 
        const pos = stream.pos;
        matchComment(stream, state);
        const iseol = stream.eol();
        stream.pos = pos;
        return iseol;
    }

    function blankLineHandle(state) {
        if (state.section == 'levels') {
            const toplevel = state.levels.at(-1);
            if (toplevel && toplevel.length > 0)
                state.levels.push([]);
        } else if (state.section == 'objects') {
            expandLastObject(state);
            state.objects_section = 0;
        }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // parse a SECTION line, validate order etc
    function parseSection(stream, state) {
        const section = matchRegex(stream, /^\w+/, true);

        // section must the only thing on the line, helps with backward compatibility
        if (!(section && sectionNames.includes(section) && checkEol(stream, state))) {
            pushBack(stream);
            return false;
        }
        matchComment(stream, state);

        // finalise previous section
        if (state.section === '') {
            state.commentStyle ||= '()';
        } else if (state.section === 'objects') {
            expandLastObject(state);
        } else if (state.section === 'legend') {
            state.names = [];
            state.names.push(...Object.keys(state.objects));
            state.names.push(...state.legend_synonyms.map(s => s[0]));
            state.names.push(...state.legend_aggregates.map(s => s[0]));
            state.names.push(...state.legend_properties.map(s => s[0]));
        } else if (section === 'levels') {
            state.abbrevNames = [];
            state.abbrevNames.push(...Object.keys(state.objects));
            state.abbrevNames.push(...state.legend_synonyms.map(s => s[0]));
            state.abbrevNames.push(...state.legend_aggregates.map(s => s[0]));
        }

        state.section = section;
        state.line_should_end = true;
        state.line_should_end_because = `a section name ("${state.section.toUpperCase()}")`;
        state.visitedSections.push(state.section);
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse a PRELUDE line, extract parsed information, return array of tokens
    // also updates state.metadata
    function parsePrelude(stream, state) {
        const lexer = new Lexer(stream, state);
        let value = null;
        
        if (value = getTokens()) 
            setState(state, value);
        return lexer.tokens;

        // extract and validate tokens
        function getTokens() {
            let token, ident;
            let kind = 'ERROR';
            const args = [];
            if (token = lexer.match(/^[a-z_]+/i, true)) {
                if (state.metadata_lines[ident]) {
                    var otherline = state.metadata_lines[token];
                    logWarning(`You've already defined a "${errorCase(token)}" in the prelude on line ${htmlJump(otherline)}.`, state.lineNumber);
                } else if (prelude_not_implemented.includes(token)) {
                    logWarning(`Option ${errorCase(token)} is not implemented, but may be in the future. Let me know if you really need it.`,state.lineNumber);
                } else if (prelude_param_text.includes(token)) {
                    ident = token;
                    lexer.pushToken(token, 'METADATA');
                    token = lexer.matchAll();
                    lexer.pushToken(token, 'METADATATEXT');
                    args.push(token);
                } else if (prelude_tables.some(t => t.includes(token))) {
                    ident = token;
                    lexer.pushToken(token, 'METADATA');

                    while (!lexer.matchEol()) {
                        if (token = lexer.match(/^\S+/, true)) {
                            kind = (token in colorPalettes.arnecolors) ? 'COLOR COLOR-' + errorCase(token)
                                : (token === "transparent") ? 'COLOR FADECOLOR'
                                : token.match(/^#[0-9a-fA-F]+$/) ? 'MULTICOLOR' + token
                                : 'METADATATEXT';
                            lexer.pushToken(token, kind);
                            args.push(token);
                        } else break;
                    }
                } else logWarning(`Prelude option "${errorCase(token)}" is not one I know, so I'm going to ignore it. Hope that works for you.`, state.lineNumber);
            } 
            if (ident) {
                if (lexer.matchEol()) 
                    return checkArguments(ident, args);
                else {
                    token = lexer.matchNotComment();
                    logError(`Unrecognised stuff in the prelude: "${errorCase(token)}".`, state.lineNumber);
                }
            } else {
                lexer.pushToken(token, 'ERROR');
                token = lexer.matchNotComment();
                lexer.pushToken(token, 'ERROR');
            }
        }

        function checkArguments(ident, args) {
            state.metadata_lines[ident] = state.lineNumber;                                                                                    
            let value
            if (prelude_keywords.includes(ident)) {
                if (args.length > 1)
                    logError(`Prelude option "${errorCase(ident)}" doesn't take any parameters, but you went and gave it "${args.join()}".`, state.lineNumber);
                else value = [ident, true];
            } else if (prelude_param_number.includes(ident)) {
                if (args.length != 1 || parseFloat(args[0]) == NaN)
                    logError(`Prelude option "${errorCase(ident)}" requires one numeric argument.`, state.lineNumber);
                else value = [ident, parseFloat(args[0])];
            } else if (prelude_param_single.includes(ident) || prelude_param_text.includes(ident)) {
                if (!(args.length == 1 || ident.startsWith('mouse')))
                    logError(`Prelude option "${errorCase(ident)}" requires exactly one argument, but you gave it ${args.length}.`, state.lineNumber);
                else if (ident.includes('_color') && !isColor(args[0]))
                    logError(`Prelude option "${errorCase(ident)}" in incorrect format - found ${args[0]}, but I expect a color name (like 'pink') or hex-formatted color (like '#1412FA'). A default will be used.`, state.lineNumber);
                else value = [ident, args[0]];
            } else if (prelude_param_multi.includes(ident)) {
                if (args.length < 1)
                    logError(`Prelude option "${errorCase(ident)}" has no arguments, but it needs at least one.`, state.lineNumber);
                else value = [ident, args.join(' ')];
            } else throw 'args';
            return value;
        }

        function setState(state, value) {
            const ident = value[0];
            if (ident == 'case_sensitive') {
                state.case_sensitive = true;
                caseSensitive = true;
                if (Object.keys(state.metadata).some(k => prelude_param_text.includes(k)))
                    logWarningNoLine("Please make sure that CASE_SENSITIVE comes before any case sensitive prelude setting.", false, false);
            } else if (ident == 'debug_switch') {
                debugSwitch = value[1];
            } else if (ident == 'mouse_clicks' && !directions_table.includes(mouse_clicks_table[0])) {
                directions_table.push(...mouse_clicks_table);
                directions_only.push(...mouse_clicks_table);
                soundverbs_movement.push(...mouse_clicks_table);
            } else if (ident == 'sprite_size') {
                const args = value[1].split('x').map(a => parseInt(a));
                if (!(args.length == 1 || args.length == 2))
                    logError(`MetaData "${errorCase(ident)}" requires an argument of numbers like 8x8 or 10, not ${value[1]}.`, state.lineNumber);
                else state.sprite_size = args[0];
            } else if (ident == 'youtube') {
                logWarning("Unfortunately, YouTube support hasn't been working properly for a long time - it was always a hack and it hasn't gotten less hacky over time, so I can no longer pretend to support it.",state.lineNumber);
                return;
            } else if (ident == 'game_uri') {
                logWarning(`Setting "${errorCase(ident)}" is an experimental Pattern:Script feature. Do not use.`,state.lineNumber);
                return;
            }
            state.metadata.push(...value);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store a TAG definition
    //  <tagid> = { id | tagid }...
    //
    function parseTagsLine(stream, state) {
        const lexer = new Lexer(stream, state);
        const symbols = {};

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            // start of parse
            if (token = lexer.matchName(!state.case_sensitive)) {
                symbols.id = token;
                if (isAlreadyDeclared(state, token) || token.match(/^(player|background)$/i)) {
                    logError(`You cannot define a tag called "${errorCase(token)}" because the name is already in use.`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else if (hasParts(token)) {
                    logError(`You cannot use "${errorCase(token)}" to define a tag because it contains colons (":").`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else lexer.pushToken(token, 'NAME');
            } else {
                token = lexer.matchNotComment();
                logError(`Expected a name for a new tag, but found "${errorCase(token)}".`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            if (token = lexer.match(/^=/, true)) {
                lexer.pushToken(token, 'ASSIGNMENT');
            } else {
                token = lexer.matchNotComment();
                logError(`Expected an equals sign "=" after the tag name but got "${errorCase(token)}".`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            symbols.members = [];
            while (true) {
                // todo: handle recursive tag defs
                if (token = lexer.matchName(!state.case_sensitive)) {
                    symbols.members.push(token);
                    lexer.pushToken(token, 'NAME');
                } else {
                    token = lexer.matchNotComment();
                    logError(`Expected a name for a new tag member, but found "${errorCase(token)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    return;
                }
                if (lexer.matchEol()) break;
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            state.tags[symbols.id] = symbols.members.map(m => expandTag(m)).flat();
        }

        // tags that reference other tags are expanded to the lowest level here rather than when used
        function expandTag(arg) {
            const ret = [];
            if (Object.hasOwn(state.tags, arg)) 
                ret.push(...state.tags[arg].map(t => expandTag(t)).flat())
            else ret.push(arg);
            return ret;
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store a MAPPINGS definition line 1
    // line ::= oldid '=>' newid
    // oldid ::= ( tag-ident | prop-obj-ident )
    //
    function parseMappingsLine1(stream, state) {
        const lexer = new Lexer(stream, state);
        const symbols = {};

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            
            lexer.matchComment();
            if (token = lexer.matchName(!state.case_sensitive)) {
                symbols.lhs = token;
                if (!(isDeclaredAs(state, token) == 'tag')) {       // todo: propobj
                    logError(`Expected a TAG name but "${errorCase(token)}" is not one.`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else {
                    lexer.pushToken(token, 'NAME');
                }
            } else {
                token = lexer.matchNotComment();
                logError(`Expected a TAG name, but found "${errorCase(token)}" instead.`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            if (token = lexer.match(/^=>/)) {
                lexer.pushToken(token, 'ASSIGNMENT');
            } else {
                token = lexer.matchNotComment();
                logError(`Expected an arrow sign "=>" but got "${errorCase(token)}" instead.`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            if (token = lexer.matchName(!state.case_sensitive)) {
                symbols.rhs = token;
                if (isAlreadyDeclared(state, token)) {
                    logError(`You cannot define a mapping called "${errorCase(token)}" because the name is already in use.`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else {
                    lexer.pushToken(token, 'NAME');
                }
            } else {
                token = lexer.matchNotComment();
                logError(`Expected a name for a mapping, but got "${errorCase(token)}" instead.`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            state.mappings[symbols.rhs] = { 
                fromKey: symbols.lhs,
                lineNumber: state.lineNumber,
             };
            state.objects_candname = symbols.rhs;
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store the second line of a MAPPINGS definition
    // line ::= tag-ident-values{n} -> mapped-ident{n}
    //       || prop-obj-ident-values{n} -> mapped-ident{n}
    //
    function parseMappingsLine2(stream, state) {
        const lexer = new Lexer(stream, state);
        const mapping = state.mappings[state.objects_candname];
        const symbols = {};

        if (getTokens())
            setState();
        else delete state.mappings[state.objects_candname];
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            
            lexer.matchComment();
            symbols.lhs = [];
            while (token = lexer.matchName(!state.case_sensitive)) {
                if (!state.tags[mapping.fromKey].includes(token)) {      // todo: prop
                    logError(`The name "${errorCase(token)}" needs to be defined by "${errorCase(mapping.fromKey)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else {
                    lexer.pushToken(token, 'NAME');
                    symbols.lhs.push(token);
                }
                lexer.matchComment();
            }

            if (token = lexer.match(/^->/)) {
                lexer.pushToken(token, 'ASSIGNMENT');
            } else {
                token = lexer.matchNotComment();
                logError(`Expected an arrow sign "->" but got "${errorCase(token)}" instead.`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            symbols.rhs = [];
            while (token = lexer.matchName(!state.case_sensitive)) {
                if (!token) {      // what do we not allow?
                    logError(`The name "${errorCase(token)}" is a very bad thing.`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                } else {
                    lexer.pushToken(token, 'NAME');
                    symbols.rhs.push(token);
                }
            }

            if (!lexer.matchEol()) {
                token = lexer.matchNotComment();
                logError(`Unrecognised stuff in a mapping: "${errorCase(token)}".`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            if (!(symbols.lhs.length == symbols.rhs.length 
                && new Set(symbols.lhs).size == symbols.lhs.length
                && new Set(symbols.lhs).size == symbols.rhs.length))
                logError(`Oops! You need the same number of symbols on both sides, and no duplicates.`, state.lineNumber);
            else {
                mapping.fromValues = symbols.lhs;
                mapping.values = symbols.rhs;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store an object name, return token list
    // nameline ::= symbol { symbol | glyph } transforms
    function parseObjectName(stream, state, mixedCase) {
        const lexer = new Lexer(stream, state);
        const symbols = {};
        const aliases = [];
        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            if (state.case_sensitive)
                stream.string = mixedCase;
            lexer.matchComment();

            while (true) {
                let token = null;
                let kind = 'ERROR';
                
                // special for PS+, because otherwise it might get parsed as a name
                if (symbols.candname && lexer.check(reg_objmodi)) {
                    break;
                // first name must be an object, glyph allowed after that
                } else if ((token = lexer.matchObjectName(!state.case_sensitive) 
                    || (symbols.candname && lexer.matchObjectGlyph(!state.case_sensitive)))) {
                    if (state.legend_synonyms.some(s => s[0] == token)) {
                        logError(`Name "${errorCase(token)}" already in use.`, state.lineNumber);

                    } else if (state.objects[token] && !state.objects[token].canRedef) {
                        logError(`Object "${errorCase(token)}" defined multiple times.`, state.lineNumber);

                    } else {
                        if (keyword_array.includes(token)) 
                            logWarning(`You named an object "${errorCase(token)}", but this is a keyword. Don't do that!`, state.lineNumber);
                        kind = 'NAME';  
                        if (!symbols.candname) symbols.candname = token;
                        else aliases.push(token);
                    }
                    lexer.pushToken(token, kind);
                    if (lexer.matchEolSemi()) break;

                } else if (token = lexer.matchToken()) {
                    logError(`Invalid object name in OBJECT section: "${errorCase(token)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    lexer.matchNotComment();
                    break;
                } else throw 'name';
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            const candname = state.objects_candname = symbols.candname;
            registerOriginalCaseName(state, candname, mixedCase, state.lineNumber);

            // use existing if there is one, to maintain the correct order of addition
            // preserve colors and sprite matrix, not transforms
            const newobj = state.objects[candname] || {       // doc: array of objects indexed by name
                lineNumber: state.lineNumber,
                colors: [],
                spritematrix: [],
            };
            delete newobj.canRedef;
            newobj.transforms = [];
            delete state.objects[candname];
            state.objects[candname] = newobj;

            const cnlc = candname.toLowerCase();
            if (candname != cnlc && [ "background", "player" ].includes(cnlc))
                createAlias(state, cnlc, candname, state.lineNumber);
            for (const alias of aliases) {
                registerOriginalCaseName(state, alias, mixedCase, state.lineNumber);
                createAlias(state, alias, candname, state.lineNumber);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    function parseObjectColors(stream, state) {
        const lexer = new Lexer(stream, state);
        const colors = [];

        if (getTokens())
            state.objects[state.objects_candname].colors = colors;
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            while (!lexer.matchEolSemi()) {
                let token = null;
                let kind = 'ERROR';
                if (token = lexer.match(/^[#\w]+/, true)) {
                    if (color_names.includes(token) || token.match(/#([0-9a-f]{2}){3,4}|#([0-9a-f]{3,4})/)) {
                        colors.push(token);
                        kind = (token in colorPalettes.arnecolors) ? `COLOR COLOR-${token.toUpperCase()}`
                            : (token === "transparent") ? 'COLOR FADECOLOR'
                            : `MULTICOLOR${token}`;
                    } else logWarning(`Invalid color in object section: "${errorCase(token)}".`, state.lineNumber);

                } else if (token = lexer.matchToken()) {
                    logError(`Was looking for color for object "${errorCase(state.objects_candname)}", got "${errorCase(token)}" instead.`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    lexer.matchNotComment();
                } else throw 'obj-color';
                lexer.pushToken(token, kind);
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // parse sprite grid, one cell at a time (to show them coloured)
    // grid ::= anychar... [ white [ comment ] ]
    // text ::= TEXT: anychar...
    function parseObjectSprite(stream, state) {
        const lexer = new Lexer(stream, state);
        const values = [];
        const obj = state.objects[state.objects_candname];
        
        if (getTokens()) {
            if (values.text) 
                obj.spritetext = values.text;
            else obj.spritematrix = (obj.spritematrix || []).concat([values]);
        }
        return lexer.tokens;

        // build a list of tokens and kinds, and extract values
        function getTokens() {
            let kind = 'ERROR';
            let token;
            if (token = lexer.match(/^text:/i, false)) {
                lexer.pushToken(token, 'LOGICWORD');

                token = lexer.matchAll();
                const kind = obj.colors.length == 1 ? `COLOR COLOR-${obj.colors[0].toUpperCase()}` : 'ERROR';
                lexer.pushToken(token, kind);
                values.text = token;
                state.objects_section = 0;
                return true;
            }    

            while (!stream.eol()) {
                let token = lexer.next();
                let kind = 'ERROR';
                let value = -1;
                if (token.match(/\s/)) break; // stop on whitespace, rest is comment or junk
                if (token == '.') kind = 'COLOR FADECOLOR';
                else if (token.match(/[0-9a-zA-Z]/)) {
                    value = token <= '9' ? +token : 10 + token.toLowerCase().charCodeAt(0) - 97;  // letter 'a'
                    if (!obj.colors[value]) 
                        logError(`Trying to access color number ${value + 1} from the color palette of sprite ${state.objects_candname}, but there are only ${obj.colors.length} defined in it."`, state.lineNumber);
                    else kind = 'COLOR BOLDCOLOR COLOR-' + obj.colors[value].toUpperCase();
                } else logError(`Invalid character "${errorCase(token)}" in sprite for ${state.objects_candname}`, state.lineNumber);
                lexer.pushToken(token, kind);
                values.push(value);
            }
            lexer.matchEol();
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse vector data for canvas or svg
    function parseObjectVector(stream, state) {
        const lexer = new Lexer(stream, state);
        const values = [];
        const obj = state.objects[state.objects_candname];
        
        if (getTokens()) 
            obj.vector.data = (obj.vector.data || []).concat(values);
        return lexer.tokens;

        // build a list of tokens and kinds, and extract array of values
        function getTokens() {
            let kind = 'ERROR';
            let token;
            if (obj.vector.type == 'canvas') {
                while (!lexer.matchEol()) {
                    kind = 'ERROR';
                    if (token = lexer.match(/^\{[^}]*\}/, false)) {
                        try {
                            const json = JSON.parse(token);
                            if (json) {
                                values.push(json);
                                kind = 'SPRITEMATRIX';
                            }
                        } catch (error) { }
                    } else token = lexer.matchAll();   
                }
                lexer.pushToken(token, kind);
                if (kind == 'ERROR') 
                    logError(`I was looking for some valid JSON (in curly braces) but found this instead: "${token}."`, state.lineNumber);
                return kind != `ERROR`;

            } else if (obj.vector.type == 'svg') {
                // TODO: check svg syntax
                logError(`SVG is not yet implemented. Sorry.`, state.lineNumber);
                //kind = 'SPRITEMATRIX';
                token = lexer.matchAll();
                values.push(token);
                return true;

            } else throw 'vector';
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store object transforms
    // transforms ::= { COPY: name | SCALE: number 
    //               | SHIFT: <dir> | TRANSLATE: <dir> : <amount> | ROT: <dir> : <dir> }...
    // assumes object already exists
    function parseObjectTransforms(stream, state) {
        const candname = state.objects_candname;
        const obj = state.objects[candname];
        if (!obj) throw 'obj';
        const lexer = new Lexer(stream, state);
        const symbols = { transforms: [] };
        if (getTokens())
            setState();
        return lexer.tokens;

        function isValidDirection(arg) {
            if (Object.hasOwn(state.tags, arg)) {
                return state.tags[arg].every(v => clockwiseDirections.includes(v)) ? arg : null;
            }
            return clockwiseDirections.includes(arg) ? arg : null;
        }

        // build a list of tokens and kinds
        function getTokens() {
            while (!lexer.matchEolSemi()) { 
                let token = null;
                let kind = 'ERROR';
                if (token = lexer.match(/^copy:/i)) {
                    if (symbols.cloneSprite) 
                        logError(`You already assigned a sprite source for "${errorCase(symbols.candname)}", you can't have more than one!`, state.lineNumber);
                    else kind = 'KEYWORD';
                    lexer.pushToken(token, kind);
                    lexer.matchComment();

                    kind = 'ERROR';
                    if (!(token = lexer.matchObjectName(!state.case_sensitive)))      // ?? glyph too?
                        logError(`Missing sprite to copy from.`, state.lineNumber);
                    else if (token == symbols.candname) 
                        logError(`You attempted to set the sprite "${errorCase(token)}" to copy from itself! Please don't.`, state.lineNumber)
                    else if (!(isAlreadyDeclared(state, token) || createObjectRef(state, token)))
                        logError(`You're trying to copy from "${errorCase(token)}" but it's not defined anywhere.`, state.lineNumber)
                    else {
                        kind = 'NAME';
                        symbols.cloneSprite = token;
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^scale:/i)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();

                    token = lexer.match(/^[0-9.]+/);
                    const arg = parseFloat(token);
                    if (arg == NaN)
                        logError(`Scale requires a numeric argument.`, state.lineNumber);
                    else {
                        symbols.scale = arg;
                        kind = 'METADATATEXT';  //???
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^flip:/i)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();

                    //token = lexer.match(/^[a-z^<>]+/i,  true);
                    token = lexer.matchObjectName(true) || lexer.match(/^[<v>^]/);
                    const dir = isValidDirection(token);
                    if (dir == null)
                        logError(`Flip requires a direction or tag argument, but you gave it ${errorCase(token)}.`, state.lineNumber);
                    else {
                        symbols.transforms.push([ 'flip', dir ]);
                        kind = 'METADATATEXT';  //???
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^[|-]/)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();
                    symbols.transforms.push([ 'flip', token == '|' ? '>' : 'v']);  

                } else if (token = lexer.match(/^shift:/i)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();

                    token = lexer.match(/^[a-z0-9:^<>]+/i,  true);
                    //token = lexer.matchObjectName(true) || lexer.match(/^[>v<^]/);
                    const args = token ? token.split(':') : [];
                    const dir = isValidDirection(args[0]);
                    const amt = args[1] ? +args[1] : 1;
                    if (!(args.length <= 2 && dir && amt))
                        logError(`Shift requires a direction or tag argument and optionally how many, but you gave it ${errorCase(token)}.`, state.lineNumber);
                    else {
                        symbols.transforms.push([ 'shift', dir, amt ]);
                        kind = 'METADATATEXT';  //???
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^translate:/i)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();

                    token = lexer.match(/^[a-z0-9:^<>]+/i,  true);
                    const args = token ? token.split(':') : [];
                    const dir = isValidDirection(args[0]);
                    const amt = args[1] ? +args[1] : null;
                    if (!(args.length == 2 && dir && amt))
                        logError(`Translate requires two arguments, a direction or tag and an amount, not ${errorCase(token)}.`, state.lineNumber);
                    else {
                        symbols.transforms.push([ 'translate', dir, +args[1] ]);
                        kind = 'METADATATEXT';  //???
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^rot:/i)) {
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();

                    token = lexer.match(/^[a-z:^<>]+/i,  true);
                    const args = token ? token.split(':') : [];
                    if (args.length == 1) args.unshift('up');
                    const dir1 = isValidDirection(args[0]);
                    const dir2 = isValidDirection(args[1]);
                    if (!(args.length <= 2 && dir1 && dir2))
                        logError(`For rot: you need 1 or 2 direction or tag arguments, but you gave it ${token ? errorCase(token) : 'neither'}.`, state.lineNumber);
                    else {
                        symbols.transforms.push([ 'rot', dir1, dir2 ]);
                        kind = 'METADATATEXT';  //???
                    }
                    lexer.pushToken(token, kind);

                } else if (token = lexer.match(/^canvas:/i)) {//@@
                    lexer.pushToken(token, 'KEYWORD');
                    lexer.matchComment();
                    symbols.vector = { 
                        type: 'canvas', 
                        data: [] 
                    };
                    if (token = lexer.match(/^[0-9,]+/,  true)) {
                        const parts = token && token.split(',');
                        if (!(parts.length >= 1 && parts.length <= 2))
                            logError(`Canvas size has to be specified as a number or number,number, not ${errorCase(token)}.`, state.lineNumber);
                        else {
                            symbols.vector.w = parts[0];
                            symbols.vector.h = parts[1] || parts[0];
                            kind = 'METADATATEXT';  //???
                        }
                        lexer.pushToken(token, kind);
                    }

                } else if (token = lexer.matchToken()) {
                    logError(`Invalid token in OBJECT modifier section: "${errorCase(token)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    lexer.matchNotComment();
                    break;
                } else throw 'obj-modi';
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            if (symbols.cloneSprite) obj.cloneSprite = symbols.cloneSprite;
            if (symbols.scale) obj.scale = symbols.scale;
            if (symbols.vector) obj.vector = symbols.vector;
            if (symbols.transforms) obj.transforms.push( ...symbols.transforms );
        }
    }

    // if the last object has tags, expand it, delete original name and add property
    function expandLastObject(state) {
        const candname = state.objects_candname;
        if (!candname || !hasParts(candname)) return;
        const obj = state.objects[candname];
        const newobjects = expandObjectDef(state, candname, obj);
        if (newobjects) {
            // add new objects but do not overwrite existing
            for (const [newid, newvalue] of newobjects)
                if (!Object.hasOwn(state.objects, newid))
                    state.objects[newid] = newvalue;
            const newlegend = [ candname, ...newobjects.map(n => n[0])];
            newlegend.lineNumber = obj.lineNumber;  // bug: it's an array, isn't it?

            delete state.objects[candname];
            state.objects_candname = '';
            state.legend_properties.push(newlegend);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // SOUND DEFINITION:
    // SOUNDEVENT ~ INT (Sound events take precedence if there's name overlap)
    // OBJECT_NAME
    //     NONDIRECTIONAL_VERB ~ INT
    //     DIRECTIONAL_VERB
    //         INT
    //         DIR+ ~ INT
    // parse a SOUNDS line, extract parsed information, return array of tokens
    function parseSoundLine(stream, state) {
        const lexer = new Lexer(stream, state);
        const rows = [];
        const symbols = {};
        
        if (getTokens()) 
            state.sounds.push(...rows);
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token = null;
            let kind = 'ERROR';
            if (token = lexer.match(reg_soundevents, true)) {
                // closemessage 1241234...
                lexer.pushToken(token, 'SOUNDEVENT');
                lexer.matchComment();
                const tevent = token;

                const tsounds = parseSoundSeedsTail();
                if (tsounds) {
                    rows.push(...tsounds.map(s => ['SOUNDEVENT', tevent, s, state.lineNumber]));
                    return true;
                } else {
                    logError("Was expecting a sound seed here (a number like 123123, like you generate by pressing the buttons above the console panel), but found something else.", state.lineNumber);                                
                }
            } else if (token = lexer.matchObjectName(!state.case_sensitive)) {
                // player move [ up... ] 142315...
                const tobjects = getObjectRefs(state, token);
                if (!tobjects) {
                    const undef = getObjectUndefs(state, token);
                    logError(`Found "${errorCase(token)}", which looks like an object but ${ undef[0] ? errorCase(undef[0]) : 'it' } is not declared anywhere.`, state.lineNumber);
                } else {
                    lexer.pushToken(token, 'NAME');

                    let tverb = null;
                    if ((token = lexer.match(/^[a-z]+/i, true))) {
                        if (soundverbs_directional.includes(token) || soundverbs_movement.includes(token) || soundverbs_other.includes(token)) {
                            lexer.pushToken(token, 'SOUNDVERB');
                            tverb = token;
                            lexer.matchComment();
                        } else lexer.pushBack();
                    }

                    if (!tverb) {
                        logError("Was expecting a soundverb here (MOVE, DESTROY, CANTMOVE, or the like), but found something else.", state.lineNumber);
                    } else {
                        const tdirs = [];
                        while (token = lexer.match(reg_sounddirectionindicators, true)) {
                            lexer.pushToken(token, 'DIRECTION');
                            tdirs.push(token);
                            lexer.matchComment();
                        }

                        const tsounds = parseSoundSeedsTail();
                        if (tsounds) {
                            tobjects.forEach(t => 
                                rows.push(...tsounds.map(s => ['SOUND', t, tverb, tdirs, s, state.lineNumber])));
                            return true;
                        } else if (token == lexer.matchNotComment()) {
                            const dirok = soundverbs_directional.includes(tverb);
                            const msg = dirok ? "direction or sound seed" : "sound seed";
                            logError(`Ah I was expecting a ${msg} after ${tverb}, but I don't know what to make of "${errorCase(token)}".`, state.lineNumber);
                        }
                    }
                }
            } else logError("Was expecting a sound event (like SFX3, or ENDLEVEL) or an object name, but didn't find either.", state.lineNumber);

            if (token == lexer.matchNotComment())
                lexer.pushToken(token, 'ERROR');
            return false;
        }
        
        // parse list of at least one sound seeds, check for eol
        function parseSoundSeedsTail() {
            const tsounds = [];
            let token = null;
            while (token = lexer.match(/^(\d+(:[\d.]+)?|afx:[\w:=+-.]+)\b/i, true)) {
                lexer.pushToken(token, 'SOUND');
                tsounds.push(token);
                lexer.matchComment();
            }
            if (token = lexer.matchNotComment()) {
                logError(`I wasn't expecting anything after the sound declaration ${tsounds.at(-1)} on this line, so I don't know what to do with "${errorCase(token)}" here.`, state.lineNumber);
                return null;
            } else return tsounds;
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    function parseLegendLine(stream, state, mixedCase) {
        const lexer = new Lexer(stream, state);
        const names = [];
        const symbols = {};

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            // start of parse
            if (token = lexer.matchObjectName(!state.case_sensitive) || lexer.matchObjectGlyph(!state.case_sensitive)) {
                symbols.newname = token;
                const defname = isAlreadyDeclared(state, token);
                if (defname)
                    logError(`Name "${errorCase(token)}" already in use (on line ${htmlJump(defname.lineNumber, 'errorTextLineNumber')}`);
                else if (keyword_array.includes(token))
                    logWarning(`You named an object "${errorCase(token)}", but this is a keyword. Don't do that!`, state.lineNumber);
                lexer.pushToken(token, defname ? 'ERROR' : 'NAME');
            }
            lexer.matchComment();

            if (token = lexer.match(/^=/)) {
                lexer.pushToken(token, 'ASSIGNMENT');
            } else {
                logError(`In the legend, define new items using the equals symbol - declarations must look like "A = B", "A = B or C [ or D ...]", "A = B and C [ and D ...]".`, state.lineNumber);
                lexer.matchNotComment();
                return;
            }
            lexer.matchComment();

            while (true) {
                let kind = 'ERROR';
                if (token = lexer.matchObjectName(!state.case_sensitive) || lexer.matchObjectGlyph(!state.case_sensitive)) {
                    const tobjects = getObjectRefs(state, token);
                    if (!tobjects) {
                        const undef = getObjectUndefs(state, token);
                        logError(`You're talking about "${errorCase(token)}" but ${ undef[0] ? errorCase(undef[0]) : 'it' } is not defined anywhere.`, state.lineNumber);
                    } else if (token == symbols.newname)
                        logError(`You can't define object "${errorCase(token)}" in terms of itself!`, state.lineNumber);
                    else {
                        if (names.includes(token))
                            logWarning(`You're repeating the object "${errorCase(token)}" here multiple times on the RHS.  This makes no sense.  Don't do that.`, state.lineNumber);                        
                        names.push(...tobjects);
                        if (tobjects.length > 1) symbols.andor ||= 'or';
                        kind = 'NAME';
                    }
                } 
                lexer.pushToken(token, kind);
                if (kind != 'NAME') {
                    lexer.matchNotComment();
                    logError(`Something bad's happening in the LEGEND`, state.lineNumber);
                    return;
                }

                if (lexer.matchEol()) break;

                if (token = lexer.match(/^(and|or)\b/i, true)) {
                    if (symbols.andor && token != symbols.andor)
                        logError(`Cannot mix AND and OR`, state.lineNumber);
                    else {
                        symbols.andor ||= token;
                        kind = 'LOGICWORD';
                    }
                    lexer.pushToken(token, kind);
                } else {
                    token = lexer.match(reg_notcommentstart);
                    logError(`AND or OR expected, found ${errorCase(token)}`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    return;
                }
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function setState() {
            if (names.length == 1) {
                registerOriginalCaseName(state, symbols.newname, mixedCase, state.lineNumber);  // tofix:
                createAlias(state, symbols.newname, names[0], state.lineNumber);
            } else if (symbols.andor == 'and') {
                const newlegend = [ symbols.newname, ...names
                    .flatMap(n => expandSymbol(state, n, true, 
                        () => logError("Cannot define an aggregate (using 'and') in terms of properties (something that uses 'or').", state.lineNumber))) ];
                newlegend.lineNumber = state.lineNumber;
                registerOriginalCaseName(state, symbols.newname, mixedCase, state.lineNumber);
                state.legend_aggregates.push(newlegend);
            } else { // == 'or'
                const newlegend = [ symbols.newname, ...names
                    .flatMap(n => expandSymbol(state, n, false,
                        () => logError("Cannot define a property (something defined in terms of 'or') in terms of aggregates (something that uses 'and').", state.lineNumber))) ];
                newlegend.lineNumber = state.lineNumber;
                registerOriginalCaseName(state, symbols.newname, mixedCase, state.lineNumber);
                state.legend_properties.push(newlegend);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // parse and store a collision layer line
    // [ tag [, ...] -> ] ( object | property) [, ...]
    // -- [-^<>-|]...

    // tag prefixes and objects and properties in the body:
    //      Position -> Clue:Position:Value, NoClueCover:Position
    //      dirs -> vs_any_under:dirs:offs
    //      directions, directions1 -> GridLines:directions:directions1
    
    function parseCollisionLayer(stream, state) {
        const lexer = new Lexer(stream, state);
        let divider
        const idents = [];
        let prearrow = 0;         // how many layers prefixes

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token = null;
            // start of parse
            while (true) {
                if (token = lexer.match(/^--[-^v<>-|]*/)) {
                    lexer.pushToken(token, 'LOGICWORD');
                    divider = token;
                    if (lexer.matchEolSemi()) break;
                } else if (token = lexer.match(/^->/)) {
                    if (idents.length == 0 || prearrow != 0)
                        logError(`Cannot use arrow syntax here.`, state.lineNumber);
                    else {
                        prearrow = idents.length;
                        lexer.pushToken(token, 'LOGICWORD');
                    }
                } else if (token = lexer.matchObjectName(!state.case_sensitive) || lexer.matchObjectGlyph(!state.case_sensitive)) {
                    let kind = 'ERROR';
                    const trefs = getObjectRefs(state, token);   // do we need this?
                    if (token == 'background' && idents.length != 0)
                        logError("Background must be in a layer by itself.",state.lineNumber);
                    else if (!trefs) {
                        const undef = getObjectUndefs(state, token);
                        logError(`Cannot add "${errorCase(token)}" to a collision layer, ${ undef[0] ? errorCase(undef[0]) : 'it' } has not been declared.`, state.lineNumber);
                    } else {
                        if (idents.includes(token))
                            logWarning(`Object "${errorCase(token)}" included explicitly multiple times in the same layer. Don't do that innit.`,state.lineNumber);         
                        else idents.push(token);
                        kind = 'NAME';
                    }
                    lexer.pushToken(token, kind);
                } else {
                    token = lexer.match(reg_notcommentstart);
                    logError(`Object name expected, found ${errorCase(token)}`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    return;
                }

                if (lexer.matchEolSemi()) break;

                // treat the comma as optional (as PS seems to do). Trailing/extra comma is OK too
                while (token = lexer.match(/^,/)) {
                    lexer.pushToken(token, 'LOGICWORD');
                } 
                if (lexer.matchEolSemi()) break;
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        // further error checking and update external state
        function setState() {

            // functions to manage keyed layers
            const keylayers = [];

            // append objects to a layer by key, or create a new one
            function addToLayer(key, objects) {
                if (keylayers[key]) 
                    keylayers[key].layer.push(...objects);
                else keylayers[key] = { lineNumber: state.lineNumber, layer: objects };
            }
            function getNewLayers() {
                return Object.values(keylayers).map(k => k.layer);
            }

            // add new objects to the proper layer based on ident and prefixes
            // if a part is a member of a prefix it goes in a layer keyed by the part
            function addNewObjects(newobjs, ident, prefixes) {
                const parts = ident.split(':');
                const prefs = prefixes.filter(p => parts.includes(p));
                if (parts.length == 1 || prefixes.length == 0) addToLayer('+', newobjs);
                else {
                    // map the position of the prefix in the parts list
                    const indexes = prefs.map(p => parts.indexOf(p));
                    for (const obj of newobjs) {
                        const key = indexes.map(i => obj.split(':')[i]).join('+');
                        addToLayer(key, [ obj ]);
                    }
                }
            }

            // check for divider first
            if (divider) {
                const chars = '^>v<|-';
                const dirs = ['up', 'right', 'down', 'left', 'down', 'right' ];
                const combos = ['downright', 'downleft', 'upright', 'upleft',
                                'leftdown', 'leftup', 'rightdown', 'rightup'];
                const dirFirst = dirs[chars.indexOf(divider[2] || '>')];
                const dirSecond = dirs[chars.indexOf(divider[3] || 'v')];
                if (!combos.includes(dirFirst + dirSecond)) {
                    consoleError(`Layer divider ${divider} is not valid.`);
                    return;
                }
                state.collisionLayerGroups.push({ 
                    lineNumber: state.lineNumber, 
                    layer: state.collisionLayers.length,
                    dirFirst: dirFirst,
                    dirSecond: dirSecond,
                });
                return;
            } 
            
            if (state.collisionLayerGroups.length == 0) {
                state.collisionLayerGroups.push({ 
                    lineNumber: state.lineNumber, 
                    layer: 0,
                    dirFirst: 'right',
                    dirSecond: 'down',
                });

            }

            // expand rhs first
            const prefixes = idents.slice(0, prearrow);
            const rhs = idents.slice(prearrow)
            for (const prefix of prefixes) {
                if (!(state.tags[prefix] || state.legend_properties.find(s => s[0] == prefix))) {
                    logError(`A layer prefix must be a tag or property but ${prefix} is not.`, state.lineNumber);
                    return;
                }
            }
            
            for (const ident of rhs) {
                const idents = getObjectRefs(state, ident);
                const newobjs =  idents.map(i => expandSymbol(state, i, false, n => logError(
                    `"${n}" is an aggregate (defined using "and"), and cannot be added to a single layer because its constituent objects must be able to coexist.`, state.lineNumber)))
                    .flat();

                // do we care about possible in-layer duplicates?
                const dups = new Set();
                state.collisionLayers.forEach((layer, layerno) => {
                    for (const obj of newobjs) {
                        if (layer.includes(obj))
                            dups.add(layerno + 1);
                    }
                });
                if (dups.size != 0) {
                    const joins = [...dups].map(v => `#${v}, `) + `#${state.collisionLayers.length + 1}`;
                    logWarning(`Object "${errorCase(ident)}" included in multiple collision layers ( layers ${joins} ). You should fix this!`, state.lineNumber);
                }

                // then use lhs to assign to layers
                addNewObjects(newobjs, ident, prefixes);
            }
            // remove the keys and push one or more layers
            const newlayers = getNewLayers();
            newlayers.forEach(l => state.collisionLayers.push(l));
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    //  [ ALL | ANY | NO | SOME ] <object> [ ON <object> ]?
    //
    function parseWinCondition(stream, state) {
        const lexer = new Lexer(stream, state);
        const names = [];
        const symbols = {};

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            // start of parse
            if (token = lexer.match(/^(all|any|no|some)\b/i, true)) {
                symbols.start = token;
                lexer.pushToken(token, 'LOGICWORD');
            } else {
                token = lexer.match(reg_notcommentstart);
                logError(`Expecting the start of a win condition ("ALL","SOME","NO") but got "${errorCase(token)}".`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }

            lexer.matchComment();
            getIdent();
            if (!lexer.matchEol()) {
                if (token = lexer.match(/^(on)\b/u, true)) {
                    symbols.kind = token;
                    lexer.pushToken(token, 'LOGICWORD');
                } else {
                    token = lexer.matchNotComment();
                    logError(`Expecting the word "ON" but got "${errorCase(token)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                    return;
                }

                lexer.matchComment();
                getIdent();
                if (!lexer.matchEol()) {
                    token = lexer.matchNotComment();
                    logError(`Error in win condition: I don't know what to do with "${errorCase(token)}".`, state.lineNumber);
                    lexer.pushToken(token, 'ERROR');
                }
            }
            return !lexer.tokens.some(t => t.kind == 'ERROR');
        }

        function getIdent() {
            let token
            if (token = lexer.matchObjectName(!state.case_sensitive) || lexer.matchObjectGlyph(!state.case_sensitive)) {
                let kind = 'ERROR';
                if (!(isAlreadyDeclared(state, token) || createObjectRef(state, token)))
                    logError(`Error in win condition: "${errorCase(token)}" is not a valid object name.`, state.lineNumber);
                else {
                    names.push(token);
                    kind = 'NAME';
                }
                lexer.pushToken(token, kind);
            } else {
                token = lexer.matchNotComment();
                logError(`Object name expected, found ${errorCase(token)}`, state.lineNumber);
                lexer.pushToken(token, 'ERROR');
                return;
            }
        }

        function setState() {
            state.winconditions.push((names.length == 1) 
                ? [ symbols.start, names[0], state.lineNumber ]
                : [ symbols.start, names[0], 'on', names[1], state.lineNumber ]);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    //  line ::= MESSAGE <text>
    //         | SECTION <text>
    //         | GOTO <text>
    //         | ( <levelchar>+ [ WS comment ] )+
    function parseLevel(stream, state) {
        const lexer = new Lexer(stream, state);
        const names = [];
        const symbols = {};

        if (getTokens())
            setState();
        return lexer.tokens;

        // build a list of tokens and kinds
        function getTokens() {
            let token
            // start of parse
            if (token = lexer.match(/^(goto|level|link|message|section|title)/i, true)) { // allow omision of whitespace (with no warning!)
                symbols.start = token;
                lexer.pushToken(token, `${errorCase(token)}_VERB`);

                if (token == 'link') {
                    if (!(token = lexer.matchObjectName())) 
                        logError(`LINK needs an object to know where to put the link.`, state.lineNumber);
                    else if (!isAlreadyDeclared(state, token))
                        logError(`LINK object "${errorCase(token)}" not found, it needs to be already defined.`, state.lineNumber);
                    else {      // @@
                        const objects = expandSymbol(state, token, false, () => {});
                        if (!(objects && objects.length == 1))
                            logError(`LINK object "${errorCase(token)}" only works with a simple object or an alias, not something created with AND or OR.`, state.lineNumber);
                        {
                            symbols.link = objects[0];
                            lexer.pushToken(token, 'NAME');
                        }
                    }
                }
                symbols.text = lexer.matchAll();
                if (symbols.text.length > 0)
                    lexer.pushToken(symbols.text, `METADATATEXT`);  // empty causes havoc
            } else {
                symbols.gridline = '';
                // allow comments in level grid, per Selene's Labyrinth
                while (true) {
                    if (state.commentStyle == '()' && lexer.peek() == '(') 
                        break;
                    if (token = lexer.match(/^\S/, !state.case_sensitive)) {
                        symbols.gridline += token;
                        const kind = state.abbrevNames.includes(token) ? 'LEVEL' : 'ERROR';
                        if (kind == 'ERROR')
                            logError(`Key "${errorCase(token)}" not found. Do you need to add it to the legend, or define a new object?`, state.lineNumber);
                        lexer.pushToken(token, kind);
                    } else break;
                }
            }

            lexer.matchEol();
            return true;
        }

        function setState() {
            // look for marker level that says a blank line has been seen
            let toplevel = state.levels.at(-1);
            if (toplevel && toplevel.length == 0) {
                state.levels.pop();
                toplevel = null;
            }
            const cmds = [ 'goto', 'level', 'link', 'message', 'section', 'title', ];
            if (cmds.includes(symbols.start))
                state.levels.push([ symbols.start, symbols.text, state.lineNumber, symbols.link ]);
            else {
                if (toplevel == null || cmds.includes(toplevel[0]))
                    state.levels.push([ state.lineNumber, null, symbols.gridline ]);
                else {
                    // if (symbols.gridline.length != toplevel[2].length)
                    //     logWarning("Maps must be rectangular, yo (In a level, the length of each row must be the same).", state.lineNumber);
                    toplevel.push(symbols.gridline);
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // called as per CodeMirror API
    // return value is an object containing a specific set of named functions
    return {
        copyState: function(state) {
            return ({
                original_case_names: Object.assign({}, state.original_case_names),
                original_line_numbers: Object.assign({}, state.original_line_numbers),
                lineNumber: state.lineNumber,

                objects: deepClone(state.objects),
                collisionLayers: state.collisionLayers.map(p => p.slice()),
                collisionLayerGroups: state.collisionLayerGroups.slice(),

                commentLevel: state.commentLevel,
                commentStyle: state.commentStyle,
                section: state.section,
                visitedSections: state.visitedSections.slice(),

                line_should_end: state.line_should_end,
                line_should_end_because: state.line_should_end_because,
                sol_after_comment: state.sol_after_comment,

                objects_candname: state.objects_candname,
                objects_section: state.objects_section,
                objects_spritematrix: state.objects_spritematrix.slice(),

                tokenIndex: state.tokenIndex,
                // PS+ SECTION command argument if any
                current_line_wip_array: state.current_line_wip_array.slice(),

                legend_synonyms: state.legend_synonyms.map(p => p.slice()),
                legend_aggregates: state.legend_aggregates.map(p => p.slice()),
                legend_properties: state.legend_properties.map(p => p.slice()),
                tags: Object.assign({}, state.tags),
                mappings: Object.assign({}, state.mappings),

                sounds: state.sounds.map(p => p.slice()),

                rules: state.rules.map(p => p.slice()),

                names: state.names.slice(),

                winconditions: state.winconditions.slice(),

                original_case_names : Object.assign({},state.original_case_names),
                original_line_numbers : Object.assign({},state.original_line_numbers),
    
                abbrevNames: state.abbrevNames.slice(),

                metadata : state.metadata.slice(),
                metadata_lines: Object.assign({}, state.metadata_lines),

                sprite_size : state.sprite_size,

                case_sensitive : state.case_sensitive,

                levels: state.levels.map(p => p.slice()),

                STRIDE_OBJ : state.STRIDE_OBJ,
                STRIDE_MOV : state.STRIDE_MOV
            });
        },
        blankLine: function(state) {
            blankLineHandle(state);
        },
        // function is called to successively find tokens and return a token type in a source code line
        // note: there is no end of line marker, the next line will follow immediately
        token: function(stream, state) {
            // these sections may have pre-loaded tokens, to be cleared before *anything* else
            if (state.current_line_wip_array.length > 0 && !['rules'].includes(state.section)) {
                return flushToken();
            }

            //--- guard against looping?
            // lastStream.pos = stream.pos;
            // lastStream.start = stream.start;
            // lastStream.lineStart = stream.lineStart;
            // lastStream.string = stream.string;
            //console.log(`get token`, lastStream);
            //--- guard against looping?

            var mixedCase = stream.string;
            //console.log(`Input line ${mixedCase}`)
            var sol = stream.sol();
            if (sol) {
                state.current_line_wip_array = [];

                // PS+ leaves original text unchanged, which means a lot of checking in other places
                if(!state.case_sensitive) {
                    stream.string = stream.string.toLowerCase();
                }
                state.tokenIndex=0;
                state.line_should_end = false;
            }
            if (state.sol_after_comment){
                sol = true;
                state.sol_after_comment = false;
            }

            if (state.tokenIndex !== -4 && matchComment(stream, state) != null) {
                state.sol_after_comment = state.sol_after_comment  || sol;
                return 'comment';
            }

            stream.eatWhile(/[ \t]/);

            if (sol && stream.eol()) {
                return blankLineHandle(state);
            }

            if (state.commentStyle === '()' && stream.match(')')) {
                logWarning("You're trying to close a comment here, but I can't find any opening bracket to match it? [This is highly suspicious; you probably want to fix it.]", state.lineNumber);
                stream.skipToEnd();
                return 'ERROR';
            } else if (state.commentStyle === '//' && stream.match(/[\(\)]/)) {
                logWarning("You're trying to use the wrong type of comment here.[This is highly suspicious; you probably want to fix it.]", state.lineNumber);
                stream.skipToEnd();
                return 'ERROR';
            }

            if (state.line_should_end && !stream.eol()) {
                logError('Only comments should go after ' + state.line_should_end_because + ' on a line.', state.lineNumber);
                stream.skipToEnd();
                return 'ERROR';
            }            

            //MATCH '==="s AT START OF LINE
            if (sol && stream.match(reg_equalsrow, true)) {  // todo: not if we're in a level
                state.line_should_end = true;
                state.line_should_end_because = 'a bunch of equals signs (\'===\')';
                return 'EQUALSBIT';
            }

            if (sol && parseSection(stream, state))
                return 'HEADER';

            if (stream.eol()) {
                //endOfLineProcessing(state,mixedCase);  
                return null;
            }

            // per section specific parsing
            switch (state.section) {
                case '': {
                    stream.string = mixedCase;  // put it back, for now!
                    state.current_line_wip_array = parsePrelude(stream, state);
                    return flushToken();

                }
                case 'tags': {
                    state.current_line_wip_array = parseTagsLine(stream, state, mixedCase);
                    return flushToken();
                }
                case 'mappings': {
                    if (state.objects_section == 0) {
                        state.objects_candname = null;
                        state.current_line_wip_array = parseMappingsLine1(stream, state);
                        state.objects_section = 1;
                    } else {
                        state.current_line_wip_array = parseMappingsLine2(stream, state);
                        state.objects_section = 0;
                    }
                    return flushToken();
                }

                // Objects parsing is all LL(1):
                // object alias* (prop : value?)*
                // ( colour+ )?
                // ( digit+ )*
                // ( json )*
                // ( prop+ )*

                case 'objects': {
                    if (sol) {  // start of line, no previous blank line, what to do?
                        if (state.objects_section >0 && stream.match(reg_objmodi, false)) {
                            state.objects_section = 5;
                        } else if (state.objects_section == 3 || state.objects_section == 4) {
                            // no blank line: criterion for end sprite: <= 10 colours, first char not [.\d], match for object name
                            if (state.objects[state.objects_candname].colors.length <= 10 && !state.objects[state.objects_candname].vector 
                                && !stream.match(/^[.\d]/, false))
                                state.objects_section = 0;
                        }
                    }
                    if (state.objects_section == 0) {
                        expandLastObject(state);
                        state.objects_candname = null;
                        state.current_line_wip_array = [];
                        state.objects_section = 1;
                    }

                    //if (sol) console.log(`${state.lineNumber}: (${state.section}:${state.objects_section}): ${stream.string}`);
                    if (sol)
                        state.current_line_wip_array['mixed'] = mixedCase;
                    else mixedCase = state.current_line_wip_array['mixed'];
                    if (!mixedCase) throw 'mix';

                    //console.log(`objects_section ${state.objects_section} at ${state.lineNumber}: ${mixedCase}`);
                    switch (state.objects_section) {
                    case 1: {
                            state.current_line_wip_array.push(...parseObjectName(stream, state, mixedCase));
                            if (state.objects_candname) {
                                if (stream.match(reg_objmodi, false))
                                    state.current_line_wip_array.push(...parseObjectTransforms(stream, state));
                                state.objects_section++;
                            }
                            return flushToken();
                        }
                    case 2: 
                        if (stream.match(/^[#\w]+/, false)) {
                            state.current_line_wip_array.push(...parseObjectColors(stream, state));
                            state.objects_section++;
                            return flushToken();
                        } else {
                            state.objects_section++;
                            // fall through
                        }
                    case 3: 
                    case 4: {
                            stream.string = mixedCase;
                            const tokens = state.objects[state.objects_candname].vector 
                                ? parseObjectVector(stream, state) 
                                : parseObjectSprite(stream, state);
                            state.current_line_wip_array.push(...tokens);
                            if (state.objects_section == 3)  // text:?
                                state.objects_section++;
                            return flushToken();
                        }
                    case 5: {
                            state.current_line_wip_array.push(...parseObjectTransforms(stream, state));
                            return flushToken();
                        }
                    }
                    break;
                }

                case 'legend': {
                    state.current_line_wip_array = parseLegendLine(stream, state, mixedCase);
                    return flushToken();
                }

                case 'sounds': {
                    stream.string = mixedCase;
                    state.current_line_wip_array = parseSoundLine(stream, state);
                    return flushToken();
                }

                case 'collisionlayers': {
                    state.current_line_wip_array = parseCollisionLayer(stream, state);
                    return flushToken();
                }
                case 'rules': {
                        if (sol) {
                            var rule = reg_notcommentstart.exec(stream.string)[0];
                            state.rules.push([rule, state.lineNumber, mixedCase]);
                            state.tokenIndex = 0;//in rules, records whether bracket has been found or not
                        }

                        if (state.tokenIndex===-4) {
                            stream.skipToEnd();
                            return 'MESSAGE';
                        }
                        if (stream.match(/[\p{Z}\s]*->[\p{Z}\s]*/u, true)) {
                            return 'ARROW';
                        }
                        var ch = stream.peek();
                        if (ch === '[' || ch === '|' || ch === ']' || ch==='+') {
                            if (ch!=='+') {
                                state.tokenIndex = 1;
                            }
                            stream.next();
                            stream.match(/[\p{Z}\s]*/u, true);
                            return 'BRACKET';
                        } else {
                            var m = stream.match(/[^\[\|\]\p{Z}\s]*/u, true)[0].trim();

                            if (state.tokenIndex===0&&reg_loopmarker.exec(m)) {
                                return 'BRACKET';
                            } else if (state.tokenIndex == 0 && m.toLowerCase() == 'subroutine') {
                                state.tokenIndex = -4;
                                return 'BRACKET';
                            } else if (state.tokenIndex === 0 && reg_ruledirectionindicators.exec(m)) {
                                stream.match(/[\p{Z}\s]*/u, true);
                                return 'DIRECTION';
                            } else if (state.tokenIndex === 1 && (directions_table.includes(m)) || Object.hasOwn(state.tags, m)) {
                                stream.match(/[\p{Z}\s]*/u, true);
                                return 'DIRECTION';
                            } else {
                                if (state.names.indexOf(m) >= 0) {
                                    if (sol) {
                                        logError('Objects cannot appear outside of square brackets in rules, only directions can.', state.lineNumber);
                                        return 'ERROR';
                                    } else {
                                        stream.match(/[\p{Z}\s]*/u, true);
                                        return 'NAME';
                                    }
                                } else if (m.match(reg_objectname) && (isAlreadyDeclared(state, m) || createObjectRef(state, m))) {
                                    return 'NAME';
                                }
                                
                                m = m.toLowerCase();
                                if (['...', 'rigid', 'random', 'global', 'once'].includes(m)) {
                                    return 'DIRECTION';
                                } else if (m.match(reg_commandwords)) {
                                    if (commandargs_table.includes(m) || twiddleable_params.includes(m)) {
                                        state.tokenIndex=-4;
                                    }
                                    return 'COMMAND';
                                } else {
                                    logError('Name "' + m + '", referred to in a rule, does not exist.', state.lineNumber);
                                    return 'ERROR';
                                }
                            }
                        }

                        break;
                    }
                case 'winconditions': {
                    state.current_line_wip_array = parseWinCondition(stream, state);
                    return flushToken();
                }
                case 'levels': {
                    stream.string = mixedCase;
                    state.current_line_wip_array = parseLevel(stream, state);
                    return flushToken();
                }
                        
                default: { 
                    throw 'case!';
                }
	        }
            // end of switch

            if (stream.eol()) {
                return null;
            }

            if (!stream.eol()) {
                stream.next();
                return null;
            }

            // flush token and kind list back to caller -- move it???
            function flushToken() {
                if (state.current_line_wip_array.length > 0) {
                    const token = state.current_line_wip_array.shift();
                    stream.pos = token.pos;
                    return token.kind;
                } else return null;
            }

        },
        startState: function() {
            return {
                objects: {},

                lineNumber: 0,
                commentLevel: 0,  // trigger comment style
                commentStyle: null,

                section: '',  // prelude
                visitedSections: [],

                line_should_end: false,
                line_should_end_because: '',
                sol_after_comment: false,

                objects_candname: '',
                objects_section: 0, //whether reading name/color/spritematrix
                objects_spritematrix: [],

                collisionLayers: [],
                collisionLayerGroups: [],

                tokenIndex: 0,

                current_line_wip_array: [],

                legend_synonyms: [],
                legend_aggregates: [],
                legend_properties: [],

                sounds: [],
                rules: [],

                names: [],

                winconditions: [],
                metadata: [],
                metadata_lines: {},

                sprite_size: 5,

                case_sensitive: false,

                original_case_names: {},
                original_line_numbers: {},

                abbrevNames: [],

                levels: [[]],

                tags: { // to match P:S
                    directions: [ 'up', 'right', 'down', 'left' ], 
                    horizontal: [ 'right', 'left' ], 
                    vertical: [ 'up', 'down' ], 
                },
                mappings: {},

                subsection: ''
            };
        }
    };
};

window.CodeMirror.defineMode('puzzle', codeMirrorFn);

</script>
<script>

'use strict';

// static data used here and elsewhere
var relativeDirections = ['^', 'v', '<', '>', 'perpendicular', 'parallel'];
var simpleAbsoluteDirections = ['up', 'down', 'left', 'right'];
var simpleRelativeDirections = ['^', 'v', '<', '>'];

var relativeDirs = ['^', 'v', '<', '>', 'parallel', 'perpendicular']; //used to index the following
//I use _par/_perp just to keep track of providence for replacement purposes later.
var relativeDict = {
    'right': ['up', 'down', 'left', 'right', 'horizontal_par', 'vertical_perp'],
    'up': ['left', 'right', 'down', 'up', 'vertical_par', 'horizontal_perp'],
    'down': ['right', 'left', 'up', 'down', 'vertical_par', 'horizontal_perp'],
    'left': ['down', 'up', 'right', 'left', 'horizontal_par', 'vertical_perp']
};

const directionaggregates = {
    'horizontal': ['left', 'right'],
    'horizontal_par': ['left', 'right'],
    'horizontal_perp': ['left', 'right'],
    'vertical': ['up', 'down'],
    'vertical_par': ['up', 'down'],
    'vertical_perp': ['up', 'down'],
    'moving': ['up', 'down', 'left', 'right', 'action'], // todo: reaction
    'orthogonal': ['up', 'down', 'left', 'right'],
    'perpendicular': ['^', 'v'],
    'parallel': ['<', '>']
};

var tagDirections = [
    { keys: [ '^', 'v', '<', '>', 'perpendicular', 'parallel', 'orthgonal' ], values: [ 'up', 'down', 'left', 'right' ] },
    { keys: [ 'horizontal' ], values: [ 'left', 'right' ] },
    { keys: [ 'vertical' ], values: [ 'up', 'down' ] },
];

function getTag(state, t) {
    return Object.hasOwn(state.tags, t) && state.tags[t];
}

function getMapping(state, m) {
    return Object.hasOwn(state.mappings, m) && state.mappings[m];
}

function isMappedTo(state, key, target) {
    return Object.hasOwn(state.mappings, key) && state.mappings[key].fromKey == target;
}

// is there a mapping fomr => key?
function canMapValue(state, key, from) {
    const map = state.mappings[key];
    return map && map.fromKey == from;
}

function getMappedValue(state, key, value) {
    const map = state.mappings[key];
    const index = map.fromValues.indexOf(value);
    return map.values[index];
}

function getMappedValues(state, key) {
    const map = state.mappings[key];
    return map.values.map(v => getTag(state, v) || v).flat();
}

// https://stackoverflow.com/questions/12303989/cartesian-product-of-multiple-arrays-in-javascript
// const f = (a, b) => [].concat(...a.map(d => b.map(e => [].concat(d, e))));
// const cartesian = (a, b, ...c) => (b ? cartesian(f(a, b), ...c) : a);
// function cartesian(...arrays) {
//     return arrays.reduce((a, b) => a.flatMap(x => b.map(y => x.concat([y]))), [ [] ]);
// }

function cartesianProduct(...arrays) {
    return arrays.reduce((a, b) => a.flatMap(x => b.map(y => x.concat([y]))), [ [] ]);
}

// a combinatorial ident expander based on embedded tags and ':' delimiters
class TagExpander {
    constructor(state, ident, usedirs = false, delim = ':') {
        this.ident = ident;
        this.delim = delim;
        [ this.stem, ...this.tail ] = ident.split(delim);
        this.keys = [];
        this.values = [];

        const tags = this.tail.filter(p => getTag(state, p));
        tags.forEach(t => {
            this.keys.push(t);
            this.values.push(state.tags[t]);
        })
        const maps = this.tail.filter(p => getMapping(state, p));
        maps.forEach(m => {
            this.keys.push(m);
            this.values.push(getMappedValues(state, m));
        });
        if (usedirs) {
            const dirs = this.tail.filter(p => tagDirections.find(d => d.keys.includes(p)));
            dirs.forEach(d => {
                this.keys.push(d);
                this.values.push(tagDirections.find(t => t.keys.includes(d)).values);
            });
        }
        this.expansion = cartesianProduct(...this.values);
    }

    get expKeys() {
        return this.keys;
    }
    get expValues() {
        return this.expansion;
    }

    // get array of base idents, one for each expansion
    getExpandedIdents() {
        if (this.keys.length == 0)
            return [ this.ident ];
        return this.expansion.map(e => [ 
            this.stem, 
            ...this.tail.map(p => 
                this.keys.includes(p) ? e[this.keys.indexOf(p)] : p) 
        ].join(this.delim));
    }

    // get an expanded ident based on a single expansion
    getExpandedIdent(exp) {
        return [ this.stem, ...this.tail.map(p => 
            this.keys.includes(p) ? exp[this.keys.indexOf(p)] : p) 
            ].join(this.delim);
    }

    // return alternate join key with substitutions based on a specific expansion
    getExpandedAlt(exp, ident) {
        const [ stem, ...tail ] = ident.split(':');
        return (tail.length == 0) ? stem
            : [ stem, ...tail.map(p => 
                this.keys.includes(p) ? exp[this.keys.indexOf(p)] : p) 
            ].join(this.delim);
    }

    // return ident with substitution if available based on a specific expansion
    getSubstitutedIdent(exp, ident, index) {
        const newident = this.keys.includes(ident) ? exp[this.keys.indexOf(ident)] : ident;
        return simpleRelativeDirections.includes(ident) ? clockwiseDirections[(clockwiseDirections.indexOf(ident) + index) % 4] : newident;
    }

    // return array of (possibly expanded) idents, one for each expansion
    getExpandedAltIdents(ident) {
        const [ stem, ...tail ] = ident.split(':');
        return this.expansion.map(e =>
            (tail.length == 0) ? stem
            : [ stem, ...tail.map(p => 
                this.keys.includes(p) ? e[this.keys.indexOf(p)] : p) 
            ].join(this.delim) );
    }
}

// expand a reference to an object from legend, layers and rules (rel dirs no expanded)
function expandObjectRef(state, objid, usedirs = false) {
    const expander = new TagExpander(state, objid, usedirs);
    //if (expander.rawTags.length == 0) return [ ident ];
    return expander.getExpandedIdents();
}

// expand object defined with tags/directions into new objects
function expandObjectDef(state, objid, objvalue) {
    const expander = new TagExpander(state, objid, true);
    if (expander.keys.length == 0) return;

    const newobjects = expander.expansion.map((exp,index) => {
        const newid = expander.getExpandedIdent(exp);
        const newvalue = { 
            ...deepClone(objvalue),
            canRedef: true 
        };
        if (objvalue.cloneSprite) {
            const altspriteid = expander.getExpandedAlt(exp, objvalue.cloneSprite);
            if (state.objects[altspriteid])
                newvalue.cloneSprite = altspriteid;
            // optional?
            //else logWarning(`Sprite copy: source says ${altspriteid.toUpperCase()} but there is no such object defined.`, objvalue.lineNumber);
        } else 
            newvalue.spritematrix = objvalue.spritematrix.map(row => [ ...row ]);

        
        if (objvalue.transforms) {
            newvalue.transforms = [];
            objvalue.transforms.forEach(xform => {
                const op = xform[0];
                newvalue.transforms.push([ op, 
                    expander.getSubstitutedIdent(exp, xform[1], index),
                    (op == 'rot') ? expander.getSubstitutedIdent(exp, xform[2], index) : xform[2] ]);
            })
        }
        return [newid, newvalue];
    });
    
    return newobjects;
}

// create hierarchy of properties when property contains tags
// do it by index because names may not be unique
function createObjectTagsAsProps(state, ident) {
    const fnValues = p => getTag(state, p) || (getMapping(state, p) && getMapping(state, p).values);
    const parts = ident.split(':');
    const todos = parts.map((p,x) => ({ part: p, index: x, values: fnValues(p) }))
        .filter(t => t.values);

    // if only one part is a tag or map we're done
    if (todos.length <= 1) return;

    todos.forEach(todo => {
        todo.values.forEach(value => {
            const newident = parts.map((p,x) => x == todo.index ? value : p).join(':');
            const expander = new TagExpander(state, newident, true);
            const newlegend = [ newident, ...expander.getExpandedIdents() ];
            newlegend.lineNumber = state.lineNumber;  // bug: ?
            state.legend_properties.push(newlegend);
            createObjectTagsAsProps(state, newident);
        })
    })
}


// generate a new sprite matrix based on transforms
// translate: handled as spriteoffset, because it might go negative
function applySpriteTransforms(obj) {
    const tranfunc = {
        'flip': (obj,dir) => [
            (m => m.reverse()),
		    (m => m.map(row => row.reverse())),
        ][dir % 2](obj.spritematrix),
        'shift': (obj,dir,amt) => obj.spritematrix = [ // up right down left
            (m => [ ...m.slice(amt), ...m.slice(0, amt) ]),
            (m => m.map(r => [ ...r.slice(-amt), ...r.slice(0, -amt) ])),
            (m => [ ...m.slice(-amt), ...m.slice(0, -amt) ]),
            (m => m.map(r => [ ...r.slice(amt), ...r.slice(0, amt) ])),
        ][dir](obj.spritematrix),
        'rot': (obj,dir1,dir2) => obj.spritematrix = [
            m => m, // 0°
            m => Array.from(m[0], (ch,col) => m.map( row => row[col] ).reverse()), // 90°
            m => Array.from(m, l => l.reverse() ).reverse(), // 180°
            m => Array.from(m[0], (ch,col) => m.map( row => row[col] )).reverse() // 270°
        ][(4 + cwdIndexOf(dir2) - dir1) % 4](obj.spritematrix),
        'translate': (obj,dir,amt) => [
            (s => s.y -= amt),
            (s => s.x += amt),
            (s => s.y += amt),
            (s => s.x -= amt),
        ][dir](obj.spriteoffset),
    };

    for (const tf of obj.transforms || []) {
        tranfunc[tf[0]](obj, cwdIndexOf(tf[1]), tf[2]);
    }
}

// generate a new sprite matrix based on transforms
function applyVectorTransforms(obj) {
    const tranfunc = {
        'flip': (obj,dir) => [
            (p => p.flipy = !p.flipy),
            (p => p.flipx = !p.flipx),
        ][dir % 2](obj.vector),
        'rot': (prm,dir1,dir2) => [
            p => p, // 0°
            p => p.angle += 90,
            p => p.angle += 180,
            p => p.angle += 270,
        ][(4 + cwdIndexOf(dir2) - dir1) % 4](obj.vector),
        'translate': (obj,dir,amt) => [
            (s => s.y -= amt),
            (s => s.x += amt),
            (s => s.y += amt),
            (s => s.x -= amt),
        ][dir](obj.spriteoffset),
        'shift': (prm) => prm,
    };

    for (const tf of obj.transforms || []) {
        tranfunc[tf[0]](obj, cwdIndexOf(tf[1]), tf[2]);
    }
}

// PS> check whether a name has been used and is not available
function isAlreadyDeclared(state, ident) {
    return Object.hasOwn(state.objects, ident)
        || state.legend_synonyms.find(s => s[0] == ident)
        || state.legend_aggregates.find(s => s[0] == ident)
        || state.legend_properties.find(s => s[0] == ident)
        || Object.hasOwn(state.tags, ident)
        || Object.hasOwn(state.mappings, ident)
}

// PS> check how a name has been used if at all
function isDeclaredAs(state, ident) {
    return Object.hasOwn(state.objects, ident) ? 'object'
        : state.legend_synonyms.find(s => s[0] == ident) ? 'alias'
        : state.legend_aggregates.find(s => s[0] == ident) ? 'and'
        : state.legend_properties.find(s => s[0] == ident) ? 'or'
        : Object.hasOwn(state.tags, ident) ? 'tag' 
        : Object.hasOwn(state.mappings, ident) ? 'map' 
        : null;
}

// get the object(s) referred to if declared, or null otherwise
function getObjectRefs(state, ident) {
    if (isAlreadyDeclared(state, ident)) return [ ident ];
    const idents = expandObjectRef(state, ident, true);
    return idents.every(i => isAlreadyDeclared(state, i)) ? idents : null;
}

// get the undefined object(s) referred to
function getObjectUndefs(state, ident) {
    if (isAlreadyDeclared(state, ident)) return [ ];
    const idents = expandObjectRef(state, ident, true);
    return idents.filter(i => !isAlreadyDeclared(state, i));
}

// create a property object for an ident with parts, if possible and not already there
// but if property contains a relative direction, create one for each absolute direction
// todo: this fails if an expansion is an aggregate -- see isaac_and_mass
function createObjectRef(state, ident) {
    const ref = getObjectRefs(state, ident);
    if (ref && ref.length > 1) {
        const parts = ident.split(':');
        if (parts.some(e => relativeDirections.includes(e))) {
            if (debugSwitch.includes('exp')) console.log(`Create object ref for relative direction: ${ident}`);
            for (const forward of simpleAbsoluteDirections) { //@@
                const absOf = dir => relativeDirs.includes(dir) ? relativeDict[forward][relativeDirs.indexOf(dir)] : dir;
                const id = ident.split(':').map(p => absOf(p)).join(':');
                createObjectRef(state, id);
            }
        }
        const newlegend = [ ident, ...ref ];
        newlegend.lineNumber = state.lineNumber;  // bug: it's an array, isn't it?
        state.legend_properties.push(newlegend);
        return true;
    } else return false;
}

function isColor(str) {
	str = str.trim();
	if (str in colorPalettes.arnecolors)
		return true;
	if (/^#([0-9A-F]{2}){3,4}$/i.test(str))
		return true;
	if (/^#([0-9A-F]{3,4})$/i.test(str))
		return true;
	if (str === "transparent")
		return true;
	return false;
}

function colorToHex(palette, str) {
    str = str.trim();
    if (str in palette) {
        return palette[str];
    }

    return str;
}

var debugMode;
var colorPalette;

function generateExtraMembers(state) {

    if (state.collisionLayers.length === 0) {
        logError("No collision layers defined.  All objects need to be in collision layers.");
    }

    //annotate objects with layers
    //assign ids at the same time
    state.idDict = [];          // doc: dictionary of object names indexed by ID
    var idcount = 0;
    for (var layerIndex = 0; layerIndex < state.collisionLayers.length; layerIndex++) {
        for (var j = 0; j < state.collisionLayers[layerIndex].length; j++) {
            var n = state.collisionLayers[layerIndex][j];
            if (n in state.objects) {
                var obj = state.objects[n];
                obj.layer = layerIndex;
                obj.id = idcount;
                state.idDict[idcount] = n;
                idcount++;
            }
        }
    }

    // PS> fill in start and length of each group of objects
    let prevObjectNo = idcount;
    for (let i = state.collisionLayerGroups.length - 1; i >= 0; --i) {
        const group = state.collisionLayerGroups[i];
        group.firstObjectNo = state.objects[state.collisionLayers[group.layer][0]].id;
        group.numObjects = prevObjectNo - group.firstObjectNo;
        prevObjectNo = group.firstObjectNo;
    }

    //set object count
    state.objectCount = idcount;

    //calculate blank mask template
    var layerCount = state.collisionLayers.length;
    var blankMask = [];
    for (var i = 0; i < layerCount; i++) {
        blankMask.push(-1);
    }

    // how many words do our bitvecs need to hold?
    MOV_BITS = 8;
    MOV_MASK = 0xff;
    STRIDE_OBJ = Math.ceil(state.objectCount / 32) | 0;         // doc: size of BitVec to hold objects, at 32 bits per
    STRIDE_MOV = Math.ceil(layerCount * MOV_BITS / 32) | 0;     // doc: size of BitVec to hold directions, at 5 bits per
    state.STRIDE_OBJ = STRIDE_OBJ;
    state.STRIDE_MOV = STRIDE_MOV;

    //get colorpalette name
    debugMode = false;
    verbose_logging = false;
    throttle_movement = false;
    colorPalette = colorPalettes.arnecolors;
    for (var i = 0; i < state.metadata.length; i += 2) {
        var key = state.metadata[i];
        var val = state.metadata[i + 1];
        if (key === 'color_palette') {
            if (val in colorPalettesAliases) {
                val = colorPalettesAliases[val];
            }
            if (colorPalettes[val] === undefined) {
                logError('Palette "' + val + '" not found, defaulting to arnecolors.', 0);
            } else {
                colorPalette = colorPalettes[val];
            }
        } else if (key === 'debug' || defaultDebugMode) {
            if (IDE && unitTesting===false){
                debugMode = true;
                cache_console_messages = true;
            }
        } else if (key === 'verbose_logging' || defaultVerboseLogging) {
            if (IDE && unitTesting===false){
                verbose_logging = true;
                cache_console_messages = true;
            }
        } else if (key === 'throttle_movement') {
            throttle_movement = true;
        }
    }

    // fix and convert colors to hex
    const maxColours = 36; // now 0-9 and a-z
    for (const obj of Object.values(state.objects)) {
        if (obj.vector) {
            if (obj.colors.length > 0)
                logWarning(`Please don't define colors for vector sprites. They're just going to get ignored anyway.`, obj.lineNumber + 1);
        } else if (obj.colors.length == 0) {
            logWarning(`A sprite must have at least one color. However did this happen?`, obj.lineNumber + 1);
            obj.colors.push('#ff00ff');
        } else if (obj.colors.length > maxColours) {
            logError(`A sprite cannot have more than ${maxColours} colors.  Why you would want more than ${maxColours} is beyond me.`, obj.lineNumber + 1);
        }
        for (let i = 0; i < obj.colors.length; i++) {
            let c = obj.colors[i];
            if (isColor(c)) {
                c = colorToHex(colorPalette, c);
                obj.colors[i] = c;
            } else {
                logError(`Invalid color specified for object "${n}", namely ${obj.colors[i]}".`, obj.lineNumber + 1);
                obj.colors[i] = '#ff00ff'; // magenta error color
            }
        }
    }

    // fix up what we can of sprite stuff here.
    // spriteoffset is needed to handle translate with negative args
    // transform on canvas has to be left until later
    for (const [key, obj] of Object.entries(state.objects)) {
        obj.spriteoffset = { x: 0, y: 0 };
        if (obj.vector) {
            obj.vector.angle ||= 0;
            if (obj.cloneSprite) {
                const other = state.objects[obj.cloneSprite];
                obj.vector = { ...other.vector };
                obj.spriteoffset = { ...other.spriteoffset };
            } 
            applyVectorTransforms(obj);

        } else {
            if (obj.cloneSprite) {
                const other = state.objects[obj.cloneSprite];
                obj.spritematrix = other.spritematrix.map(row => [...row]);
                obj.spriteoffset = { ...other.spriteoffset };
            } 
            if (obj.spritematrix.length == 0) {
                obj.spritematrix = Array.from(
                    { length: state.sprite_size },
                    () => (new Array(state.sprite_size).fill(0))
                );
            }
            applySpriteTransforms(obj);
        }
    }

    if (debugSwitch.includes('obj')) console.log('Objects', state.objects);
    if (debugSwitch.includes('obj')) console.log('Properties', state.legend_properties);
    if (debugSwitch.includes('obj')) console.log('Aggregates', state.legend_aggregates);
    if (debugSwitch.includes('obj')) console.log('Synonyms', state.legend_synonyms);

    var glyphOrder = [];
    //calculate glyph dictionary
    var glyphDict = {};
    for (var n in state.objects) {
        if (state.objects.hasOwnProperty(n)) {
            var obj = state.objects[n];
            var mask = blankMask.concat([]);
            mask[obj.layer] = obj.id;
            glyphDict[n] = mask;
            glyphOrder.push([obj.lineNumber,n]);
        }
    }
    
    var added = true;
    while (added) 
    {
        added = false;

        //then, synonyms
        for (var i = 0; i < state.legend_synonyms.length; i++) {
            var dat = state.legend_synonyms[i];
            var key = dat[0];
            var val = dat[1];
            if ((!(key in glyphDict) || (glyphDict[key] === undefined)) && (glyphDict[val] !== undefined)) {
                added = true;
                glyphDict[key] = glyphDict[val];
                glyphOrder.push([dat.lineNumber,key]);
            } 
            }

        //then, aggregates
        for (var i = 0; i < state.legend_aggregates.length; i++) {
            var dat = state.legend_aggregates[i];
            var key = dat[0];
            var vals = dat.slice(1);
            var allVallsFound = true;
            for (var j = 0; j < vals.length; j++) {
                var v = vals[j];
                if (glyphDict[v] === undefined) {
                    allVallsFound = false;
                    break;
                }
            }
            if ((!(key in glyphDict) || (glyphDict[key] === undefined)) && allVallsFound) {
                var mask = blankMask.concat([]);

                for (var j = 1; j < dat.length; j++) {
                    var n = dat[j];
                    var obj = state.objects[n];
                    if (obj == undefined) {
                        logError('Object not found with name ' + n, state.lineNumber);
                    }
                    if (mask[obj.layer] == -1) {
                        mask[obj.layer] = obj.id;
                    } else {
                        if (obj.layer === undefined) {
                            logError('Object "' + n.toUpperCase() + '" has been defined, but not assigned to a layer.', dat.lineNumber);
                        } else {
                            var n1 = n.toUpperCase();
                            var n2 = state.idDict[mask[obj.layer]].toUpperCase();
                            // if (n1 !== n2) {
                                logError(
                                    'Trying to create an aggregate object (something defined in the LEGEND section using AND) with both "' +
                                    n1 + '" and "' + n2 + '", which are on the same layer and therefore can\'t coexist.',
                                    dat.lineNumber
                                );
                            // }
                            }
                        }
                    }
                added = true;
                glyphDict[dat[0]] = mask;
                glyphOrder.push([dat.lineNumber,key]);
            }
        }
    }
    
    //sort glyphs line number
    glyphOrder.sort((a,b)=>a[0] - b[0]);
    glyphOrder = glyphOrder.map(a=>a[1]);

    state.glyphDict = glyphDict;
    state.glyphOrder = glyphOrder;

    var aggregatesDict = {};
    for (var i = 0; i < state.legend_aggregates.length; i++) {
        var entry = state.legend_aggregates[i];
        aggregatesDict[entry[0]] = entry.slice(1);
    }
    state.aggregatesDict = aggregatesDict;

    var propertiesDict = {};
    for (var i = 0; i < state.legend_properties.length; i++) {
        var entry = state.legend_properties[i];
        propertiesDict[entry[0]] = entry.slice(1);
    }
    state.propertiesDict = propertiesDict;

    //calculate lookup dictionaries
    var synonymsDict = {};
    for (var i = 0; i < state.legend_synonyms.length; i++) {
        var entry = state.legend_synonyms[i];
        var key = entry[0];
        var value = entry[1];
        if (value in aggregatesDict) {
            aggregatesDict[key] = aggregatesDict[value];
        } else if (value in propertiesDict) {
            propertiesDict[key] = propertiesDict[value];
        } else if (key !== value) {
            synonymsDict[key] = value;
        }
    }
    state.synonymsDict = synonymsDict;

    var modified = true;
    while (modified) {
        modified = false;
        for (var n in synonymsDict) {
            if (synonymsDict.hasOwnProperty(n)) {
                var value = synonymsDict[n];
                if (value in propertiesDict) {
                    delete synonymsDict[n];
                    propertiesDict[n] = propertiesDict[value];
                    modified = true;
                } else if (value in aggregatesDict) {
                    delete aggregatesDict[n];
                    aggregatesDict[n] = aggregatesDict[value];
                    modified = true;
                } else if (value in synonymsDict) {
                    synonymsDict[n] = synonymsDict[value];
                }
            }
        }

        for (var n in propertiesDict) {
            if (propertiesDict.hasOwnProperty(n)) {
                var values = propertiesDict[n];
                for (var i = 0; i < values.length; i++) {
                    var value = values[i];
                    if (value in synonymsDict) {
                        values[i] = synonymsDict[value];
                        modified = true;
                    } else if (value in propertiesDict) {
                        values.splice(i, 1);
                        var newvalues = propertiesDict[value];
                        for (var j = 0; j < newvalues.length; j++) {
                            var newvalue = newvalues[j];
                            if (values.indexOf(newvalue) === -1) {
                                values.push(newvalue);
                            }
                        }
                        modified = true;
                    }
                    if (value in aggregatesDict) {
                        logError('Trying to define property "' + n.toUpperCase() + '" in terms of aggregate "' + value.toUpperCase() + '".');
                    }
                }
            }
        }


        for (var n in aggregatesDict) {
            if (aggregatesDict.hasOwnProperty(n)) {
                var values = aggregatesDict[n];
                for (var i = 0; i < values.length; i++) {
                    var value = values[i];
                    if (value in synonymsDict) {
                        values[i] = synonymsDict[value];
                        modified = true;
                    } else if (value in aggregatesDict) {
                        values.splice(i, 1);
                        var newvalues = aggregatesDict[value];
                        for (var j = 0; j < newvalues.length; j++) {
                            var newvalue = newvalues[j];
                            if (values.indexOf(newvalue) === -1) {
                                values.push(newvalue);
                            }
                        }
                        modified = true;
                    }
                    if (value in propertiesDict) {
                        logError('Trying to define aggregate "' + n.toUpperCase() + '" in terms of property "' + value.toUpperCase() + '".');
                    }
                }
            }
        }
    }

    /* determine which properties specify objects all on one layer */
    state.propertiesSingleLayer = {};
    for (var key in propertiesDict) {
        if (propertiesDict.hasOwnProperty(key)) {
            var values = propertiesDict[key];
            var sameLayer = true;
            for (var i = 1; i < values.length; i++) {
                // dies here if previous error
                if ((state.objects[values[i - 1]].layer !== state.objects[values[i]].layer)) { 
                    sameLayer = false;
                    break;
                }
            }
            if (sameLayer) {
                state.propertiesSingleLayer[key] = state.objects[values[0]].layer;
            }
        }
    }

    if (state.idDict[0] === undefined && state.collisionLayers.length > 0) {
        logError('You need to have some objects defined');
    }

    //set default background object
    var backgroundid;
    var backgroundlayer;
    if (state.objects.background === undefined) {
        if ('background' in state.synonymsDict) {
            var n = state.synonymsDict['background'];
            var obj = state.objects[n];
            backgroundid = obj.id;
            backgroundlayer = obj.layer;
        } else if ('background' in state.propertiesDict) {
            var backgrounddef = state.propertiesDict['background'];
            var n = backgrounddef[0];
            var obj = state.objects[n];
            backgroundid = obj.id;
            backgroundlayer = obj.layer;
            for (var i=1;i<backgrounddef.length;i++){
                var nnew = backgrounddef[i];
                var onew = state.objects[nnew];
                if (onew.layer !== backgroundlayer) {
                    var lineNumber = state.original_line_numbers['background'];
                    logError('Background objects must be on the same layer',lineNumber);
                }
            }
        } else if ('background' in state.aggregatesDict) {
            var obj = state.objects[state.idDict[0]];
            backgroundid = obj.id;
            backgroundlayer = obj.layer;
            var lineNumber = state.original_line_numbers['background'];
            logError("background cannot be an aggregate (declared with 'and'), it has to be a simple type, or property (declared in terms of others using 'or').",lineNumber);
        } else {
            var obj = state.objects[state.idDict[0]];
            if (obj!=null){
                backgroundid = obj.id;
                backgroundlayer = obj.layer;
            }
            logError("you have to define something to be the background");
        }
    } else {
        backgroundid = state.objects.background.id;
        backgroundlayer = state.objects.background.layer;
    }
    state.backgroundid = backgroundid;
    state.backgroundlayer = backgroundlayer;
}

function generateExtraMembersPart2(state) {
	function assignMouseObject(preludeTerm, defaultName) {
		if (preludeTerm in state.metadata) {
			var name = state.metadata[preludeTerm] || defaultName;
            var id = null;
            var object = null;
			if (state.objects[name]) {
                id = state.objects[name].id;
                object = state.objects[name];
			} else {
				if (name in state.synonymsDict) {
					var n = state.synonymsDict[name];
					var o = state.objects[n];
                    id = o.id;
                    object = o;
				} else {
					var o=state.objects[state.idDict[1]];
					id=o.id;
					logError(name + " object/alias has to be defined");
				}
            }
            
            if (object != null && object.layer !== undefined) {
                var layerID = object.layer;
                if (state.collisionLayers[layerID].length != 1) {
                    logWarningNoLine("Mouse object '"+name+"' (for input '"+ preludeTerm +"') could overlap with other objects on the same layer. Consider moving the object to its own layer.", true, false);
                }
            }

			return id;
		}
	}
	
	state.lmbID = assignMouseObject("mouse_left", "lmb");
	state.rmbID = assignMouseObject("mouse_right", "rmb");
	state.dragID = assignMouseObject("mouse_drag", "drag");
	state.rdragID = assignMouseObject("mouse_rdrag", "rdrag");
	state.lmbupID = assignMouseObject("mouse_up", "lmbup");
	state.rmbupID = assignMouseObject("mouse_rup", "rmbup");
	
	if ("mouse_obstacle" in state.metadata) {
		var name = state.metadata["mouse_obstacle"];
		
		if (name) {
			state.obstacleMask = state.objectMasks[name];
			if (!state.obstacleMask) {
				logError(name + " object/alias has to be defined.");
				state.obstacleMask = state.objectMasks["background"];
			}
		}
	}
}

Level.prototype.calcBackgroundMask = function(state) {
    if (state.backgroundlayer === undefined) {
        logError("you have to have a background layer");
    }

    var backgroundMask = state.layerMasks[state.backgroundlayer];
    for (var i = 0; i < this.n_tiles; i++) {
        var cell = this.getCell(i);
        cell.iand(backgroundMask);
        if (!cell.iszero()) {
            return cell;
        }
    }
    cell = new BitVec(STRIDE_OBJ);
    cell.ibitset(state.backgroundid);
    return cell;
}

function levelFromString(state,level) {
	var backgroundlayer=state.backgroundlayer;
	//var backgroundid=state.backgroundid;
	var backgroundLayerMask = state.layerMasks[backgroundlayer];

    // pad all lines to same length
    //const width = level[2].reduce((a, b) => Math.max(a, b), 0);
    //level[2] = level[2].map(l => l.padEnd(width, '.'));

	var o = new Level(level[0], level[2].length, level.length-2, state.collisionLayers.length, null, level[1]);
	o.objects = new Int32Array(o.width * o.height * STRIDE_OBJ);

	for (var i = 0; i < o.width; i++) {
		for (var j = 0; j < o.height; j++) {
			var ch = level[j+2].charAt(i);
			if (ch.length==0) {
				ch=level[j+2].charAt(level[j+2].length-1);
			}
			var mask = state.glyphDict[ch];

			if (mask == undefined) {
				if (state.propertiesDict[ch]===undefined) {
					logError('Error, symbol "' + ch + '", used in map, not found.', level[0]+j);
				} else {
                    logError('Error, symbol "' + ch + '" is defined using OR, and therefore ambiguous - it cannot be used in a map. Did you mean to define it in terms of AND?', level[0] + j);
				}
                return o;
			}

			var maskint = new BitVec(STRIDE_OBJ);
			mask = mask.concat([]);					
			for (var z = 0; z < o.layerCount; z++) {
				if (mask[z]>=0) {
					maskint.ibitset(mask[z]);
				}
			}
			for (var w = 0; w < STRIDE_OBJ; ++w) {
				o.objects[STRIDE_OBJ * (i * o.height + j) + w] = maskint.data[w];
			}
		}
	}

	var levelBackgroundMask = o.calcBackgroundMask(state);
	for (var i=0;i<o.n_tiles;i++)
	{
		var cell = o.getCell(i);
		if (!backgroundLayerMask.anyBitsInCommon(cell)) {
			cell.ior(levelBackgroundMask);
			o.setCell(i, cell);
		}
	}
	return o;
}
//also assigns glyphDict
function levelsToArray(state) {
	const levels = [];
    const links = [];
    //const links = {};
    //const targets = new Set();
    let section, title, description, gotoFlag;
    
    if (state.levels.at(-1).length == 0)
        state.levels.pop();

    let levelNo = 1;
    // compile each level command
    // parse: state.levels.push([ symbols.start, symbols.text, state.lineNumber, symbols.link ]);
    state.levels.forEach(level => {
        title ||= `Level ${levelNo}`;
		if (level[0] == 'message') {
            if (gotoFlag) logWarning('Message unreachable due to previous GOTO.', level[2]);
            const wrapTest = wordwrap(level[1], 35);  // todo: 35
            if (wrapTest.length > 12)       // todo: 12
                logWarning('Message too long to fit on screen.', level[2]);
            levels.push({
                message: level[1],
				lineNumber: level[2],
				section: section
			});
		} else if (level[0] == 'goto') {
            if (gotoFlag) logWarning('GOTO unreachable due to previous GOTO.', level[2]);
            levels.push( {
                target: level[1],           // text, will be converted to index later
				lineNumber: level[2],
				section: section
			});
            gotoFlag = true;
		} else if (level[0] == 'section') {
            section = level[1];
            gotoFlag = false;
		} else if (level[0] == 'level') {
            title = level[1];           // !!!
		} else if (level[0] == 'title') {
            description = level[1];     // todo: 
            logWarning(`Option TITLE is not implemented, but may be in the future. Let me know if you really need it.`,state.lineNumber);
		} else if (level[0] == 'link') {
            links.push( {             // text, will be converted to index later
                target: level[1],
				lineNumber: level[2],
                object: level[3]
            });
		} else {
            if (gotoFlag && links.length == 0) 
                logWarning('Level unreachable due to previous GOTO.', level[0]);
            level[1] = section; // todo: fix it
			levels.push(levelFromString(state, level));
            levels.at(-1).title = title;
            levels.at(-1).linksTop = links.length;
            ++levelNo;
            title = null;
		}
	});
    links.forEach(link => { //@@
        let index = -9999;
        if ((index = levels.findIndex(level => link.target == level.section)) != -1)
            link.targetNo = index;
        else if ((index = levels.findIndex(level => link.target == level.title)) != -1)
            link.targetNo = -1-index;
        else {
            logError(`Sorry, link target "${link.target.toUpperCase()}" does not seem to be the name of any level.`, link.lineNumber);
            link.targetNo = -9999;
        }
    });
	state.levels = levels;
	state.links = links;
}

function extractSections(state) {
	var sections = [];

	var lastSection = null;

	for(var i = 0; i < state.levels.length; i++) {
		var level = state.levels[i];
		
		if(level.section != lastSection) {
			var o = {
				name: level.section,
				firstLevel: i
			};
			if(o.name == "__WIN__") {
				state.winSection = o;
			} else {
				sections.push(o);
			}
			
			lastSection = level.section;
		}
	}

	state.sections = sections;
}

function convertSectionNamesToIndices(state) {
	var sectionMap = {};
	var duplicateSections = {};
	for (var s = 0; s < state.sections.length; s++) {
		var sectionName = state.sections[s].name.toLowerCase();
		if(sectionMap[sectionName] === undefined){
			sectionMap[sectionName] = s;
		}else{
			duplicateSections[sectionName] = true;
		}
	}
	
	// GOTO commands in the RULES
    // todo: GOTO level or section
	for (var r = 0; r < state.rules.length; r++) {
		var rule = state.rules[r];
		for (var c = 0; c < rule.commands.length; c++) {
			var command = rule.commands[c];
			if (command[0] != 'goto') continue;
            
            if ( typeof command[1] == "number") {continue;} //Variant rule was previously converted into an index PS+#105
			var sectionName = command[1].toLowerCase();
			var sectionIndex = sectionMap[sectionName];
			if (sectionIndex === undefined){
				logError(`Invalid GOTO command - there is no section named "${command[1]}". Either it does not exist, or it has zero levels.`, rule.lineNumber);
				//logError('Invalid GOTO command - There is no section named "'+command[1]+'". Either it does not exist, or it has zero levels.', rule.lineNumber);
				sectionIndex = -9999;
			}else if (duplicateSections[sectionName] !== undefined){
				logError(`Invalid GOTO command - there are multiple sections named "${command[1]}". Section names must be unique for GOTO to work.`, rule.lineNumber);
				sectionIndex = -9999;
			}
			command[1] = sectionIndex;
		}
	}
	
	// GOTO commands in the LEVELS
	for (var i = 0; i < state.levels.length; i++) {
		var level = state.levels[i];
		if (level.target === undefined) continue; // This was a level or a message, but not a goto.
		var targetName = level.target.toLowerCase();
		var targetIndex = sectionMap[targetName];
		if (targetIndex === undefined){
			logError(`Invalid GOTO command - there is no section named "${command[1]}".`, level.lineNumber);
			targetIndex = 0;
		}else if (duplicateSections[targetName] !== undefined){
			logError(`Invalid GOTO command - there are multiple sections named "${command[1]}".`, level.lineNumber);
			targetIndex = 0;
		}
		level.target = targetIndex;
	}
}

// fix gosubs and subroutines to use group number (so must be after created groups)
function fixUpGosubs(state) { // PS>
    const subroutines = state.subroutines;
    const rules = state.rules;
    // first fixup subroutines so we know which group to gosub to
    let rulex = 0;
    for (const subroutine of subroutines) {
        while (rules[rulex][0].lineNumber < subroutine.lineNumber)
            rulex++;
        subroutine.groupNumber = rulex;
    }

    // rules are now groups. Go figure.
    for (const group of state.rules) {
        for (const rule of group) {
            for (const cmd of rule.commands) {
                if (cmd[0] == 'gosub' && typeof cmd[1] == "string") {       // the vagaries of the parse means this fixup may already have been done
                    const subroutine = state.subroutines.find(s => s.label == cmd[1].toLowerCase());
                    if (!subroutine) 
                        logError(`Invalid GOSUB command - there is no subroutine named "${cmd[1]}".`, rule.lineNumber);
                    else cmd[1] = subroutine.groupNumber;   // replace name by linenumber
                }
            }
        }
    }
}

// return true if this is a directional rule
function directionalRule(rule) {
    for (const row of [ ...rule.lhs, ...rule.rhs ]) {
        if (row.length > 1)
            return true;
        for (const cell of row) {
            for (var k = 0; k < cell.length; k += 2) {
                if (relativeDirections.includes(cell[k]))
                    return true;
                if (cell[k + 1].split(':').some(p => relativeDirections.includes(p)))
                    return true;
            }
        }
    }
    return false;
}

function findIndexAfterToken(str, tokens, tokenIndex) {
    str = str.toLowerCase();
    var curIndex = 0;
    for (var i = 0; i <= tokenIndex; i++) {
        var token = tokens[i];
        curIndex = str.indexOf(token, curIndex) + token.length;
    }
    return curIndex;
}
function rightBracketToRightOf(tokens,i){
    for(;i<tokens.length;i++){
        if (tokens[i]==="]"){
            return true;
        }
    }
    return false;
}

function processRuleString(rule, state, curRules) {
    /*

    	intermediate structure
    		dirs: Directions[]
    		pre : CellMask[]
    		post : CellMask[]

    		//pre/post pairs must have same lengths
    	final rule structure
    		dir: Direction
    		pre : CellMask[]
    		post : CellMask[]
    */
    var line = rule[0];
    var lineNumber = rule[1];
    var origLine = rule[2];

    // STEP ONE, TOKENIZE
    line = line.replace(/\[/g, ' [ ').replace(/\]/g, ' ] ').replace(/\|/g, ' | ').replace(/\-\>/g, ' -> ');
    line = line.trim();
    if (line[0] === '+') {
        line = line.substring(0, 1) + " " + line.substring(1, line.length);
    }
    var tokens = line.split(/\s/).filter(function(v) { return v !== '' });

    if (tokens.length == 0) {
        logError('Spooky error!  Empty line passed to rule function.', lineNumber);
    }


// STEP TWO, READ DIRECTIONS
/*
	STATE
	0 - scanning for initial directions
	LHS
	1 - reading cell contents LHS
	2 - reading cell contents RHS
*/
    var parsestate = 0;
    var directions = [];

    var curcell = null; // [up, cat, down mouse]
    var curcellrow = []; // [  [up, cat]  [ down, mouse ] ]

    var incellrow = false;

    var rhs = false;
    var lhs_cells = [];
    var rhs_cells = [];
    var late = false;
    var rigid = false;
    var groupNumber = lineNumber;
    var commands = [];
    var randomRule = false;
    var has_plus = false;
    var globalRule = false;
    let isOnce = false;
    const prefixes = [];

    if (tokens.length===1) {
        if (tokens[0]==="startloop" ) {
            rule_line = {
                bracket: 1
            }
            return rule_line;
        } else if (tokens[0]==="endloop" ) {
            rule_line = {
                bracket: -1
            }
            return rule_line;
        }
    }

    if (tokens[0] == 'subroutine') {   // PS>
        return {
            label: tokens.slice(1).join(' ').toLowerCase(),
            lineNumber: lineNumber
        }
    }

    if (tokens.indexOf('->') == -1) {
        logError("A rule has to have an arrow in it. There's no arrow here! Consider reading up about rules - you're clearly doing something weird", lineNumber);
    }

    var curcell = [];
    var bracketbalance = 0;
    for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        switch (parsestate) {
            case 0:
                {
                    //read initial directions
                    if (token === '+') {
                        has_plus=true;
                        if (groupNumber === lineNumber) {
                            if (curRules.length == 0) {
                                logError('The "+" symbol, for joining a rule with the group of the previous rule, needs a previous rule to be applied to.', lineNumber);
                            }
                            if (i !== 0) {
                                logError('The "+" symbol, for joining a rule with the group of the previous rule, must be the first symbol on the line ', lineNumber);
                            }
                            groupNumber = curRules[curRules.length - 1].groupNumber;
                        } else {
                            logError('Two "+"s (the "append to previous rule group" symbol) applied to the same rule.', lineNumber);
                        }
                    } else if (token in directionaggregates) {
                        directions = directions.concat(directionaggregates[token]);
                    } else if (token === 'late') {
                        late = true;                        
                    } else if (token === 'rigid') {
                        rigid = true;
                    } else if (token === 'random') {
                        randomRule = true;
                        if (has_plus) {
                            logError(`A rule-group can only be marked random by the opening rule in the group (aka, a '+' and 'random' can't appear as rule modifiers on the same line).  Why? Well, you see "random" isn't a property of individual rules, but of whole rule groups.  It indicates that a single possible application of some rule from the whole group should be applied at random.`, lineNumber) 
                        }
                    } else if (token == 'global') {
                        globalRule = true;
                    } else if (token == 'once') {
                        isOnce = true;
                    } else if (simpleAbsoluteDirections.indexOf(token) >= 0) {
                        directions.push(token);
                    } else if (simpleRelativeDirections.indexOf(token) >= 0) {
                        logError('You cannot use relative directions (\"^v<>\") to indicate in which direction(s) a rule applies.  Use absolute directions indicators (Up, Down, Left, Right, Horizontal, or Vertical, for instance), or, if you want the rule to apply in all four directions, do not specify directions', lineNumber);
                    } else if (getTag(state, token)) {
                        prefixes.push(token);
                    } else if (token == '[') {
                        if (directions.length == 0) {
                            directions = directions.concat(directionaggregates['orthogonal']);
                        }
                        parsestate = 1;
                        i--;
                    } else {
                        logError("The start of a rule must consist of some number of directions (possibly 0), before the first bracket, specifying in what directions to look (with no direction specified, it applies in all four directions).  It seems you've just entered \"" + token.toUpperCase() + '\".', lineNumber);
                    }
                break;
            }
            case 1:
                {                                        
            if (token == '[') {
                bracketbalance++;
                if(bracketbalance>1){
                    logWarning("Multiple opening brackets without closing brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.", lineNumber);
                }
                if (curcell.length > 0) {
                    logError('Error, malformed cell rule - encountered a "["" before previous bracket was closed', lineNumber);
                }
                incellrow = true;
                curcell = [];
            } else if (directions_only.includes(token)) {
                if (curcell.length % 2 == 1) {
                    logError("Error, an item can only have one direction/action at a time, but you're looking for several at once!", lineNumber);
                } else if (!incellrow) {
                    logWarning("Invalid syntax. Directions should be placed at the start of a rule.", lineNumber);
                } else if (late && token!=='no' && token!=='random' && token!=='randomdir') {
                    logError("Movements cannot appear in late rules.", lineNumber);
                  } else {
                    curcell.push(token);
                }
            } else if (token == '|') {
                if (!incellrow) {
                    logWarning('Janky syntax.  "|" should only be used inside cell rows (the square brackety bits).',lineNumber);
                } else if (curcell.length % 2 == 1) {
                    logError('In a rule, if you specify a movement, it has to act on an object.', lineNumber);
                } else {
                    curcellrow.push(curcell);
                    curcell = [];
                }
            } else if (token === ']') {
                bracketbalance--;
                if(bracketbalance<0){
                    logWarning("Multiple closing brackets without corresponding opening brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.", lineNumber);
                }

                if (curcell.length % 2 == 1) {
                    if (curcell[0]==='...') {
                        logError('Cannot end a rule with ellipses.', lineNumber);
                    } else {
                        logError('In a rule, if you specify a movement, it has to act on an object.', lineNumber);
                    }
                } else {
                    curcellrow.push(curcell);
                    curcell = [];
                }

                if (rhs) {
                    rhs_cells.push(curcellrow);
                } else {
                    lhs_cells.push(curcellrow);
                }
                curcellrow = [];
                incellrow = false;
            } else if (token === '->') {
                if (groupNumber !== lineNumber) {
                    var parentrule = curRules[curRules.length - 1];
                    if (parentrule.late!==late){
                        logWarning('Oh gosh you can mix late and non-late rules in a rule-group if you really want to, but gosh why would you want to do that?  What do you expect to accomplish?', lineNumber);
                    }
                }
                if (incellrow) {
                    logError('Encountered an unexpected "->" inside square brackets.  It\'s used to separate states, it has no place inside them >:| .', lineNumber);
                } else if (rhs) {
                    logError('Error, you can only use "->" once in a rule; it\'s used to separate before and after states.', lineNumber);
                }  else {
                    rhs = true;
                }
            } else if (isAlreadyDeclared(state, token) || createObjectRef(state, token)) { // @@
                // it's either a known object name or a name that might need expanding but definitely not a command (need a better way...)
                if (!incellrow) {
                    logWarning("Invalid token "+token.toUpperCase() +". Object names should only be used within cells (square brackets).", lineNumber);
                } else if (curcell.length % 2 == 0) {
                    curcell.push('');
                    curcell.push(token);
                } else if (curcell.length % 2 == 1) {
                    curcell.push(token);
                }
            } else if (token==='...') {
                if (!incellrow) {
                     logWarning("Invalid syntax, ellipses should only be used within cells (square brackets).", lineNumber);
                 } else {
                     curcell.push(token);
                     curcell.push(token);
                 }
            } else if (token.match(reg_commandwords)) {
                if (rhs===false) {
                    logError("Commands should only appear at the end of rules, not in or before the pattern-detection/-replacement sections.", lineNumber);
                } else if (incellrow) {//only a warning for legacy support reasons.
                //} else if (incellrow || rightBracketToRightOf(tokens,i)){//only a warning for legacy support reasons.
                    logWarning("Commands should only appear at the end of rules, not in or before the pattern-detection/-replacement sections.", lineNumber);
                }
                const tok = token.toLowerCase();
                const needarg = commandargs_table.includes(tok);
                const twid = twiddleable_params.includes(tok);
                if (needarg || twid) {
                    if (twid && !state.metadata.includes('runtime_metadata_twiddling')) {
                        logError("You can only change a flag at runtime if you have the 'runtime_metadata_twiddling' prelude flag defined!",lineNumber)
                    } else {
                        const index = findIndexAfterToken(origLine,tokens,i);
                        const str = origLine.substring(index).trim();
                        if (twid && str == "")
                            logError('You included a twiddleable option, but did not specify a value. The twiddle may behave strangely. Please use "set", "default", "wipe", or specify the correct value. See the documentation for more info.', lineNumber);
                        //needs to be nonempty or the system gets confused and thinks it's a whole level message rather than an interstitial.
                        commands.push([tok, str == "" ? " " : str]);
                    }
                    i=tokens.length;
                }  else {
                    commands.push([tok]);
                }
                        } else {
                logError('Error, malformed cell rule - was looking for cell contents, but found "' + token + '".  What am I supposed to do with this, eh, please tell me that.', lineNumber);
            }
        }

    }
}

    if (late && rigid){
        logError("Late rules cannot be marked as rigid (rigid rules are all about dealing with the consequences of unresolvable movements, and late rules can't even have movements).", lineNumber);
    }
    
    if (lhs_cells.length != rhs_cells.length) {
        if (commands.length > 0 && rhs_cells.length == 0) {
        //ok
    } else {
        logError('Error, when specifying a rule, the number of matches (square bracketed bits) on the left hand side of the arrow must equal the number on the right', lineNumber);
    }
} else {
    for (var i = 0; i < lhs_cells.length; i++) {
        if (lhs_cells[i].length != rhs_cells[i].length) {
            logError('In a rule, each pattern to match on the left must have a corresponding pattern on the right of equal length (number of cells).', lineNumber);
            state.invalid=true;
        }
        if (lhs_cells[i].length == 0) {
            logError("You have an totally empty pattern on the left-hand side.  This will match *everything*.  You certainly don't want this.");
        }
    }
}

if (lhs_cells.length == 0) {
    logError('This rule refers to nothing.  What the heck? :O', lineNumber);
}

var rule_line = {
    directions: directions,
    lhs: lhs_cells,
    rhs: rhs_cells,
    lineNumber: lineNumber,
    late: late,
    rigid: rigid,
    groupNumber: groupNumber,
    commands: commands,
    randomRule: randomRule,
    globalRule: globalRule,
    isOnce: isOnce,
    prefixes: prefixes,
};

    if (directionalRule(rule_line) === false && rule_line.directions.length>1) {
        rule_line.directions.splice(1);
    }

//next up - replace relative directions with absolute direction

return rule_line;
}

// function is passed a cell which we may modify
function deepCloneHS(HS, fn) {
    return HS.map(row => row.map(cell => fn ? fn(cell) : [ ...cell ]));
}

function deepCloneRule(rule, fnlhs, fnrhs) {
	return {
		lineNumber: rule.lineNumber,
		direction: rule.direction,
		lhs: deepCloneHS(rule.lhs, fnlhs),
		rhs: deepCloneHS(rule.rhs, fnrhs),
		late: rule.late,
		rigid: rule.rigid,
		groupNumber: rule.groupNumber,
		commands:rule.commands,
		randomRule:rule.randomRule,
		globalRule:rule.globalRule,
        isOnce: rule.isOnce,
	};
}

// make multiple passes to parse and expand rules, with absolute directions and objects
function rulesToArray(state) {
    let rules = parseRulesToArray(state);
    rules = expandRulesWithPrefixes(state, rules);
    rules = expandRulesWithMultipleDirections(state, rules);
    for (const rule of rules)
        convertRelativeDirsToAbsolute(state, rule);
    rules = expandRulesWithTags(state, rules);
    checkRuleObjects(state, rules);
    rules = expandRulesWithMultiDirectionObjects(state, rules);
    for (const rule of rules) {
        if (!debugSwitch.includes('noul')) rewriteUpLeftRules(rule);
        atomizeAggregates(state, rule);
        if (state.invalid) return; // protect next from crash
        rephraseSynonyms(state, rule);
    }
    rules = convertObjectsAndDirections(state, rules);
    state.rules = rules;
}

// find and filter out start and end loop, subroutines PS>
function parseRulesToArray(state) {
    const oldrules = state.rules;
    var newrules = [];
    var loops = [];
    var subroutines = [];
    for (var i = 0; i < oldrules.length; i++) {
        var lineNumber = oldrules[i][1];
        var newrule = processRuleString(oldrules[i], state, newrules);
        if (newrule.bracket) {
            loops.push([lineNumber, newrule.bracket]);
        } else if (newrule.label) {      // PS>
            const other = subroutines.find(s => s.label == newrule.label);
            if (other)
                logError(`Duplicate subroutine, "${newrule.label}" already defined at line ${other.lineNumber}`, newrule.lineNumber);
            else {
                // target for gosub is next groupno, or next lineno if none
                subroutines.push({
                    label: newrule.label,
                    lineNumber: newrule.lineNumber,
                });
            }
        } else newrules.push(newrule);
    }
    state.loops = loops;
    state.subroutines = subroutines;
    if (debugSwitch.includes('exp')) console.log(`parseRulesToArray ${newrules.length}`);
    return newrules;
}

// PS> expand rules with prefixes
// for every prefix.id found in a cell, clone the entire rule once for every prefix.member
// dirs [ again_col ] [ con:dirs:offs ] -> [ again_col ] [ con:dirs ]
function expandRulesWithPrefixes(state, rules) {
    const newrules = rules.map(r => expandRuleWithPrefixes(state, r)).flat();
    if (debugSwitch.includes('exp')) console.log(`expandRulesWithPrefixes ${rules.length} -> ${newrules.length}`);
    return newrules;
}

function expandRuleWithPrefixes(state, rule) {
    if (rule.prefixes.length == 0) return [ rule ];
    var newrules = [];
    const cartesian = cartesianProduct(...rule.prefixes.map(p => state.tags[p]));
    for (const exp of cartesian) {
        const fn = cell => cell.map((atom,atomx) => (atomx % 2 == 0) ? atom
            : replaceObjectPrefix(state, atom, rule.prefixes, exp));
        const newrule = deepCloneRule(rule, fn, fn);
        newrule.directions = rule.directions; // not expanded yet
        newrules.push(newrule);
    }
    return newrules;
}

// function to be used during deep clone rule
// note: will fail badly if map and tag are not a match, so check beforehand!
function replaceObjectPrefix(state, objid, prefixes, exp) {
    // in each could be any prefix and we need to find which one
    const fnGetTag = p => prefixes.includes(p) && exp[prefixes.indexOf(p)];
    const fnGetMap = p => {
        const pref = prefixes.find(x => canMapValue(state, p, x));
        return pref && getMappedValue(state, p, exp[prefixes.indexOf(pref)]);
    };

    return objid.split(':')
        .map(p => fnGetTag(p) || fnGetMap(p) || p)
        .join(':');
}

// expand rules with tags (that are not properties)
// [ con:dirs:offs ] -> [ con:up:up ] etc x16
function expandRulesWithTags(state, rules) {
    const newrules = rules.map(r => expandRuleWithTags(state, r)).flat();
    if (debugSwitch.includes('exp')) console.log(`expandRulesWithTags ${rules.length} -> ${newrules.length}`);
    return newrules;
}

function expandRuleWithTags(state, rule) {
    // iterating this way means we can index directly into the new rule
    // find and store all the changes needed
    const todo = [];
    rule.lhs.forEach((row, rowx) => {     // in brackets [ ]
        row.forEach((cell, cellx) => {     // between bars [ | ]
            cell.forEach((atom, atomx) => {
                if (atomx % 2 == 1 && [atomx - 1] != 'no' && atom != '...' && !isAlreadyDeclared(state, atom)) {
                    todo.push({ rowx: rowx, cellx: cellx, atomx: atomx, ident: atom });
                }
            });
        });
    });
    if (todo.length == 0) return [ rule ];

    // apply the changes for each todo
    let newrules = [ rule ];
    todo.forEach((t,tx) => {
        const temprules = [];
        newrules.forEach(r => {
            const expander = new TagExpander(state, t.ident, true);
            for (const newident of expander.getExpandedIdents()) {
                const newrule = deepCloneRule(r);
                newrule.lhs[t.rowx][t.cellx][t.atomx] = newident;
                if (rule.rhs[t.rowx][t.cellx][t.atomx] == t.ident)
                    newrule.rhs[t.rowx][t.cellx][t.atomx] = newident;
                temprules.push(newrule);
            }
        });
        newrules = temprules;
    });
    return newrules;
}

// PS> expand rules with multi direction parts
// [ wantsToFlyTo:> wantsToFlyTo:perpendicular ] -> [ ]
// now expand out rules with multiple directions
function expandRulesWithMultiDirectionObjects(state, rules) {
    var newrules = [];
    for (const rule of rules) {
        const objs = [ ...rule.lhs, ...rule.rhs ].flat()
            .map(cell => cell.filter((_,x) => x % 2 == 1))
            .flat();
        const dirs = objs.map(obj => obj.split(':'))
            .flat()
            .filter((part,x,a) => part in directionaggregates && a.indexOf(part) == x);
        if (dirs.length == 0)
            newrules.push(rule);
        else {
            const muldir = dirs[0];
            for (const expdir of directionaggregates[muldir]) {
                const fnsub = cell => cell.map((c,x) => (x % 2 == 0) ? c
                    : (c == muldir) ? expdir 
                    : (c.includes(`:${muldir}`)) ? c.replace(`:${muldir}`, `:${expdir}`)
                    : c);
                newrules.push(deepCloneRule(rule, fnsub, fnsub));
            }
        }
    
    }
    if (debugSwitch.includes('exp')) console.log(`expandRulesWithMultiDirectionObjects ${rules.length} -> ${newrules.length}`);
    return newrules;
}

function checkRuleObjects(state, rules) {
    for (const rule of rules) {
        const objs = [ ...rule.lhs, ...rule.rhs ].flat()
            .map(cell => cell.filter((_,x) => x % 2 == 1))
            .filter(o => o != '...')
            .flat();
        for (const obj of objs) {
            if (!isAlreadyDeclared(state, obj))
                console.log(`Not declared`, rule.lineNumber, obj);
        }
    }
}
 
//now expand out rules with multiple directions, and set the rule direction
function expandRulesWithMultipleDirections(state, rules) {
    var newrules = [];
    for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var ruledirs = rule.directions;
        for (var j = 0; j < ruledirs.length; j++) {
            var dir = ruledirs[j];
            if (dir in directionaggregates && directionalRule(rule)) {
                var dirs = directionaggregates[dir];
                for (var k = 0; k < dirs.length; k++) {
                    var modifiedrule = deepCloneRule(rule);
                    modifiedrule.direction = dirs[k];
                    newrules.push(modifiedrule);
                }
            } else {
                var modifiedrule = deepCloneRule(rule);
                modifiedrule.direction = dir;
                newrules.push(modifiedrule);
            }
        }
    }
    if (debugSwitch.includes('exp')) console.log(`expandRulesWithMultipleDirections ${rules.length} -> ${newrules.length}`);
    return newrules;
}

function convertObjectsAndDirections(state, rules2) {
    var rules3 = [];
    //expand property rules
    for (var i = 0; i < rules2.length; i++) {
        var rule = rules2[i];
        rules3 = rules3.concat(concretizeMovingRule(state, rule, rule.lineNumber));
    }

    var rules4 = [];
    for (var i = 0; i < rules3.length; i++) {
        var rule = rules3[i];
        rules4 = rules4.concat(concretizePropertyRule(state, rule, rule.lineNumber));
    }

    for (var i=0;i<rules4.length;i++){
        makeSpawnedObjectsStationary(state,rules4[i],rule.lineNumber);
    }
    return rules4;
}

function containsEllipsis(rule) {
    for (var i = 0; i < rule.lhs.length; i++) {
        for (var j = 0; j < rule.lhs[i].length; j++) {
            if (rule.lhs[i][j][1] === '...')
                return true;
        }
    }
    return false;
}

//optional: replace up/left rules with their down/right equivalents
function rewriteUpLeftRules(rule) {
    if (containsEllipsis(rule)) {
        return;
    }

    if (rule.direction == 'up') {
        rule.direction = 'down';
    } else if (rule.direction == 'left') {
        rule.direction = 'right';
    } else {
        return;
    }

    for (var i = 0; i < rule.lhs.length; i++) {
        rule.lhs[i].reverse();
        if (rule.rhs.length > 0) {
            rule.rhs[i].reverse();
        }
    }
}

//expands all properties to list of all things it could be, filterio
function getPossibleObjectsFromCell(state, cell) {
    var result = [];
    for (var j = 0; j < cell.length; j += 2) {
        var dir = cell[j];
        var name = cell[j + 1];
        if (name in state.objects){
            result.push(name);
        }
        else if (name in state.propertiesDict) {
            var aliases = state.propertiesDict[name];
            for (var k = 0; k < aliases.length; k++) {
                var alias = aliases[k];
                result.push(alias);
            }        
        }
    }
    return result;
}

function getPropertiesFromCell(state, cell) {
    var result = [];
    for (var j = 0; j < cell.length; j += 2) {
        var dir = cell[j];
        var name = cell[j + 1];
        if (dir == "random") {
            continue;
        }
        if (name in state.propertiesDict) {
            result.push(name);
        }
    }
    return result;
}

//returns you a list of object names in that cell that're moving
function getMovings(state, cell) {
    var result = [];
    for (var j = 0; j < cell.length; j += 2) {
        var dir = cell[j];
        var name = cell[j + 1];
        if (dir in directionaggregates) {
            result.push([name, dir]);
        }
    }
    return result;
}

function concretizePropertyInCell(cell, property, concreteType) {
    for (var j = 0; j < cell.length; j += 2) {
        if (cell[j + 1] === property && cell[j] !== "random") {
            cell[j + 1] = concreteType;
        }
    }
}

function concretizeMovingInCell(cell, ambiguousMovement, nameToMove, concreteDirection) {
    for (var j = 0; j < cell.length; j += 2) {
        if (cell[j] === ambiguousMovement && cell[j + 1] === nameToMove) {
            cell[j] = concreteDirection;
        }
    }
}

function concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteDirection) {
    for (var j = 0; j < cell.length; j += 2) {
        if (cell[j] === ambiguousMovement) {
            cell[j] = concreteDirection;
        }
    }
}

function expandRuleTags(state, cell) {
    var expanded = [];
    for (var i = 0; i < cell.length; i += 2) {
        var dir = cell[i];
        var name = cell[i + 1];

        if (name.includes(':') && (dir == 'no' || !(name in state.propertiesDict))) {
            const expander = new TagExpander(state, name, true);
            for (const newname of expander.getExpandedIdents()) {
                expanded.push(dir);
                expanded.push(newname);
            }
        } else {
            expanded.push(dir);
            expanded.push(name);
        }
    }
    return expanded;

}

// inline expansion of negative properties: expand [ no flying ] to [ no cat no bat ]
function expandNoPrefixedProperties(state, cell) {
    var expanded = [];
    for (var i = 0; i < cell.length; i += 2) {
        var dir = cell[i];
        var name = cell[i + 1];

        if (dir === 'no' && (name in state.propertiesDict)) {
            var aliases = state.propertiesDict[name];
            for (var j = 0; j < aliases.length; j++) {
                var alias = aliases[j];
                expanded.push(dir);
                expanded.push(alias);
            }
        } else {
            expanded.push(dir);
            expanded.push(name);
        }
    }
    return expanded;
}

function concretizePropertyRule(state, rule, lineNumber) {

    //step 1, rephrase rule to change "no flying" to "no cat no bat"
    for (var i = 0; i < rule.lhs.length; i++) {
        var cur_cellrow_l = rule.lhs[i];
        for (var j = 0; j < cur_cellrow_l.length; j++) {
            cur_cellrow_l[j] = expandNoPrefixedProperties(state, 
                expandRuleTags(state, cur_cellrow_l[j]));
            if (rule.rhs.length > 0)
                rule.rhs[i][j] = expandNoPrefixedProperties(state, 
                    expandRuleTags(state, rule.rhs[i][j]));
        }
    }

    //are there any properties we could avoid processing?
    // e.g. [> player | movable] -> [> player | > movable],
    // 		doesn't need to be split up (assuming single-layer player/block aggregates)

    // we can't manage this if they're being used to disambiguate

    const ambiguousProperties = {};
    const mappingProperties_l = [];
    const mappingProperties_r = [];

    for (let j = 0; j < rule.rhs.length; j++) {
        const row_l = rule.lhs[j];
        const row_r = rule.rhs[j];
        for (let k = 0; k < row_r.length; k++) {
            const properties_l = getPropertiesFromCell(state, row_l[k]);
            const properties_r = getPropertiesFromCell(state, row_r[k]);

            for (let prop_n = 0; prop_n < properties_r.length; prop_n++) {
                const property = properties_r[prop_n];
                if (!properties_l.includes(property)) {
                    ambiguousProperties[property] = true;
                }
            }
            properties_l.forEach(value => mappingProperties_l.push(value));
            properties_r.forEach(value => mappingProperties_r.push(value));
        }
    }

    // PS> do we have properties on both sides, all of the same length, left all different from right?
    let result = [rule];
    if (mappingProperties_l.length > 0 && mappingProperties_r.length > 0) {
        const proplen = prop => state.propertiesDict[prop].length;
        const len0 = proplen(mappingProperties_l[0]);
        if (!mappingProperties_l.some(value => proplen(value) != len0)
            && !mappingProperties_r.some(value => proplen(value) != len0)
            && !mappingProperties_l.some(value => mappingProperties_r.includes(value))) {
            result = replaceMappedProperties(rule, len0);
        }
    }

    // PS> blindly replace property by n-th member in the n-th new rule (except if random)
    function replaceMappedProperties(oldRule, numprops) {
        let newRules = [];
        while (numprops-- > 0)
            newRules.push(deepCloneRule(oldRule));
        //const newRules = (new Array(numprops)).map(v => deepCloneRule(oldRule));
        newRules.forEach((newRule,rindex) => {
            [ newRule.lhs, newRule.rhs ].forEach(side => {
                side.forEach(cellrow => {
                    cellrow.forEach(cell => {
                        for (let j = 0; j < cell.length; j += 2) {
                            if (cell[j] != "random" && cell[j + 1] in state.propertiesDict) {
                                cell[j + 1] = state.propertiesDict[cell[j+1]][rindex];
                            }
                        }
                    });
                });
            });
        });
        if (debugSwitch.includes('exp')) console.log(`replaceMappedProperties added ${rules.length} -> ${newrules.length}`);
        return newRules;
    }

    var shouldremove;
    var modified = true;
    while (modified) {
        modified = false;
        for (var i = 0; i < result.length; i++) {
            //only need to iterate through lhs
            var cur_rule = result[i];
            shouldremove = false;
            for (var j = 0; j < cur_rule.lhs.length && !shouldremove; j++) {
                var cur_rulerow = cur_rule.lhs[j];
                for (var k = 0; k < cur_rulerow.length && !shouldremove; k++) {
                    var cur_cell = cur_rulerow[k];
                    var properties = getPropertiesFromCell(state, cur_cell);
                    for (var prop_n = 0; prop_n < properties.length; ++prop_n) {
                        var property = properties[prop_n];

                        if (state.propertiesSingleLayer.hasOwnProperty(property) &&
                            ambiguousProperties[property] !== true) {
                            // we don't need to explode this property
                            continue;
                        }

                        var aliases = state.propertiesDict[property];

                        shouldremove = true;
                        modified = true;

                        //just do the base property, let future iterations take care of the others

                        for (var l = 0; l < aliases.length; l++) {
                            var concreteType = aliases[l];
                            var newrule = deepCloneRule(cur_rule);
                            newrule.propertyReplacement = {};
                            for (var prop in cur_rule.propertyReplacement) {
                                if (cur_rule.propertyReplacement.hasOwnProperty(prop)) {
                                    var propDat = cur_rule.propertyReplacement[prop];
                                    newrule.propertyReplacement[prop] = [propDat[0], propDat[1]];
                                }
                            }

                            concretizePropertyInCell(newrule.lhs[j][k], property, concreteType);
                            if (newrule.rhs.length > 0) {
                                concretizePropertyInCell(newrule.rhs[j][k], property, concreteType); //do for the corresponding rhs cell as well
                            }

                            if (newrule.propertyReplacement[property] === undefined) {
                                newrule.propertyReplacement[property] = [concreteType, 1];
                            } else {
                                newrule.propertyReplacement[property][1] = newrule.propertyReplacement[property][1] + 1;
                            }

                            result.push(newrule);
                        }

                        break;
                    }
                }
            }
            if (shouldremove) {
                result.splice(i, 1);
                i--;
            }
        }
    }


    for (var i = 0; i < result.length; i++) {
        //for each rule
        var cur_rule = result[i];
        if (cur_rule.propertyReplacement === undefined) {
            continue;
        }

        //for each property replacement in that rule
        for (var property in cur_rule.propertyReplacement) {
            if (cur_rule.propertyReplacement.hasOwnProperty(property)) {
                var replacementInfo = cur_rule.propertyReplacement[property];
                var concreteType = replacementInfo[0];
                var occurrenceCount = replacementInfo[1];
                if (occurrenceCount === 1) {
                    //do the replacement
                    for (var j = 0; j < cur_rule.rhs.length; j++) {
                        var cellRow_rhs = cur_rule.rhs[j];
                        for (var k = 0; k < cellRow_rhs.length; k++) {
                            var cell = cellRow_rhs[k];
                            concretizePropertyInCell(cell, property, concreteType);
                        }
                    }
                }
            }
        }
    }

    //if any properties remain on the RHSes, bleep loudly
    var rhsPropertyRemains = '';
    for (var i = 0; i < result.length; i++) {
        var cur_rule = result[i];
        delete result.propertyReplacement;
        for (var j = 0; j < cur_rule.rhs.length; j++) {
            var cur_rulerow = cur_rule.rhs[j];
            for (var k = 0; k < cur_rulerow.length; k++) {
                var cur_cell = cur_rulerow[k];
                var properties = getPropertiesFromCell(state, cur_cell);
                for (var prop_n = 0; prop_n < properties.length; prop_n++) {
                    if (ambiguousProperties.hasOwnProperty(properties[prop_n])) {
                        rhsPropertyRemains = properties[prop_n];
                    }
                }
            }
        }
    }


    if (rhsPropertyRemains.length > 0) {
        logError('This rule has a property on the right-hand side, \"' + rhsPropertyRemains.toUpperCase() + "\", that can't be inferred from the left-hand side.  (either for every property on the right there has to be a corresponding one on the left in the same cell, OR, if there's a single occurrence of a particular property name on the left, all properties of the same name on the right are assumed to be the same).", lineNumber);
        return [];
    }

    return result;
}

function makeSpawnedObjectsStationary(state,rule,lineNumber){
    //movement not getting correctly cleared from tile #492
    //[ > Player | ] -> [ Crate | Player ] if there was a player already in the second cell, it's not replaced with a stationary player.
    //if there are properties remaining by this stage, just ignore them ( c.f. "[ >  Moveable | Moveable ] -> [ > Moveable | > Moveable ]" in block faker, what's left in this form) - this only happens IIRC when the properties span a single layer so it's)
    //if am object without moving-annotations appears on the RHS, and that object is not present on the lhs (either explicitly as an object, or implicitly in a property), add a 'stationary'
    if (rule.late){
        return;
    }

    for (var j = 0; j < rule.rhs.length; j++) {
        var row_l = rule.lhs[j];
        var row_r = rule.rhs[j];
        for (var k = 0; k < row_r.length; k++) {
            var cell=row_r[k];

            //this is super intricate. uff. 
            var objects_l = getPossibleObjectsFromCell(state, row_l[k]);
            var layers = objects_l.map(n=>state.objects[n].layer);
            for (var l = 0; l < cell.length; l += 2) {
                var dir = cell[l];
                if (dir!==""){
                    continue;
                }
                var name = cell[l + 1];
                if (name in state.propertiesDict || objects_l.indexOf(name)>=0){
                    continue;
                }
                // dies here if invalid object name
                var r_layer = state.objects[name].layer;
                if (layers.indexOf(r_layer)===-1){
                    cell[l]='stationary';
                }
            }
        }
    }

}

function concretizeMovingRule(state, rule, lineNumber) {

    var shouldremove;
    var result = [rule];
    var modified = true;
    while (modified) {
        modified = false;
        for (var i = 0; i < result.length; i++) {
            //only need to iterate through lhs
            var cur_rule = result[i];
            shouldremove = false;
            for (var j = 0; j < cur_rule.lhs.length; j++) {
                var cur_rulerow = cur_rule.lhs[j];
                for (var k = 0; k < cur_rulerow.length; k++) {
                    var cur_cell = cur_rulerow[k];
                    var movings = getMovings(state, cur_cell); //finds aggregate directions
                    if (movings.length > 0) {
                        shouldremove = true;
                        modified = true;

                        //just do the base property, let future iterations take care of the others
                        var cand_name = movings[0][0];
                        var ambiguous_dir = movings[0][1];
                        var concreteDirs = directionaggregates[ambiguous_dir];
                        for (var l = 0; l < concreteDirs.length; l++) {
                            var concreteDirection = concreteDirs[l];
                            var newrule = deepCloneRule(cur_rule);

                            //deep copy replacements
                            newrule.movingReplacement = {};
                            for (var moveTerm in cur_rule.movingReplacement) {
                                if (cur_rule.movingReplacement.hasOwnProperty(moveTerm)) {
                                    var moveDat = cur_rule.movingReplacement[moveTerm];
                                    newrule.movingReplacement[moveTerm] = [moveDat[0], moveDat[1], moveDat[2],moveDat[3],moveDat[4],moveDat[5]];
                                }
                            }
                            newrule.aggregateDirReplacement = {};
                            for (var moveTerm in cur_rule.aggregateDirReplacement) {
                                if (cur_rule.aggregateDirReplacement.hasOwnProperty(moveTerm)) {
                                    var moveDat = cur_rule.aggregateDirReplacement[moveTerm];
                                    newrule.aggregateDirReplacement[moveTerm] = [moveDat[0], moveDat[1], moveDat[2]];
                                }                                
                            }

                            concretizeMovingInCell(newrule.lhs[j][k], ambiguous_dir, cand_name, concreteDirection);
                            if (newrule.rhs.length > 0) {
                                concretizeMovingInCell(newrule.rhs[j][k], ambiguous_dir, cand_name, concreteDirection); //do for the corresponding rhs cell as well
                            }

                            if (newrule.movingReplacement[cand_name+ambiguous_dir] === undefined) {
                                newrule.movingReplacement[cand_name+ambiguous_dir] = [concreteDirection, 1, ambiguous_dir,cand_name,j,k];
                            } else {
                                var mr = newrule.movingReplacement[cand_name+ambiguous_dir];
                                if (j!==mr[4] || k!==mr[5]){
                                    mr[1] = mr[1] + 1;
                                }
                            }
                            if (newrule.aggregateDirReplacement[ambiguous_dir] === undefined) {
                                newrule.aggregateDirReplacement[ambiguous_dir] = [concreteDirection, 1, ambiguous_dir];
                            } else {
                                newrule.aggregateDirReplacement[ambiguous_dir][1] = newrule.aggregateDirReplacement[ambiguous_dir][1] + 1;
                            }

                            result.push(newrule);
                        }
                    }
                }
            }
            if (shouldremove) {
                result.splice(i, 1);
                i--;
            }
        }
    }


    for (var i = 0; i < result.length; i++) {
        //for each rule
        var cur_rule = result[i];
        if (cur_rule.movingReplacement === undefined) {
            continue;
        }
        var ambiguous_movement_dict = {};
        //strict first - matches movement direction to objects
        //for each property replacement in that rule
        for (var cand_name in cur_rule.movingReplacement) {
            if (cur_rule.movingReplacement.hasOwnProperty(cand_name)) {
                var replacementInfo = cur_rule.movingReplacement[cand_name];
                var concreteMovement = replacementInfo[0];
                var occurrenceCount = replacementInfo[1];
                var ambiguousMovement = replacementInfo[2];
                var ambiguousMovement_attachedObject = replacementInfo[3];

                if (occurrenceCount === 1) {
                    //do the replacement
                    for (var j = 0; j < cur_rule.rhs.length; j++) {
                        var cellRow_rhs = cur_rule.rhs[j];
                        for (var k = 0; k < cellRow_rhs.length; k++) {
                            var cell = cellRow_rhs[k];
                            concretizeMovingInCell(cell, ambiguousMovement, ambiguousMovement_attachedObject, concreteMovement);
                        }
                    }
                }

            }
        }

        //I don't fully understand why the following part is needed (and I wrote this yesterday), but it's not obviously malicious.
        var ambiguous_movement_names_dict = {};
        for (var cand_name in cur_rule.aggregateDirReplacement) {
            if (cur_rule.aggregateDirReplacement.hasOwnProperty(cand_name)) {
                var replacementInfo = cur_rule.aggregateDirReplacement[cand_name];
                var concreteMovement = replacementInfo[0];
                var occurrenceCount = replacementInfo[1];
                var ambiguousMovement = replacementInfo[2];
                //are both the following boolean bits necessary, or just the latter? ah well, no harm it seems.
                if ((ambiguousMovement in ambiguous_movement_names_dict) || (occurrenceCount !== 1)) {
                    ambiguous_movement_names_dict[ambiguousMovement] = "INVALID";
                } else {
                    ambiguous_movement_names_dict[ambiguousMovement] = concreteMovement
                }
            }
        }        

        //for each ambiguous word, if there's a single ambiguous movement specified in the whole lhs, then replace that wholesale
        for (var ambiguousMovement in ambiguous_movement_dict) {
            if (ambiguous_movement_dict.hasOwnProperty(ambiguousMovement) && ambiguousMovement !== "INVALID") {
                concreteMovement = ambiguous_movement_dict[ambiguousMovement];
                if (concreteMovement === "INVALID") {
                    continue;
                }
                for (var j = 0; j < cur_rule.rhs.length; j++) {
                    var cellRow_rhs = cur_rule.rhs[j];
                    for (var k = 0; k < cellRow_rhs.length; k++) {
                        var cell = cellRow_rhs[k];
                        concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteMovement);
                    }
                }
            }
        }

        
        //further replacements - if a movement word appears once on the left, can use to disambiguate remaining ones on the right
        for (var ambiguousMovement in ambiguous_movement_names_dict) {
            if (ambiguous_movement_names_dict.hasOwnProperty(ambiguousMovement) && ambiguousMovement !== "INVALID") {
                concreteMovement = ambiguous_movement_names_dict[ambiguousMovement];
                if (concreteMovement === "INVALID") {
                    continue;
                }
                for (var j = 0; j < cur_rule.rhs.length; j++) {
                    var cellRow_rhs = cur_rule.rhs[j];
                    for (var k = 0; k < cellRow_rhs.length; k++) {
                        var cell = cellRow_rhs[k];
                        concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteMovement);
                    }
                }
            }
        }
    }

    //if any properties remain on the RHSes, bleep loudly
    var rhsAmbiguousMovementsRemain = '';
    for (var i = 0; i < result.length; i++) {
        var cur_rule = result[i];
        delete result.movingReplacement;
        for (var j = 0; j < cur_rule.rhs.length; j++) {
            var cur_rulerow = cur_rule.rhs[j];
            for (var k = 0; k < cur_rulerow.length; k++) {
                var cur_cell = cur_rulerow[k];
                var movings = getMovings(state, cur_cell);
                if (movings.length > 0) {
                    rhsAmbiguousMovementsRemain = movings[0][1];
                }
            }
        }
    }


    if (rhsAmbiguousMovementsRemain.length > 0) {
        logError('This rule has an ambiguous movement on the right-hand side, \"' + rhsAmbiguousMovementsRemain + "\", that can't be inferred from the left-hand side.  (either for every ambiguous movement associated to an entity on the right there has to be a corresponding one on the left attached to the same entity, OR, if there's a single occurrence of a particular ambiguous movement on the left, all properties of the same movement attached to the same object on the right are assumed to be the same (or something like that)).", lineNumber);
        state.invalid=true;
    }

    return result;
}

// replace all synonyms in a rule by the object they refer to
function rephraseSynonyms(state, rule) {
    for (var i = 0; i < rule.lhs.length; i++) {
        var cellrow_l = rule.lhs[i];
        var cellrow_r = rule.rhs[i];
        for (var j = 0; j < cellrow_l.length; j++) {
            var cell_l = cellrow_l[j];
            for (var k = 1; k < cell_l.length; k += 2) {
                var name = cell_l[k];
                if (name in state.synonymsDict) {
                    cell_l[k] = state.synonymsDict[cell_l[k]];
                }
            }
            if (rule.rhs.length > 0) {
                var cell_r = cellrow_r[j];
                for (var k = 1; k < cell_r.length; k += 2) {
                    var name = cell_r[k];
                    if (name in state.synonymsDict) {
                        cell_r[k] = state.synonymsDict[cell_r[k]];
                    }
                }
            }
        }
    }
}

// replace all aggregates in a rule by the set of objects they refer to
function atomizeAggregates(state, rule) {
    for (var i = 0; i < rule.lhs.length; i++) {
        var cellrow = rule.lhs[i];
        for (var j = 0; j < cellrow.length; j++) {
            var cell = cellrow[j];
            atomizeCellAggregates(state, cell, rule.lineNumber);
        }
    }
    for (var i = 0; i < rule.rhs.length; i++) {
        var cellrow = rule.rhs[i];
        for (var j = 0; j < cellrow.length; j++) {
            var cell = cellrow[j];
            atomizeCellAggregates(state, cell, rule.lineNumber);
        }
    }
}

function atomizeCellAggregates(state, cell, lineNumber) {
    for (var i = 0; i < cell.length; i += 2) {
        var dir = cell[i];
        var c = cell[i + 1];
        if (c in state.aggregatesDict) {
            if (dir === 'no') {
                logError("You cannot use 'no' to exclude the aggregate object " + c.toUpperCase() + " (defined using 'AND'), only regular objects, or properties (objects defined using 'OR').  If you want to do this, you'll have to write it out yourself the long way.", lineNumber);
            }
            var equivs = state.aggregatesDict[c];
            cell[i + 1] = equivs[0];
            for (var j = 1; j < equivs.length; j++) {
                cell.push(cell[i]); //push the direction
                cell.push(equivs[j]);
            }
        }
    }
}

// replace all relative directions in every rule cell by absolute based on rule direction (direction and object)
function convertRelativeDirsToAbsolute(state, rule) {
    [ ...rule.lhs, ...rule.rhs ].flat().forEach(cell => {
        absolutifyRuleCell(rule.direction, cell);
    });
}

function absolutifyRuleCell(forward, cell) {
    const absOf = dir => relativeDirs.includes(dir) ? relativeDict[forward][relativeDirs.indexOf(dir)] : dir;
    for (var i = 0; i < cell.length; i += 2) {
        cell[i] = absOf(cell[i]);
        cell[i + 1] = cell[i + 1].split(':').map(p => absOf(p)).join(':');
    }
}

function rulesToMask(state) {
    /*

    */
    var layerCount = state.collisionLayers.length;
    var layerTemplate = [];
    for (var i = 0; i < layerCount; i++) {
        layerTemplate.push(null);
    }

    for (var i = 0; i < state.rules.length; i++) {
        var rule = state.rules[i];
        for (var j = 0; j < rule.lhs.length; j++) {
            var cellrow_l = rule.lhs[j];
            var cellrow_r = rule.rhs[j];
            for (var k = 0; k < cellrow_l.length; k++) {
                var cell_l = cellrow_l[k];
                var layersUsed_l = layerTemplate.concat([]);
                var objectsPresent = new BitVec(STRIDE_OBJ);
                var objectsMissing = new BitVec(STRIDE_OBJ);
                var anyObjectsPresent = [];
                var movementsPresent = new BitVec(STRIDE_MOV);
                var movementsMissing = new BitVec(STRIDE_MOV);

                var objectlayers_l = new BitVec(STRIDE_MOV);
                for (var l = 0; l < cell_l.length; l += 2) {
                    var object_dir = cell_l[l];
                    if (object_dir === '...') {
                        objectsPresent = ellipsisPattern;
                        if (cell_l.length !== 2) {
                            logError("You can't have anything in with an ellipsis. Sorry.", rule.lineNumber);
                        } else if ((k === 0) || (k === cellrow_l.length - 1)) {
                            logError("There's no point in putting an ellipsis at the very start or the end of a rule", rule.lineNumber);
                        } else if (rule.rhs.length > 0) {
                            var rhscell = cellrow_r[k];
                            if (rhscell.length !== 2 || rhscell[0] !== '...') {
                                logError("An ellipsis on the left must be matched by one in the corresponding place on the right.", rule.lineNumber);
                            }
                        }
                        break;
                    } else if (object_dir === 'random') {
                        logError("RANDOM cannot be matched on the left-hand side, it can only appear on the right", rule.lineNumber);
                        continue;
                    }

                    var object_name = cell_l[l + 1];
                    var object = state.objects[object_name];
                    var objectMask = state.objectMasks[object_name];
                    if (object) {
                        var layerIndex = object.layer | 0;
                    } else {
                        var layerIndex = state.propertiesSingleLayer[object_name];
                    }

                    if (typeof(layerIndex) === "undefined") {
                        logError("Oops!  " + object_name.toUpperCase() + " not assigned to a layer.", rule.lineNumber);
                    }

                    if (object_dir === 'no') {
                        objectsMissing.ior(objectMask);
                    } else {
                        var existingname = layersUsed_l[layerIndex];
                        if (existingname !== null) {
                            rule.discard=[object_name.toUpperCase(), existingname.toUpperCase()];
                        }

                        layersUsed_l[layerIndex] = object_name;

                        if (object) {
                            objectsPresent.ior(objectMask);
                            objectlayers_l.ishiftor(MOV_MASK, MOV_BITS * layerIndex);
                        } else {
                            anyObjectsPresent.push(objectMask);
                        }

                        if (object_dir === 'stationary') {
                            movementsMissing.ishiftor(MOV_MASK, MOV_BITS * layerIndex);
                        } else {
                            movementsPresent.ishiftor(dirMasks[object_dir], MOV_BITS * layerIndex);
                        }
                    }
                }

                if (rule.rhs.length > 0) {
                    var rhscell = cellrow_r[k];
                    var lhscell = cellrow_l[k];
                    if (rhscell[0] === '...' && lhscell[0] !== '...') {
                        logError("An ellipsis on the right must be matched by one in the corresponding place on the left.", rule.lineNumber);
                    }
                    for (var l = 0; l < rhscell.length; l += 2) {
                        var content = rhscell[l];
                        if (content === '...') {
                            if (rhscell.length !== 2) {
                                logError("You can't have anything in with an ellipsis. Sorry.", rule.lineNumber);
                            }
                        }
                    }
                }

                if (objectsPresent === ellipsisPattern) {
                    cellrow_l[k] = ellipsisPattern;
                    continue;
                } else {
                    cellrow_l[k] = new CellPattern([objectsPresent, objectsMissing, anyObjectsPresent, movementsPresent, movementsMissing, null]);
                }

                //if X no X, then cancel
                if (objectsPresent.anyBitsInCommon(objectsMissing)){
                    //if I'm about the remove the last representative of this line number, throw an error
                    var ln = rule.lineNumber;
                    if ( (i>0 && state.rules[i-1].lineNumber===ln) || ( (i+1<state.rules.length) && state.rules[i+1].lineNumber===ln)){
                        //all good
                    } else {
                        logWarning('This rule has some content of the form "X no X" (either directly or maybe indirectly - check closely how the terms are defined if nothing stands out) which can never match and so the rule is getting removed during compilation.', rule.lineNumber);
                    }
                    state.rules.splice(i,1);
                    i--;
                    continue;
                }
                
                if (rule.rhs.length === 0) {
                    continue;
                }

                var cell_r = cellrow_r[k];
                var layersUsed_r = layerTemplate.concat([]);
                var layersUsedRand_r = layerTemplate.concat([]);

                var objectsClear = new BitVec(STRIDE_OBJ);
                var objectsSet = new BitVec(STRIDE_OBJ);
                var movementsClear = new BitVec(STRIDE_MOV);
                var movementsSet = new BitVec(STRIDE_MOV);

                var objectlayers_r = new BitVec(STRIDE_MOV);
                var randomMask_r = new BitVec(STRIDE_OBJ);
                var postMovementsLayerMask_r = new BitVec(STRIDE_MOV);
                var randomDirMask_r = new BitVec(STRIDE_MOV);
                for (var l = 0; l < cell_r.length; l += 2) {
                    var object_dir = cell_r[l];
                    var object_name = cell_r[l + 1];

                    if (object_dir === '...') {
                        //logError("spooky ellipsis found! (should never hit this)");
                        break;
                    } else if (object_dir === 'random') {
                        if (object_name in state.objectMasks) {
                            var mask = state.objectMasks[object_name];
                            randomMask_r.ior(mask);
                            var values;
                            if (state.propertiesDict.hasOwnProperty(object_name)) {
                                values = state.propertiesDict[object_name];
                            } else {
                                //get line number declaration of object_name
                                logWarning(`In this rule you're asking me to spawn a random ${object_name.toUpperCase()} for you, but that's already a concrete single object.  You wanna be using random with properties (things defined in terms of OR in the legend) so there's some things to select between.`, rule.lineNumber);
                                values = [object_name];
                            }
                            for (var m = 0; m < values.length; m++) {
                                var subobject = values[m];
                                var layerIndex = state.objects[subobject].layer | 0;
                                var existingname = layersUsed_r[layerIndex];
                                if (existingname !== null) {
                                    var o1 = subobject.toUpperCase();
                                    var o2 = existingname.toUpperCase();
                                    if (o1 !== o2) {
                                        logWarning("This rule may try to spawn a " + o1 + " with random, but also requires a " + o2 + " be here, which is on the same layer - they shouldn't be able to coexist!", rule.lineNumber);
                                    }
                                }

                                layersUsedRand_r[layerIndex] = subobject;
                            }

                        } else {
                            logError('You want to spawn a random "' + object_name.toUpperCase() + '", but I don\'t know how to do that', rule.lineNumber);
                        }
                        continue;
                    }

                    var object = state.objects[object_name];
                    var objectMask = state.objectMasks[object_name];
                    if (object) {
                        var layerIndex = object.layer | 0;
                    } else {
                        var layerIndex = state.propertiesSingleLayer[object_name];
                    }


                    if (object_dir == 'no') {
                        objectsClear.ior(objectMask);
                    } else {
                        var existingname = layersUsed_r[layerIndex];
                        if (existingname === null) {
                            existingname = layersUsedRand_r[layerIndex];
                        }

                        if (existingname !== null) {
                            if (rule.hasOwnProperty('discard')) {

                            } else {
                                logError('Rule matches object types that can\'t overlap: "' + object_name.toUpperCase() + '" and "' + existingname.toUpperCase() + '".', rule.lineNumber);
                            }
                        }

                        layersUsed_r[layerIndex] = object_name;

                        if (object_dir.length > 0) {
                            postMovementsLayerMask_r.ishiftor(MOV_MASK, MOV_BITS * layerIndex);
                        }

                        var layerMask = state.layerMasks[layerIndex];

                        if (object) {
                            objectsSet.ibitset(object.id);
                            objectsClear.ior(layerMask);
                            objectlayers_r.ishiftor(MOV_MASK, MOV_BITS * layerIndex);
                        } else {
                            // shouldn't need to do anything here...
                        }
                        //possibility - if object not present on lhs in same position, clear movement
                        if (object_dir === 'stationary') {
                            movementsClear.ishiftor(MOV_MASK, MOV_BITS * layerIndex);
                        }                
                        if (object_dir === 'randomdir') {
                            randomDirMask_r.ishiftor(dirMasks[object_dir], MOV_BITS * layerIndex);
                        } else {
                            movementsSet.ishiftor(dirMasks[object_dir], MOV_BITS * layerIndex);
                        };
                    }
                }

                //I don't know why these two ifs here are needed.
                if (!(objectsPresent.bitsSetInArray(objectsSet.data))) {
                    objectsClear.ior(objectsPresent); // clear out old objects
                }
                if (!(movementsPresent.bitsSetInArray(movementsSet.data))) {
                    movementsClear.ior(movementsPresent); // ... and movements
                }

                /*
                for rules like this I want to clear movements on newly-spawned entities
                    [ >  Player | Crate ] -> [  >  Player | > Crate  ]
                    [ > Player | ] -> [ Crate | Player ]

                WITHOUT havin this rule remove movements
                    [ > Player | ] -> [ Crate | Player ]
                (bug #492)
                */
               
                for (var l = 0; l < layerCount; l++) {
                    if (layersUsed_l[l] !== null && layersUsed_r[l] === null) {
                        // a layer matched on the lhs, but not on the rhs
                        objectsClear.ior(state.layerMasks[l]);
                        postMovementsLayerMask_r.ishiftor(MOV_MASK, MOV_BITS * l);
                    }
                }

                objectlayers_l.iclear(objectlayers_r);

                postMovementsLayerMask_r.ior(objectlayers_l);
                if (!objectsClear.iszero() || !objectsSet.iszero() || !movementsClear.iszero() || !movementsSet.iszero() || !postMovementsLayerMask_r.iszero() || !randomMask_r.iszero() || !randomDirMask_r.iszero()) {
                    // only set a replacement if something would change
                    cellrow_l[k].replacement = new CellReplacement([objectsClear, objectsSet, movementsClear, movementsSet, postMovementsLayerMask_r, randomMask_r, randomDirMask_r]);
                } 
            }
        }
    }
}

function cellRowMasks(rule) {
    var ruleMasks = [];
    var lhs = rule[1];
    for (var i = 0; i < lhs.length; i++) {
        var cellRow = lhs[i];
        var rowMask = new BitVec(STRIDE_OBJ);
        for (var j = 0; j < cellRow.length; j++) {
            if (cellRow[j] === ellipsisPattern)
                continue;
            rowMask.ior(cellRow[j].objectsPresent);
        }
        ruleMasks.push(rowMask);
    }
    return ruleMasks;
}

function cellRowMasks_Movements(rule){
    var ruleMasks_mov = [];
    var lhs = rule[1];
    for (var i = 0; i < lhs.length; i++) {
        var cellRow = lhs[i];
        var rowMask = new BitVec(STRIDE_MOV);
        for (var j = 0; j < cellRow.length; j++) {
            if (cellRow[j] === ellipsisPattern)
                continue;
            rowMask.ior(cellRow[j].movementsPresent);
        }
        ruleMasks_mov.push(rowMask);
    }
    return ruleMasks_mov;
}

function collapseRules(groups) {
    for (var gn = 0; gn < groups.length; gn++) {
        var rules = groups[gn];
        for (var i = 0; i < rules.length; i++) {
            var oldrule = rules[i];
            var newrule = [0, [], oldrule.rhs.length > 0, oldrule.lineNumber /*ellipses,group number,rigid,commands,randomrule,[cellrowmasks]*/ ];
            var ellipses = [];
            for (var j = 0; j < oldrule.lhs.length; j++) {
                ellipses.push(0);
            }

            newrule[0] = dirMasks[oldrule.direction];
            for (var j = 0; j < oldrule.lhs.length; j++) {
                var cellrow_l = oldrule.lhs[j];
                for (var k = 0; k < cellrow_l.length; k++) {
                    if (cellrow_l[k] === ellipsisPattern) {
                        ellipses[j] ++;
                        if (ellipses[j]>2) {
                            logError("You can't use more than two ellipses in a single cell match pattern.", oldrule.lineNumber);
                        } else {
                            if (k>0 && cellrow_l[k-1]===ellipsisPattern){
                                logWarning("Why would you go and have two ellipses in a row like that? It's exactly the same as just having a single ellipsis, right?", oldrule.lineNumber);
                        }
                    }
                }
                }
                newrule[1][j] = cellrow_l;
            }
            newrule.push(ellipses);
            newrule.push(oldrule.groupNumber);
            newrule.push(oldrule.rigid);
            newrule.push(oldrule.commands);
            newrule.push(oldrule.randomRule);
            newrule.push(cellRowMasks(newrule));
            newrule.push(cellRowMasks_Movements(newrule));
            newrule.push(oldrule.globalRule);
            newrule.push(oldrule.isOnce);
            rules[i] = new Rule(newrule);
        }
    }
    matchCache = {}; // clear match cache so we don't slowly leak memory
}



function ruleGroupDiscardOverlappingTest(ruleGroup) {
    if (ruleGroup.length === 0)
        return;
    
    var discards=[];

    for (var i = 0; i < ruleGroup.length; i++) {
        var rule = ruleGroup[i];
        if (rule.hasOwnProperty('discard')) {
            
            var beforesame = i===0 ? false : ruleGroup[i-1].lineNumber === rule.lineNumber;
            var aftersame = i===(ruleGroup.length-1) ? false : ruleGroup[i+1].lineNumber === rule.lineNumber;

            ruleGroup.splice(i, 1);
            
            var found=false;
            for(var j=0;j<discards.length;j++){
                var discard=discards[j];
                if (discard[0]===rule.discard[0] && discard[1]===rule.discard[1]){
                    found=true;
                    break;
                }
            }
            if(!found){
                discards.push(rule.discard)
            }

            //if rule before isn't of same linenumber, and rule after isn't of same linenumber, 
            //then a rule has been totally erased and you should throw an error!
            if ( !(beforesame||aftersame) || ruleGroup.length===0) {
                
                const example = discards[0];
                
                var parenthetical = "";
                if (discards.length>1){
                    parenthetical = " (ditto for ";
                    for (var j=1;j<discards.length;j++){
                        if (j>1){
                            parenthetical+=", "
                            
                            if (j===discards.length-1){
                                parenthetical += "and ";
            }
                        }

                        const thisdiscard = discards[j];
                        const p1 = thisdiscard[0];
                        const p2 = thisdiscard[1];
                        parenthetical += `${p1}/${p2}`;

                        if (j===3 && discards.length>4){
                            parenthetical+=" etc.";
                            break;
                        }
                    }
                    parenthetical += ")";
                }

                logError(`${example[0]} and ${example[1]} can never overlap${parenthetical}, but this rule requires that to happen, so it's being culled.`, rule.lineNumber);
            }
            i--;
        }
    }
}

function arrangeRulesByGroupNumber(state) {
    var aggregates = {};
    var aggregates_late = {};
    for (var i = 0; i < state.rules.length; i++) {
        var rule = state.rules[i];
        var targetArray = aggregates;
        if (rule.late) {
            targetArray = aggregates_late;
        }

        if (targetArray[rule.groupNumber] == undefined) {
            targetArray[rule.groupNumber] = [];
        }
        targetArray[rule.groupNumber].push(rule);
    }

    var result = [];
    for (var groupNumber in aggregates) {
        if (aggregates.hasOwnProperty(groupNumber)) {
            var ruleGroup = aggregates[groupNumber];
            ruleGroupDiscardOverlappingTest(ruleGroup);
            if (ruleGroup.length > 0) {
                result.push(ruleGroup);
            }
        }
    }
    var result_late = [];
    for (var groupNumber in aggregates_late) {
        if (aggregates_late.hasOwnProperty(groupNumber)) {
            var ruleGroup = aggregates_late[groupNumber];
            ruleGroupDiscardOverlappingTest(ruleGroup);
            if (ruleGroup.length > 0) {
                result_late.push(ruleGroup);
            }
        }
    }
    state.rules = result;

    //check that there're no late movements with direction requirements on the lhs
    state.lateRules = result_late;
}

function generateRigidGroupList(state) {
	var rigidGroupIndex_to_GroupIndex=[];
	var groupIndex_to_RigidGroupIndex=[];
	var groupNumber_to_GroupIndex=[];
	var groupNumber_to_RigidGroupIndex=[];
	var rigidGroups=[];
	for (var i=0;i<state.rules.length;i++) {
		var ruleset=state.rules[i];
		var rigidFound=false;
		for (var j=0;j<ruleset.length;j++) {
			var rule=ruleset[j];
			if (rule.isRigid) {
				rigidFound=true;
			}
		}
		rigidGroups[i]=rigidFound;
		if (rigidFound) {
			var groupNumber=ruleset[0].groupNumber;
			groupNumber_to_GroupIndex[groupNumber]=i;
			var rigid_group_index = rigidGroupIndex_to_GroupIndex.length;
			groupIndex_to_RigidGroupIndex[i]=rigid_group_index;
			groupNumber_to_RigidGroupIndex[groupNumber]=rigid_group_index;
			rigidGroupIndex_to_GroupIndex.push(i);
		}
	}
    if (rigidGroupIndex_to_GroupIndex.length > 30) {
        var group_index = rigidGroupIndex_to_GroupIndex[30];
        logError("There can't be more than 30 rigid groups (rule groups containing rigid members).", state.rules[group_index][0].lineNumber);
	}

	state.rigidGroups=rigidGroups;
	state.rigidGroupIndex_to_GroupIndex=rigidGroupIndex_to_GroupIndex;
	state.groupNumber_to_RigidGroupIndex=groupNumber_to_RigidGroupIndex;
	state.groupIndex_to_RigidGroupIndex=groupIndex_to_RigidGroupIndex;
}

function getMaskFromName(state,name) {
	var objectMask=new BitVec(STRIDE_OBJ);
	if (name in state.objects) {
		var o=state.objects[name];
		objectMask.ibitset(o.id);
	}

	if (name in state.aggregatesDict) {
		var objectnames = state.aggregatesDict[name];
		for(var i=0;i<objectnames.length;i++) {
			var n=objectnames[i];
			var o = state.objects[n];
			objectMask.ibitset(o.id);
		}
	}

	if (name in state.propertiesDict) {
		var objectnames = state.propertiesDict[name];
		for(var i=0;i<objectnames.length;i++) {
			var n = objectnames[i];
			var o = state.objects[n];
			objectMask.ibitset(o.id);
		}
	}

	if (name in state.synonymsDict) {
		var n = state.synonymsDict[name];
		var o = state.objects[n];
		objectMask.ibitset(o.id);
	}

	if (!state.metadata.includes("nokeyboard") && objectMask.iszero()) {
		logErrorNoLine("error, didn't find any object called player, either in the objects section, or the legends section. there must be a player!");
	}
	return objectMask;
}

function generateMasks(state) {
    state.playerMask = getMaskFromName(state, 'player');

    var layerMasks = [];                        // doc: bit vector of object IDs in a layer
    var layerCount = state.collisionLayers.length;
    for (var layer = 0; layer < layerCount; layer++) {
        var layerMask = new BitVec(STRIDE_OBJ);
        for (var j = 0; j < state.objectCount; j++) {
            var n = state.idDict[j];
            var o = state.objects[n];
            if (o.layer == layer) {
                layerMask.ibitset(o.id);
            }
        }
        layerMasks.push(layerMask);
    }
    state.layerMasks = layerMasks;              // doc: array of layer masks indexed by layer

    var objectMask = {};
    for (var n in state.objects) {
        if (state.objects.hasOwnProperty(n)) {
            var o = state.objects[n];
            objectMask[n] = new BitVec(STRIDE_OBJ);
            objectMask[n].ibitset(o.id);
        }
    }

    // Synonyms can depend on properties, and properties can depend on synonyms.
    // Process them in order by combining & sorting by linenumber.

    var synonyms_and_properties = state.legend_synonyms.concat(state.legend_properties);
    synonyms_and_properties.sort(function(a, b) {
        return a.lineNumber - b.lineNumber;
    });

    for (var i = 0; i < synonyms_and_properties.length; i++) {
        var synprop = synonyms_and_properties[i];
        if (synprop.length == 2) {
            // synonym (a = b)
            objectMask[synprop[0]] = objectMask[synprop[1]];
        } else {
            // property (a = b or c)
            var val = new BitVec(STRIDE_OBJ);
            for (var j = 1; j < synprop.length; j++) {
                var n = synprop[j];
                val.ior(objectMask[n]);
            }
            objectMask[synprop[0]] = val;
        }
    }

    //use \n as a delimeter for internal-only objects
    var all_obj = new BitVec(STRIDE_OBJ);
    all_obj.inot();
    objectMask["\nall\n"] = all_obj;

    state.objectMasks = objectMask;

    
    state.aggregateMasks = {};

    //set aggregate masks similarly
    for (var aggregateName of Object.keys(state.aggregatesDict)) {
        var objectnames = state.aggregatesDict[aggregateName];
        
        var aggregateMask = new BitVec(STRIDE_OBJ);
        for (var i = 0; i < objectnames.length; i++) {
            var n = objectnames[i];
            var o = state.objects[n];
            aggregateMask.ior(objectMask[n]);
        }
        state.aggregateMasks[aggregateName] = aggregateMask;
    }
}

function checkObjectsAreLayered(state) {
    for (var n in state.objects) {
        if (state.objects.hasOwnProperty(n)) {
            var found = false;
            for (var i = 0; i < state.collisionLayers.length; i++) {
                var layer = state.collisionLayers[i];
                for (var j = 0; j < layer.length; j++) {
                    if (layer[j] === n) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }
            if (found === false) {
                var o = state.objects[n];
                logError('Object "' + n.toUpperCase() + '" has been defined, but not assigned to a layer.', o.lineNumber);
            }
        }
    }
}

function isInt(value) {
return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value))
}
// convert metadata to object format and validate
function twiddleMetaData(state, update = false) {
	var newmetadata;

	if (!update) {
		newmetadata = {};
		for (var i=0;i<state.metadata.length;i+=2) {
			var key = state.metadata[i];
			var val = state.metadata[i+1];
			newmetadata[key]=val;
		}
	} else {
		newmetadata = state.metadata;
	}


    const getIntCheckedPositive = function(s,lineNumber){
        if (!isFinite(s) || !isInt(s)){
            logWarning(`Wasn't able to make sense of "${s}" as a (whole number) dimension.`,lineNumber);
            return NaN;
        }
        var result = parseInt(s);
        if (isNaN(result)){
            logWarning(`Wasn't able to make sense of "${s}" as a dimension.`,lineNumber);
        }
        if (result<=0){
            logWarning(`The dimension given to me (you gave "${s}") is baad - it should be greater than 0.`,lineNumber);
        }
        return result;
    }
    const getCoords = function(str,lineNumber){
		var coords = val.split('x');
        if (coords.length!==2){
            logWarning("Dimensions must be of the form AxB.",lineNumber);
            return null;
        } else {
            var intcoords = [getIntCheckedPositive(coords[0],lineNumber), getIntCheckedPositive(coords[1],lineNumber)];
            if (!isFinite(coords[0]) || !isFinite(coords[1]) || isNaN(intcoords[0]) || isNaN(intcoords[1])) {
                logWarning(`Couldn't understand the dimensions given to me (you gave "${val}") - should be of the form AxB.`,lineNumber);
                return null
            } else {
                if (intcoords[0]<=0 || intcoords[1]<=0){
                    logWarning(`The dimensions given to me (you gave "${val}") are baad - they should be > 0.`,lineNumber);
	}
                return intcoords;
            }
        }
    }

    if (newmetadata.flickscreen !== undefined) {
		var val = newmetadata.flickscreen;
        newmetadata.flickscreen = getCoords(val,state.metadata_lines.flickscreen);
        if (newmetadata.flickscreen===null){
            delete newmetadata.flickscreen;
        }
    }
    if (newmetadata.zoomscreen !== undefined) {
		var val = newmetadata.zoomscreen;
        newmetadata.zoomscreen = getCoords(val, state.metadata_lines.zoomscreen);
        if (newmetadata.zoomscreen === null) {
            delete newmetadata.zoomscreen;
	}
	}
	if (newmetadata.smoothscreen!==undefined) {
		var val = newmetadata.smoothscreen;
		var args = val.split(/\s+/);

		var validArguments = true

		if (args.length < 1) {
			logErrorNoLine('smoothscreen given no arguments but expects at least 1: smoothscreen [flick] WxH [IxJ] [S]')
			validArguments = false
		} else if (args.length > 4) {
			logErrorNoLine('smoothscreen given ' + args.length + ' arguments but expects at most 4: smoothscreen [flick] WxH [IxJ] [S]')
			validArguments = false
		}

		const smoothscreen = {
			screenSize: { width: 0, height: 0 },
			boundarySize: { width: 1, height: 1 },
			cameraSpeed: 0.125,
			flick: false,
			debug: !!newmetadata.smoothscreen_debug
		}

		if (args[0] === 'flick') {
			smoothscreen.flick = true
			args.shift()
		}

		const screenSizeMatch = args[0].match(/^(?<width>\d+)x(?<height>\d+)$/)
		if (screenSizeMatch) {
			smoothscreen.screenSize.width = parseInt(screenSizeMatch.groups.width)
			smoothscreen.screenSize.height = parseInt(screenSizeMatch.groups.height)

			if (smoothscreen.flick) {
				smoothscreen.boundarySize.width = smoothscreen.screenSize.width
				smoothscreen.boundarySize.height = smoothscreen.screenSize.height
			}
		} else {
			logErrorNoLine('smoothscreen given first argument ' + args[0] + ' but must be formatted WxH where W and H are integers')
			validArguments = false
		}

		if (args.length > 1) {
			const boundarySizeMatch = args[1].match(/^(?<width>\d+)x(?<height>\d+)$/)
			if (boundarySizeMatch) {
				smoothscreen.boundarySize.width = parseInt(boundarySizeMatch.groups.width)
				smoothscreen.boundarySize.height = parseInt(boundarySizeMatch.groups.height)
			} else {
				logErrorNoLine('smoothscreen given second argument ' + args[1] + ' but must be formatted IxJ where I and J are integers')
				validArguments = false
			}
		}

		if (args.length > 2) {
			const cameraSpeedMatch = args[2].match(/^(?<speed>\d+(\.\d+)?)$/)
			if (cameraSpeedMatch) {
				smoothscreen.cameraSpeed = clamp(parseFloat(cameraSpeedMatch.groups.speed), 0, 1)
			} else {
				logErrorNoLine('smoothscreen given third argument ' + args[2] + ' but must be a number')
				validArguments = false
			}
		}

		if (validArguments) {
			newmetadata.smoothscreen = smoothscreen;
		} else {
			delete newmetadata.smoothscreen
		}
	}

    if (newmetadata.tween_easing) {
        let easing = newmetadata.tween_easing;
        if (easing) {
            easing = (parseInt(easing) != NaN && easingAliases[parseInt(easing)]) ? easingAliases[parseInt(easing)] : easing.toLowerCase();
            if (EasingFunctions[easing]) 
                newmetadata.tween_easing = easing;
            else {
                logErrorNoLine(`tween easing ${newmetadata.tween_easing} is not valid.`);
                delete newmetadata.tween_easing;
            }
        }
    }

    if (newmetadata.tween_snap) {
        const snap = Math.max(parseInt(state.metadata.tween_snap), 1);
        if (snap) newmetadata.tween_snap = snap;
        else {
            logErrorNoLine(`tween ${newmetadata.tween_snap} is not valid.`);
            delete newmetadata.tween_snap;
        }
    }

    state.metadata=newmetadata;

	if (!update) {
		state.default_metadata = deepClone(newmetadata);
	}
}

function processWinConditions(state) {
    //	[-1/0/1 (no,some,all),ob1,ob2] (ob2 is background by default)
    var newconditions = [];
    for (var i = 0; i < state.winconditions.length; i++) {
        var wincondition = state.winconditions[i];
        if (wincondition.length == 0) {
            return;
        }
        var num = 0;
        switch (wincondition[0].toLowerCase()) {
            case 'no':
                { num = -1; break; }
            case 'all':
                { num = 1; break; }
        }

        var lineNumber = wincondition[wincondition.length - 1];

        var n1 = wincondition[1];
        var n2;
        if (wincondition.length == 5) {
            n2 = wincondition[3];
        } else {
            n2 = '\nall\n';
        }

        var mask1 = 0;
        var mask2 = 0;
        var aggr1 = false;
        var aggr2 = false;

        if (n1 in state.objectMasks) {
            aggr1 = false;
            mask1 = state.objectMasks[n1];
        } else if (n1 in state.aggregateMasks){
            aggr1 = true;
            mask1 = state.aggregateMasks[n1];
        } else {
            logError('Unwelcome term "' + n1 + '" found in win condition. I don\'t know what I\'m supposed to do with this. ', lineNumber);
        }
        if (n2 in state.objectMasks) {
            aggr2=false;
            mask2 = state.objectMasks[n2];
        } else if (n2 in state.aggregateMasks){
            aggr2 = true;
            mask2 = state.aggregateMasks[n2];
        } else {
            logError('Unwelcome term "' + n1 + '" found in win condition. I don\'t know what I\'m supposed to do with this. ', lineNumber);
        }
        var newcondition = [num, mask1, mask2, lineNumber, aggr1, aggr2];
        newconditions.push(newcondition);
    }
    state.winconditions = newconditions;
}

function printCellRow(cellRow) {
    var result = "[ ";
    for (var i = 0; i < cellRow.length; i++) {
        if (i > 0) {
            result += "| ";
        }
        var cell = cellRow[i];
        for (var j = 0; j < cell.length; j += 2) {
            var direction = cell[j];
            var object = cell[j + 1]
            if (direction === "...") {
                result += direction + " ";
            } else {
                result += direction + " " + object + " ";
            }
        }
    }
    result += "] ";
    return result;
}

function cacheRuleStringRep(rule) {
	var result="(<a onclick=\"jumpToLine('"+ rule.lineNumber.toString() + "');\"  href=\"javascript:void(0);\">"+rule.lineNumber+"</a>) "+ rule.direction.toString().toUpperCase()+" ";
	if (rule.rigid) {
		result = "RIGID "+result+" ";
	}
	if (rule.randomRule) {
		result = "RANDOM "+result+" ";
	}
	if (rule.globalRule) {
		result = "GLOBAL "+result+" ";
	}
	if (rule.isOnce) {
		result = "ONCE "+result+" ";
	}
	if (rule.late) {
		result = "LATE "+result+" ";
	}
	for (var i=0;i<rule.lhs.length;i++) {
		var cellRow = rule.lhs[i];
		result = result + printCellRow(cellRow);
	}
	result = result + "-> ";
	for (var i=0;i<rule.rhs.length;i++) {
		var cellRow = rule.rhs[i];
		result = result + printCellRow(cellRow);
	}
	for (var i=0;i<rule.commands.length;i++) {
		var command = rule.commands[i];
		if (command.length===1) {
			result = result +command[0].toString();
		} else {
			result = result + '('+command[0].toString()+", "+command[1].toString()+') ';			
		}
	}
	//print commands next
	rule.stringRep=result;
}

function cacheAllRuleNames(state) {

    for (var i = 0; i < state.rules.length; i++) {
        var rule = state.rules[i];
        cacheRuleStringRep(rule);
    }
}

function printRules(state) {
    var output = "";
    var loopIndex = 0;
    var loopEnd = -1;
    let subroutineIndex = 0;
    var discardcount = 0;
    for (var i = 0; i < state.rules.length; i++) {
        var rule = state.rules[i];
        // print subroutine - could be more than one, must come before any startloop and after any endloop!
        let subrtext = '';
        for (let subroutine = state.subroutines[subroutineIndex]; subroutine && subroutine.lineNumber < rule.lineNumber; subroutine = state.subroutines[++subroutineIndex]) {
            subrtext += `SUBROUTINE ${subroutine.label}<br>`;
        }
        if (loopIndex < state.loops.length) {
            if (state.loops[loopIndex][0] < rule.lineNumber) {
                output += subrtext + "STARTLOOP<br>";
                subrtext = '';
                loopIndex++;
                if (loopIndex < state.loops.length) { // don't die with mismatched loops
                    loopEnd = state.loops[loopIndex][0];
                    loopIndex++;
                }
            }
        }
        if (loopEnd !== -1 && loopEnd < rule.lineNumber) {
            output += "ENDLOOP<br>";
            loopEnd = -1;
        }
        output += subrtext;
        if (rule.hasOwnProperty('discard')) {
            discardcount++;
        } else {
            var sameGroupAsPrevious = i>0 && state.rules[i-1].groupNumber === rule.groupNumber;
            if (sameGroupAsPrevious){
                output += '+ ';
            } else {
                output += '&nbsp;&nbsp;';
            }
            output += rule.stringRep + "<br>";
        }
    }
    if (loopEnd !== -1) { // no more rules after loop end
        output += "ENDLOOP<br>";
    }
    output += "===========<br>";
    output = "<br>Rule Assembly : (" + (state.rules.length - discardcount) + " rules)<br>===========<br>" + output;
    consolePrint(output);
}

function removeDuplicateRules(state) {
    var record = {};
    var newrules = [];
    var lastgroupnumber = -1;
    for (var i = state.rules.length - 1; i >= 0; i--) {
        var r = state.rules[i];
        var groupnumber = r.groupNumber;
        if (groupnumber !== lastgroupnumber) {
            record = {};
        }
        var r_string = r.stringRep;
        if (record.hasOwnProperty(r_string)) {
            state.rules.splice(i, 1);
        } else {
            record[r_string] = true;
        }
        lastgroupnumber = groupnumber;
    }
}

function generateLoopPoints(state) {
    var loopPoint = {};
    var loopPointIndex = 0;
    var outside = true;
    var source = 0;
    var target = 0;
    if (state.loops.length > 0) {
        for (var i=0;i<state.loops.length;i++){
            var loop = state.loops[i];
            if (i%2===0){
                if (loop[1]===-1){         
                    logError("Found an ENDLOOP, but I'm not in a loop?",loop[0]);
                }
            } else {
                if (loop[1]===1){         
                    logError("Found a STARTLOOP, but I'm already inside a loop? (Puzzlescript can't nest loops, FWIW).",loop[0]);
                }
            }
        }
        var lastloop=state.loops[state.loops.length-1];
        if (lastloop[1]!==-1){
            logError("Yo I found a STARTLOOP without a corresponding ENDLOOP.",lastloop[0]);

        }
        // logError("Have to have matching number of  'startLoop' and 'endLoop' loop points.",state.loops[state.loops.length-1][0]);
    }

    for (var j = 0; j < state.loops.length; j++) {
        var loop = state.loops[j];
        for (var i = 0; i < state.rules.length; i++) {
            var ruleGroup = state.rules[i];

            var firstRule = ruleGroup[0];
            var lastRule = ruleGroup[ruleGroup.length - 1];

            var firstRuleLine = firstRule.lineNumber;
            var lastRuleLine = lastRule.lineNumber;

            if (loop[0] >= firstRuleLine && loop[0] <= lastRuleLine) {
                logWarning("Found a loop point in the middle of a rule. You probably don't want to do this, right?", loop[0]);
            }
            if (outside) {
                if (firstRuleLine >= loop[0]) {
                    target = i;
                    outside = false;
                    break;
                }
            } else {
                if (firstRuleLine >= loop[0]) {
                    source = i - 1;
                    loopPoint[source] = target;
                    outside = true;
                    break;
                }
            }
        }
    }
    if (outside === false) {
        var source = state.rules.length;
        loopPoint[source] = target;
    } else {}
    state.loopPoint = loopPoint;

    loopPoint = {};
    outside = true;
    for (var j = 0; j < state.loops.length; j++) {
        var loop = state.loops[j];
        for (var i = 0; i < state.lateRules.length; i++) {
            var ruleGroup = state.lateRules[i];

            var firstRule = ruleGroup[0];
            var lastRule = ruleGroup[ruleGroup.length - 1];

            var firstRuleLine = firstRule.lineNumber;
            var lastRuleLine = lastRule.lineNumber;

            if (outside) {
                if (firstRuleLine >= loop[0]) {
                    target = i;
                    outside = false;
                    break;
                }
            } else {
                if (firstRuleLine >= loop[0]) {
                    source = i - 1;
                    loopPoint[source] = target;
                    outside = true;
                    break;
                }
            }
        }
    }
    if (outside === false) {
        var source = state.lateRules.length;
        loopPoint[source] = target;
    } else {}
    state.lateLoopPoint = loopPoint;
}

var soundDirectionMasks = {
    'up':           1,
    'down':         2,
    'left':         4,
    'right':        8,
    'horizontal': 0xc,
    'vertical':     3,
    'orthogonal': 0xf,
    '_action_'  :0x10,
    '_lclick_'  :0x20,
    '_rclick_'  :0x40
};

function generateSoundData(state) {
    const sfx_Events = {};
    // doc: lists of sfx event triggers { objectMask:, directionMask:, layer:, seed: }
    const sfx_CreationMasks = [];
    const sfx_DestructionMasks = [];
    const sfx_MovementMasks = state.collisionLayers.map(x => []);     // doc: array of sfx movement triggers, indexed by layer
    const sfx_MovementFailureMasks = [];

    for (const sound of state.sounds) {
        if (sound[0] === "SOUNDEVENT") {
            const event = sound[1];
            const seed = sound[2];
            const line = sound[3];
            if (sfx_Events[event]) 
                logWarning(`${event.toUpperCase()} already declared.`, line);
            sfx_Events[event] = seed;
        } else { // SOUND
            const target = sound[1];
            let verb = sound[2];
            let directions = sound[3];
            const seed = sound[4];
            const line = sound[5];

            if (target in state.aggregatesDict)
                logError('cannot assign sound events to aggregate objects (declared with "and"), only to regular objects, or properties, things defined in terms of "or" ("' + target + '").', line);
            if (!(target in state.objectMasks))
                logError(`Object "${target}" not found.`, line);

            if (soundverbs_directional.includes(verb)) {
                if (directions.length == 0)
                    directions = ['orthogonal'];
            } else if (soundverbs_movement.includes(verb)) {
                directions = [ `_${verb}_` ];
                verb = 'move';
            } else if (directions.length > 0)
                logError('Incorrect sound declaration - cannot have directions (UP/DOWN/etc.) attached to non-directional sound verbs (CREATE is not directional, but MOVE is directional).', line);

            // construct a direction mask
            let directionMask = 0;
            for (const dir of directions) {
                if (!soundDirectionMasks[dir]) 
                    logError(`Was expecting a direction, instead found "${dir}".`, line);
                else 
                    directionMask |= soundDirectionMasks[dir];
            }

            // construct a list of targets, after expanding properties (if any)
            let targets = [target];
            let modified = true;
            while (modified) {
                modified = false;
                for (let k = 0; k < targets.length; k++) {
                    const t = targets[k];
                    if (t in state.synonymsDict) {
                        targets[k] = state.synonymsDict[t];
                        modified = true;
                    } else if (t in state.propertiesDict) {
                        modified = true;
                        const props = state.propertiesDict[t];
                        targets.splice(k, 1);
                        k--;
                        for (let l = 0; l < props.length; l++) {
                            targets.push(props[l]);
                        }
                    }
                }
            }
            
            // create 'mask' entries for runtime sound event checking, one per target object
            // this code originally kept only the masks, but could misfire if object on one mask hit direction on another
            // note: this information required to support animation
            for (let j = 0; j < targets.length; j++) {
                const targetName = targets[j];
                const targetDat = state.objects[targetName];
                const targetLayer = targetDat.layer;
                let shiftedDirectionMask = null;
                // separate masks for each layer
                if (verb === 'move' || verb === 'cantmove') {
                    shiftedDirectionMask = new BitVec(STRIDE_MOV);
                    shiftedDirectionMask.ishiftor(directionMask, MOV_BITS * targetLayer);
                }

                // doc: sfx/afx seed for target object, movement(s) as mask shifted to target layer
                const o = {
                    objId: targetDat.id,
                    directionMask: shiftedDirectionMask,
                    layer:targetLayer,
                    seed: seed
                };
                if (debugSwitch.includes('sfx')) console.log(`Sfx verb ${verb} o: ${JSON.stringify(o)}`);

                if (verb === 'move')
                    sfx_MovementMasks[targetLayer].push(o);
                else if (verb === 'cantmove') 
                    sfx_MovementFailureMasks.push(o);
                else if (verb === 'create') 
                    sfx_CreationMasks.push(o);
                else // (verb === 'destroy') 
                    sfx_DestructionMasks.push(o);
            }
        }
    }

    state.sfx_Events = sfx_Events;
    state.sfx_CreationMasks = sfx_CreationMasks;
    state.sfx_DestructionMasks = sfx_DestructionMasks;
    state.sfx_MovementMasks = sfx_MovementMasks;
    state.sfx_MovementFailureMasks = sfx_MovementFailureMasks;
}


function formatHomePage(state) {
    state.bgcolor = ('background_color' in state.metadata) ? colorToHex(colorPalette, state.metadata.background_color) : '#000000';
    state.fgcolor = ('text_color' in state.metadata) ? colorToHex(colorPalette, state.metadata.text_color) : "#FFFFFF";
    state.author_color = ('author_color' in state.metadata) ? colorToHex(colorPalette, state.metadata.author_color) : "#FFFFFF";
    state.title_color = ('title_color' in state.metadata) ? colorToHex(colorPalette, state.metadata.title_color) : "#FFFFFF";
    state.keyhint_color = ('keyhint_color' in state.metadata) ? colorToHex(colorPalette, state.metadata.keyhint_color) : "#FFFFFF"; // todo:

    if (canSetHTMLColors) {

        if ('background_color' in state.metadata) {
            document.body.style.backgroundColor = state.bgcolor;
        }

        if ('text_color' in state.metadata) {
            const separator = document.getElementById("separator");
            if (separator != null) {
                separator.style.color = state.fgcolor;
            }

            var h1Elements = document.getElementsByTagName("a");
            for (var i = 0; i < h1Elements.length; i++) {
                h1Elements[i].style.color = state.fgcolor;
            }

            var h1Elements = document.getElementsByTagName("h1");
            for (var i = 0; i < h1Elements.length; i++) {
                h1Elements[i].style.color = state.fgcolor;
            }
        }
    }

    if ('homepage' in state.metadata) {
        var url = state.metadata['homepage'];
        url = url.replace("http://", "");
        url = url.replace("https://", "");
        state.metadata['homepage'] = url;
    }
}

// load and compile a new script
function loadFile(str) {
	var processor = new codeMirrorFn();
	var state = processor.startState();

    if (!str || str.trim().length == 0) {
        logErrorNoLine('Empty file! Compilation abandoned!', true);
        return;
    }
	var lines = str.split('\n');
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];
		state.lineNumber = i + 1;
		var ss = new CodeMirror.StringStream(line, 4);
		do {
			processor.token(ss, state);
		}		
		while (ss.eol() === false);
	}

    if (debugSwitch.includes('tag')) console.log('Tags', state.tags);
    if (debugSwitch.includes('map')) console.log('Mappings', state.mappings);
    if (debugSwitch.includes('layer')) console.log('Collision Layers', state.collisionLayers);
    if (debugSwitch.includes('layer')) console.log('Collision Layer Groups', state.collisionLayerGroups);
    generateExtraMembers(state);
	generateMasks(state);
	levelsToArray(state);
	extractSections(state);
    rulesToArray(state);
    
    if (state.invalid>0){
        return null;
    }

	cacheAllRuleNames(state);

    removeDuplicateRules(state);
    
    if (state.invalid>0){
        return null;
    }

	convertSectionNamesToIndices(state);
    
	rulesToMask(state);

	
	if (debugMode) {
		printRules(state);
	}

	arrangeRulesByGroupNumber(state);
	collapseRules(state.rules);
	collapseRules(state.lateRules);

    generateRigidGroupList(state);

	processWinConditions(state);
	checkObjectsAreLayered(state);

	twiddleMetaData(state);
	
	generateExtraMembersPart2(state);

	generateLoopPoints(state);

    fixUpGosubs(state);  //

    generateSoundData(state);

    formatHomePage(state);

    //delete intermediate representations
	delete state.commentLevel;
    delete state.commentStyle;
    delete state.line_should_end;
    delete state.line_should_end_because;
    delete state.sol_after_comment;
	delete state.names;
	delete state.abbrevNames;
	delete state.objects_candname;
	delete state.objects_section;
	delete state.objects_spritematrix;
	delete state.section;
	delete state.subsection;
	delete state.tokenIndex;
    delete state.current_line_wip_array;
	delete state.visitedSections;
	delete state.loops;
	return state;
}

var ifrm;

// compile a script for editor or testing, run inputs and return state if valid
function compile(command, text, randomseed) {
    matchCache = {};
    forceRegenImages = true;
    if (command === undefined) {
        command = ["restart"];
    }
    if (randomseed === undefined) {
        randomseed = null;
    }
    lastDownTarget = canvas;

    if (text === undefined) {
        var code = window.form1.code;

        var editor = code.editorreference;

        text = editor.getValue() + "\n";
    }
    if (canDump === true) {
        compiledText = text;
    }

    errorCount = 0;
    compiling = true;
    errorStrings = [];
    consolePrint('=================================');
    // todo: temporary console output to help with debugging
    try {
        console.log(`Begin compile: '${text.split('\n')[0]}'`);
        var state = loadFile(text);
    } catch(error) {
        consolePrint(error);
        console.error(`Compile error: ${error}`);
        console.error(`${error.stack}`);
        errorStrings.push(error);
        //errorCount++;
    } finally {
        compiling = false;
    }

    if (!state || state.invalid) {
        console.log(`End compile: aborted with error ${errorStrings[errorStrings.length - 1]}`);
        consoleError(`<span class="systemMessage">Compilation aborted. ${errorStrings[errorStrings.length - 1]}</span>`);
        return null;
    }

    console.log(`End compile: ${state && !state.invalid && errorCount == 0 ? "ok" : "FAILED, error count = " + errorCount}`);

    if (state.levels && state.levels.length === 0) {
        logError('No levels found. Add some levels!', undefined, true);
    }

    if (errorCount > 0) {
        // if (IDE===false){
        //     consoleError('<span class="systemMessage">Errors detected during compilation; the game may not work correctly.  If this is an older game, and you think it just broke because of recent changes in the puzzlescript plus engine, consider letting me know via the issue tracker.</span>');
        // } else{
            consoleError('<span class="systemMessage">Errors detected during compilation; the game may not work correctly.</span>');
        // }
    } else {
        var ruleCount = 0;
        for (var i = 0; i < state.rules.length; i++) {
            ruleCount += state.rules[i].length;
        }
        for (var i = 0; i < state.lateRules.length; i++) {
            ruleCount += state.lateRules[i].length;
        }
        consolePrint(htmlClass('systemMessage', `Successful ${command[0] == "restart" ? "compilation" : "live recompilation"}, generated ${ruleCount} instructions.`));
                
        if (debugMode) {
            consolePrint(htmlClass('systemMessage', `Tags: ${Object.keys(state.tags).length} Objects: ${state.objectCount} Layers: ${state.collisionLayers.length} Sounds: ${state.sounds.length} Levels: ${state.levels.length}.`));
        }
        
        if (IDE){
            if (state.metadata.title!==undefined) {
                document.title=`${state.metadata.title} - PuzzleScript Next`;
            }
        }
    }

    if (IDE) {
        if (state.metadata.tween_length !== undefined && state.lateRules.length >= 1) {
            logWarning("Using tweens in a game that also has LATE rules is currently experimental! If you change objects that moved with LATE then tweens might not play!", undefined, true);
            logWarning("Note that if you change objects that have moved in LATE rules, their tweens won't play!", undefined, true);
        }

        if(state.metadata.level_select_unlocked_ahead !== undefined && state.metadata.level_select_unlocked_rollover !== undefined) {
            logWarning("You can't use both level_select_unlocked_ahead and level_select_unlocked_rollover at the same time, so please choose only one!", undefined, true);
        }

        if(state.metadata.level_select === undefined && (state.metadata.level_select_lock !== undefined || state.metadata.level_select_unlocked_ahead !== undefined || state.metadata.level_select_unlocked_rollover !== undefined || state.metadata.continue_is_level_select !== undefined || state.metadata.level_select_solve_symbol !== undefined)) {
            logWarning("You're using level select prelude flags, but didn't define the 'level_select' flag.", undefined, true);
        }

        if(state.metadata.level_select_lock === undefined && (state.metadata.level_select_unlocked_ahead !== undefined || state.metadata.level_select_unlocked_rollover !== undefined)) {
            logWarning("You've defined a level unlock condition, but didn't define the 'level_select_lock' flag.", undefined, true);
        }

        if(state.metadata.runtime_metadata_twiddling_debug !== undefined) {
            logWarning("RUNTIME_METADATA_TWIDDLING_DEBUG is deprecated, however you can now use verbose logging instead to see when metadata is changed.", undefined, true);
        }

        if(state.metadata.level_select !== undefined && state.sections.length == 0) {
            logWarning("To use LEVEL_SELECT, you need to create some sections first, otherwise the level list will be empty! Please see the docs for more info.", undefined, true);
        }
        if (isSitelocked()) {
            logError("The game is sitelocked. To continue testing, add the current domain '"+window.location.origin+ "' to the list.", undefined, true);
        }
    }

    if (state) { //otherwise error
        setGameState(state, command, randomseed);
        clearInputHistory();
    }
    consoleCacheDump();

    return state;

}



function qualifyURL(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}

function isSitelocked() {
    if (state.metadata.sitelock_origin_whitelist === undefined && state.metadata.sitelock_hostname_whitelist === undefined) {
        return false;
    }

    if (IDE == true) {
        return false; //Don't sitelock in editor
    }

    if (state.metadata.sitelock_origin_whitelist === undefined) {
        var origins = state.metadata.sitelock_origin_whitelist.split(" ");

        var origin = window.location.origin;

        for (var i = 0; i < origins.length; i += 1) {
            if (origin == origins[i]) {
                return false;
            }
        }
    }

    if (state.metadata.sitelock_hostname_whitelist == undefined) {
        var hostnames = state.metadata.sitelock_hostname_whitelist.split(" ");

        var hostname = window.location.hostname;

        for (var i = 0; i < hostnames.length; i += 1) {
            if (hostname == hostnames[i]) {
                return false;
            }
        }
    }

    return true;
}

</script>
<script>
var keyRepeatTimer=0;
var keyRepeatIndex=0;
var input_throttle_timer=0.0;
var lastinput=-100;

var dragging=false;
var rightdragging=false;
var columnAdded=false;

function selectText(containerid,e) {
	var myspan = document.getElementById(containerid);
	if (e&&(e.ctrlKey || e.metaKey)) {
		if(solving) return;
		var levelarr = ["console"].concat(myspan.innerHTML.split("<br>"));
		var leveldat = levelFromString(state,levelarr);
		loadLevelFromLevelDat(state,leveldat,null);
		canvasResize();
	} else {
	    if (document.selection) {
	        var range = document.body.createTextRange();
	        range.moveToElementText(myspan);
	        range.select();
	    } else if (window.getSelection) {
	        var range = document.createRange();
	        range.selectNode(myspan);
			var selection = window.getSelection();
			//why removeallranges? https://stackoverflow.com/a/43443101 whatever...
			selection.removeAllRanges();
	        selection.addRange(range);
	    }
	}
}

function recalcLevelBounds(){
}

function arrCopy(from, fromoffset, to, tooffset, len) {
	while (len--)
		to[tooffset++] = from[fromoffset]++;
}

function adjustLevel(level, widthdelta, heightdelta) {
	backups.push(backupLevel());
	var oldlevel = level.clone();
	level.width += widthdelta;
	level.height += heightdelta;
	level.n_tiles = level.width * level.height;
	level.objects = new Int32Array(level.n_tiles * STRIDE_OBJ);
	var bgMask = new BitVec(STRIDE_OBJ);
	bgMask.ibitset(state.backgroundid);
	for (var i=0; i<level.n_tiles; ++i) 
		level.setCell(i, bgMask);
	level.movements = new Int32Array(level.objects.length);
	columnAdded=true;
	RebuildLevelArrays();
	return oldlevel;
}

function addLeftColumn() {
	var oldlevel = adjustLevel(curLevel, 1, 0);
	for (var x=1; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index - curLevel.height))
		}
	}
}

function addRightColumn() {
	var oldlevel = adjustLevel(curLevel, 1, 0);
	for (var x=0; x<curLevel.width-1; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index))
		}
	}
}

function addTopRow() {
	var oldlevel = adjustLevel(curLevel, 0, 1);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=1; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index - x - 1))
		}
	}
}

function addBottomRow() {
	var oldlevel = adjustLevel(curLevel, 0, 1);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height - 1; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index - x));
		}
	}
}

function removeLeftColumn() {
	if (curLevel.width<=1) {
		return;
	}
	var oldlevel = adjustLevel(curLevel, -1, 0);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index + curLevel.height))
		}
	}
}

function removeRightColumn(){
	if (curLevel.width<=1) {
		return;
	}
	var oldlevel = adjustLevel(curLevel, -1, 0);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index))
		}
	}
}

function removeTopRow(){
	if (curLevel.height<=1) {
		return;
	}
	var oldlevel = adjustLevel(curLevel, 0, -1);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index + x + 1))
		}
	}
}
function removeBottomRow(){
	if (curLevel.height<=1) {
		return;
	}
	var oldlevel = adjustLevel(curLevel, 0, -1);
	for (var x=0; x<curLevel.width; ++x) {
		for (var y=0; y<curLevel.height; ++y) {
			var index = x*curLevel.height + y;
			curLevel.setCell(index, oldlevel.getCell(index + x))
		}
	}
}

function matchGlyph(inputmask,glyphAndMask) {
	// find mask with closest match
	var highestbitcount=-1;
	var highestmask;
	for (var i=0; i<glyphAndMask.length; ++i) {
		var glyphname = glyphAndMask[i][0];
		var glyphmask = glyphAndMask[i][1];
 		var glyphbits = glyphAndMask[i][2];
		//require all bits of glyph to be in input
		if (glyphmask.bitsSetInArray(inputmask.data)) {
			var bitcount = 0;
			for (var bit=0;bit<32*STRIDE_OBJ;++bit) {
				if (glyphbits.get(bit) && inputmask.get(bit))
 					bitcount++;
				if (glyphmask.get(bit) && inputmask.get(bit))
					bitcount++;
			}
			if (bitcount>highestbitcount) {
				highestbitcount=bitcount;
				highestmask=glyphname;
			}
		}
	}
	if (highestbitcount>0) {
		return highestmask;
	}
	
	logErrorNoLine("Wasn't able to approximate a glyph value for some tiles, using '.' as a placeholder.",true);
	return '.';
}

var htmlEntityMap = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	'"': '&quot;',
	"'": '&#39;',
	"/": '&#x2F;'
};

var selectableint  = 0;

function printLevel() {
	var glyphMasks = [];
	for (var glyphName in state.glyphDict) {
		if (state.glyphDict.hasOwnProperty(glyphName)&&glyphName.length===1) {
			var glyph = state.glyphDict[glyphName];
			var glyphmask=new BitVec(STRIDE_OBJ);
			for (var i=0;i<glyph.length;i++)
			{
				var id = glyph[i];
				if (id>=0) {
					glyphmask.ibitset(id);
				}
			}
			var glyphbits = glyphmask.clone();
			//register the same - backgroundmask with the same name
			var bgMask = state.layerMasks[state.backgroundlayer];
			glyphmask.iclear(bgMask);
			glyphMasks.push([glyphName, glyphmask, glyphbits]);
		}
	}
	selectableint++;
	var tag = 'selectable'+selectableint;
	var output="Printing level contents:<br><br><span id=\""+tag+"\" onclick=\"selectText('"+tag+"',event)\"><br>";
	cache_console_messages = false;
	for (var j=0;j<curLevel.height;j++) {
		for (var i=0;i<curLevel.width;i++) {
			var cellIndex = j+i*curLevel.height;
			var cellMask = curLevel.getCell(cellIndex);
			var glyph = matchGlyph(cellMask,glyphMasks);
			if (glyph in htmlEntityMap) {
				glyph = htmlEntityMap[glyph]; 
			}
			output = output+glyph;
		}
		if (j<curLevel.height-1){
			output=output+"<br>";
		}
	}
	output+="</span><br><br>"
	consolePrint(output,true);
}

function levelEditorClick(event,click) {
	// note: screenwidth and screenheight are correct, not inflated by glyph panel
	const glyphPanelRect = { x: 0, y: -1 - editorRowCount, w: screenwidth + 1, h: editorRowCount };
	if (mouseCoordY >= glyphPanelRect.y && mouseCoordY < glyphPanelRect.y + glyphPanelRect.h) {
		var newindex = mouseCoordX + glyphPanelRect.w * (mouseCoordY - glyphPanelRect.y);
		if (mouseCoordX===-1) {
			printLevel();
		} else if (mouseCoordX >= 0 && newindex < glyphImages.length) {
			glyphSelectedIndex = newindex;
			redraw();
		}

	} else if (mouseCoordX >= 0 && mouseCoordY >= 0 && mouseCoordX < screenwidth && mouseCoordY < screenheight) {
		var glyphname = glyphImagesCorrespondance[glyphSelectedIndex];
		var glyph = state.glyphDict[glyphname];
		var glyphmask = new BitVec(STRIDE_OBJ);
		for (var i=0;i<glyph.length;i++) {
			var id = glyph[i];
			if (id>=0) {
				glyphmask.ibitset(id);
			}			
		}

		var backgroundMask = state.layerMasks[state.backgroundlayer];
		if (glyphmask.bitsClearInArray(backgroundMask.data)) {
			// If we don't already have a background layer, mix in
			// the default one.
			glyphmask.ibitset(state.backgroundid);
		}

		var coordIndex = mouseCoordY + mouseCoordX*curLevel.height;
		var getcell = curLevel.getCell(coordIndex);
		if (getcell.equals(glyphmask)) {
			return;
		} else {
			if (anyEditsSinceMouseDown===false) {
				anyEditsSinceMouseDown=true;				
        		backups.push(backupLevel());
			}
			curLevel.setCell(coordIndex, glyphmask);
			redraw();
		}
	} else {
		if (mouseCoordX == -1) {
			addLeftColumn();			
			canvasResize();
		} else if (mouseCoordX == screenwidth) {
			addRightColumn();
			canvasResize();
		} 
		if (mouseCoordY == -1) {
			addTopRow();
			canvasResize();
		} else if (mouseCoordY == screenheight) {
			addBottomRow();
			canvasResize();
		}
	}
}

function levelEditorRightClick(event,click) {
	if (mouseCoordY===-2) {
		if (mouseCoordX<=glyphImages.length) {
			glyphSelectedIndex=mouseCoordX;
			redraw();
		}
	} else if (mouseCoordX >= 0 && mouseCoordY >= 0 && mouseCoordX < screenwidth && mouseCoordY < screenheight) {
		var coordIndex = mouseCoordY + mouseCoordX*curLevel.height;
		var glyphmask = new BitVec(STRIDE_OBJ);
		glyphmask.ibitset(state.backgroundid);
		curLevel.setCell(coordIndex, glyphmask);
		redraw();
	}
	else {
		if (mouseCoordX == -1) {
			removeLeftColumn();			
			canvasResize();
		} else if (mouseCoordX == screenwidth) {
			removeRightColumn();
			canvasResize();
		} 
		if (mouseCoordY == -1) {
			removeTopRow();
			canvasResize();
		} else if (mouseCoordY == screenheight) {
			removeBottomRow();
			canvasResize();
		}
	}
}

function getTilesTraversingPoints(x1, y1, x2, y2) {
	// these branches should never be hit, but we want to be defensive to avoid infinite loops:
	if (isNaN(x2)) {
		console.warn("getTilesTraversingPoints() got NaN (second coord)")
		x2 = -100
		y2 = -100
	}
	if (isNaN(x1)) {
		console.warn("getTilesTraversingPoints() got NaN (first coord)")
		x1 = x2
		y1 = y2
	}
	
	if (cellwidth !== cellheight) {
		throw "Error: Cell is not square.";
	}
	
	var dirX = x2-x1;
	var dirY = y2-y1;
	//var rootedX = (y1*dirX)/dirY;					non-integer
	var scaledRootedX = (y1*dirX);						// == rootedX *dirY
	var rootedY = y1;
	
	// (x1/dirX)*dirY - y1 = c
	//	x*dirY = y*dirX
	
	//var shiftMid = x1-rootedX;					non-integer
	var scaledShiftMid = x1*dirY-scaledRootedX;			// == shiftMid*dirY
	
	// dirY*x2 - dirX*y2 - dirY*shiftMid	==	0
	// dirY*x2 - dirX*y2	==	scaledShiftMid
	
	//var horizontalDeviation = cellwidth*(1 + Math.abs(dirX/dirY))/2;		non-integer; formula provided by phenomist, checked by me (ThatScar)
	var scaledAbsDeviationTimesTwo = cellwidth*(Math.abs(dirX) + Math.abs(dirY));	// == abs(horizontalDeviation*dirY*2)
	
	//var scaledShiftMin = scaledShiftMid - horizontalDeviation*dirY;
	//var scaledShiftMax = scaledShiftMid + horizontalDeviation*dirY;
	var scaledShiftATimesTwo = 2*scaledShiftMid - scaledAbsDeviationTimesTwo;
	var scaledShiftBTimesTwo = 2*scaledShiftMid + scaledAbsDeviationTimesTwo;
	
	/// Important: shifts A and B must be used interchangeably
	
	// Testing against various cellCenterX, cellCenterY;
	// dirY*shiftMin		<	dirY*cellCenterX - dirX*cellCenterY	<=	dirY*shiftMax
	// scaledShiftMin		<	dirY*cellCenterX - dirX*cellCenterY	<=	scaledShiftMax
	// scaledShiftBTimesTwo	<2*(dirY*cellCenterX - dirX*cellCenterY)<=	scaledShiftBTimesTwo
	// OR if both A and B fail, instead.
	
	
	//fOfPoint = dirY*cellCenterX - dirX*cellCenterY;
	//isInside = (scaledShiftMin < fOfPoint) == (fOfPoint <= scaledShiftMax);
	function isInside(cellCenterXTimesTwo, cellCenterYTimesTwo) {
		fOfPointTimesTwo = dirY*cellCenterXTimesTwo - dirX*cellCenterYTimesTwo;
		return (scaledShiftATimesTwo < fOfPointTimesTwo) == (fOfPointTimesTwo <= scaledShiftBTimesTwo);
		/// Important: shifts A and B must be used interchangeably
	}
	
	var cellX1=Math.floor(x1/cellwidth);
	var cellY1=Math.floor(y1/cellheight);
	var cellX2=Math.floor(x2/cellwidth);
	var cellY2=Math.floor(y2/cellheight);
	var offsetToCenterTimesTwo = cellwidth-1;
	
	var xSign = (cellX2-cellX1)>=0 ? 1 : -1;
	var ySign = (cellY2-cellY1)>=0 ? 1 : -1;
	
	var yTrimmer = cellY1;
	
	var tileListX = [];
	var tileListY = [];
	
	
	for (var i=cellX1; i != cellX2+xSign; i += xSign) {
		var over = false;
		
		for (var j=yTrimmer; j != cellY2+ySign; j += ySign) {
			if (j >= curLevel.height || j < 0 || i >= curLevel.width || i < 0) {
				error = "Mouse input loop failed; it:" + i + " " + j + " cell1:" + cellX1 + " " + cellY1 + " cell2:" + cellX2 + " " + cellY2;
				console.log(error);
				throw error;
			}
			if (isInside(i*2*cellwidth+offsetToCenterTimesTwo, j*2*cellwidth+offsetToCenterTimesTwo)){
				
				tileListX.push(i);
				tileListY.push(j);
				// console.log(i + " " + j + " w:" + level.width + " h:" + level.height);
				
				over = true;
				yTrimmer = j;
			} else if (over) {
				break;
			}
		}
	}
	
	var avoidObstacles = "mouse_obstacle" in state.metadata;
	
	var otherTileListX = [cellX1];
	var otherTileListY = [cellY1];
	
	while(cellX1 !== cellX2 || cellY1 !== cellY2) {
		if (cellY1 >= curLevel.height || cellY1 < 0 || cellX1 >= curLevel.width || cellX1 < 0) {
			error = "Mouse input loop failed; cell1:" + cellX1 + " " + cellY1 + " cell2:" + cellX2 + " " + cellY2;
			console.log(error);
			throw error;
		}
		
		hitObstacle = function () {
			var coordIndex = screenOffsetY+cellY1 + (screenOffsetX+cellX1)*curLevel.height;
			var tile = curLevel.getCell(coordIndex);
			if (state.obstacleMask.anyBitsInCommon(tile)) {
				return true;
			} else {
				return false;
			}
		}
		
		cellCornerXTimesTwo = (cellX1*2)*cellwidth+offsetToCenterTimesTwo + xSign*cellwidth;
		cellCornerYTimesTwo = (cellY1*2)*cellwidth+offsetToCenterTimesTwo + ySign*cellwidth;
		fOfPointTimesTwo = dirY*cellCornerXTimesTwo - dirX*cellCornerYTimesTwo;
		if ((fOfPointTimesTwo > scaledShiftMid*2 == ySign > 0) != (xSign > 0)) {
			cellX1 += xSign;
			if (avoidObstacles && hitObstacle()) {
				cellX1 -= xSign;
				cellY1 += ySign;
			}
		} else {
			cellY1 += ySign;
			if (avoidObstacles && hitObstacle()) {
				cellY1 -= ySign;
				cellX1 += xSign;
			}
		}
		
		if (!(avoidObstacles && hitObstacle())) {
			otherTileListX.push(cellX1);
			otherTileListY.push(cellY1);
		} else {
			break;
		}
	}
			
	if (avoidObstacles) {
		tileListX = otherTileListX;
		tileListY = otherTileListY;
	} else for (var i=0; i<tileListX.length; i++) {
		if (tileListX[i] !== otherTileListX[i] || tileListY[i] !== otherTileListY[i]) {
			try {displayError("line tile placement algorithm discrepancies detected");} catch(e){}
			consolePrint("line tile placement algorithm discrepancies detected", true);
			throw "line tile placement algorithm discrepancies detected";
		}
	}
	
	return {tileListX: tileListX, tileListY: tileListY};
}

var lastCoord;

var x1 = 5;
var y1 = 5;
var x2 = 5;
var y2 = 5;

function mouseAction(event,click,id) {
	if (debugSwitch.includes('input')) console.log('mouseAction', click, id);
	if (textMode) {
		// we only handle click actions -- not sure why this is here, but gets called by mouseMove()
		if (!click) {
			if (quittingTitleScreen) {return;}

			if (!mouseInCanvas || mouseCoordY < 0 || mouseCoordY > 12) {
				hoverSelection = -1;
			} else {
				hoverSelection = mouseCoordY;
			}
			return;
		}

		if (event.type != "mousedown" && event.type != "touchstart") {
			return;
		}

		if (titleScreen) {
			if (quittingTitleScreen || titleSelected) {
				return;
			}

			if (titleMode == 0) { //Title no save data
				generateTitleScreen(-1, 0, true);
				titleButtonSelected();
			} else if (titleMode == 1) {//Title with save data
				generateTitleScreen(-1, 0, hoverSelection);
				if (titleSelection)
					titleButtonSelected();
			} else if (titleMode===2) { //Level select
				generateLevelSelectScreen(-1, 0, mouseCoordY);
				if (titleSelection == 0)
					goToTitleScreen();
				else if (titleSelection) {
					titleSelected=true;
					timer=0;
					quittingTitleScreen=true;
				}
			} else if (titleMode == 3) { // pause screen select
				generatePauseScreen(-1, 0, mouseCoordY);
				//generatePauseScreen(-1, 0, hoverSelection);
				timer=0;
				quittingTitleScreen = true;
				redraw();
			}
		} else if (messageselected===false && (state.levels[curLevelNo].message || messagetext != "")) {
			messageselected=true;
			//console.log(`MA TS=${prevTimestamp} Timer = ${timer} qms=${quittingMessageScreen}`);
			timer=0;
			quittingMessageScreen=true;
			tryPlayCloseMessageSound();
			titleScreen=false;
			drawMessageScreen("");
		}
	} else {
		if (winning) {return;}

		x1 = x2;
		y1 = y2;
		x2 = mousePixelX;
		y2 = mousePixelY;

		// clamp mouse target pixel (for moving)
		x2 = Math.max(0, Math.min(cellwidth*screenwidth-1, mousePixelX));
		y2 = Math.max(0, Math.min(cellheight*screenheight-1, mousePixelY));
		
		if (!click) {
			var tileLists = getTilesTraversingPoints(x1, y1, x2, y2);
			var tileListX = tileLists.tileListX;
			var tileListY = tileLists.tileListY;
			
			for (var i=0; i<tileListX.length; i++) {
				
				var coordIndex = screenOffsetY+tileListY[i] + (screenOffsetX+tileListX[i])*curLevel.height;
				if (lastCoord===coordIndex) {
					continue;
				}
				lastCoord = coordIndex;
				
				if (againing) {
					//consolePrint("no mouse, againing",false);
				} else {
					pushInput(`mouse,${id},${coordIndex}`);
					mouseInput(id, coordIndex);  // refactor for makeGIF()
					event.handled = true;
				}
			}
		} else if (mouseCoordX>=0 && mouseCoordY>=0 && mouseCoordX<screenwidth && mouseCoordY<screenheight) {
			var coordIndex = screenOffsetY+mouseCoordY + (screenOffsetX+mouseCoordX)*curLevel.height;
			if (againing) {
				//consolePrint("no mouse, againing",false);
			} else {
				pushInput(`mouse,${id},${coordIndex}`);
				mouseInput(id, coordIndex);  // refactor for makeGIF()
				event.handled = true;
			}
		}
	}
}

function mouseInput(id, coordIndex) {
	if (id >= 0) {
		// drop an object at this location
		try {
			var bak = backupLevel();
			var cell = curLevel.getCell(coordIndex);
			cell.ibitset(id);
			curLevel.setCell(coordIndex, cell);
			var inputdir = 5;
			if (processInput(inputdir,false,false,bak)) {
				redraw();
			}
		} catch(e) {
			console.log(e);
			consolePrint(e,true);
		}
	} else {
		// don't drop an object, feed in a movement instead
		const inputdir = (id == -1) ? 6 : 7;  // todo: mclick
		if (processInput(inputdir, false, false, bak, coordIndex)) {
			redraw();
		}
	}
}

var anyEditsSinceMouseDown = false;

function onMouseDown(event, wasFiredByTouch = false) {
	//console.log("mouse down");
	if (event.handled){
		return;
	}

	ULBS();
	
	var lmb = event.button===0;
	var rmb = event.button===2 ;
	if (event.type=="touchstart"){
		lmb=true;
	}
	if (lmb && (event.ctrlKey||event.metaKey)){
		lmb=false;
		rmb=true;
	}
	
	if (lmb ) {
        lastDownTarget = event.target;
        keybuffer=[];
        if (event.target===canvas || event.target.className==="tapFocusIndicator") {
        	setMouseCoord(event);
        	dragging=true;
        	rightdragging=false;
        	anyEditsSinceMouseDown=false;
        	if (levelEditorOpened && !textMode) {
        		return levelEditorClick(event,true);
        	} else if ("mouse_left" in state.metadata) {
				if (wasFiredByTouch) {
					prevent(event)
				}
				return mouseAction(event,true,state.lmbID);		// must break to not execute dragging=false;
			} else if (state.metadata.mouse_clicks) {
				return mouseAction(event, true, -1); // trigger lclick
			}

        }
        dragging=false;
        rightdragging=false; 
    } else if (rmb) {
    	if (event.target.id==="gameCanvas") {
			setMouseCoord(event);
		    dragging=false;
		    rightdragging=true;
        	if (levelEditorOpened) {
        		return levelEditorRightClick(event,true);
        	} else if ("mouse_right" in state.metadata) {
				return mouseAction(event,true,state.rmbID);
			} else if (state.metadata.mouse_clicks) {
				return mouseAction(event, true, -2); // trigger rclick
			}
        } else {
			dragging=false;
			rightdragging=false;
		}
    } else if (event.button===1) {
		//undo
		if (textMode===false && (IsMouseGameInputEnabled() || levelEditorOpened)) {
			pushInput("undo");
			DoUndo(false,true);
			canvasResize(); // calls redraw
			return prevent(event);
		}
	}
	event.handled=true;

}

function rightClickCanvas(event) {
	//console.log("rightClickCanvas");
	// cannot setMouseCoord() here -- crashes -- but assume it's been set
	if (mouseCoordX >= 0 && mouseCoordY >= 0 && mouseCoordX < screenwidth && mouseCoordY < screenheight) {
		return prevent(event);
	}
	if (levelEditorOpened) {
		return prevent(event);
	}
}

function onMouseUp(event, wasFiredByTouch = false) {
	if (event.handled){
		return;
	}

	dragging=false;
    rightdragging=false;

	var lmb = event.button===0;
	var rmb = event.button===2;
	if (event.type=="touchend"){
		lmb=true;
	}

	if (lmb) {
        if (event.target===canvas) {
        	setMouseCoord(event);
        	if ("mouse_up" in state.metadata) {
				if (wasFiredByTouch) {
					prevent(event)
				} //Prevent "ghost click" on mobile
				return mouseAction(event,true,state.lmbupID);
			}
        }
    } else if (rmb) {
    	if (event.target.id==="gameCanvas") {
        	setMouseCoord(event);
        	if ("mouse_rup" in state.metadata) {
				return mouseAction(event,true,state.rmbupID);
			}
        }
    }
	event.handled=true;
}

function onKeyDown(event) {
	//console.log(`keycode ${event.keyCode}`);

	ULBS();
	// Prevent arrows/space from scrolling page
	if ((!IDE) && ([32, 37, 38, 39, 40].indexOf(event.keyCode) > -1)) {
		if (event&&(event.ctrlKey || event.metaKey)){
		} else {
			prevent(event);
		}
	}

	if ((!IDE) && event.keyCode===77){//m
		toggleMute();		
	}

	// discard duplicates, but don't pass them through either
    if (keybuffer.indexOf(event.keyCode)>=0) {
    	return prevent(event);
    }

    if(lastDownTarget === canvas || (window.Mobile && (lastDownTarget === window.Mobile.focusIndicator) ) ){
    	if (keybuffer.indexOf(event.keyCode)===-1) {
    		if (event&&(event.ctrlKey || event.metaKey)){
		    } else {
    		    keybuffer.splice(keyRepeatIndex,0,event.keyCode);
	    	    keyRepeatTimer=0;
	    	    checkKey(event,!event.repeat);
		    }
		}
	}


    if (canDump===true) {
        if (event.keyCode===74 && (event.ctrlKey||event.metaKey)) {//ctrl+j
            dumpTestCase();
            prevent(event);
        } else if (event.keyCode===75 && (event.ctrlKey||event.metaKey)) {//ctrl+k
            makeGIF();
            prevent(event);
        }  else if (event.keyCode===83 && (event.ctrlKey||event.metaKey)) {//ctrl+s
            saveClick();
            prevent(event);
		// avoid conflicts with codemirror key bindings
        // }  else if (event.keyCode===66 && (event.ctrlKey||event.metaKey)) {//ctrl+b
        //     rebuildClick();
        //     prevent(event);
        //     event.target.blur();
        //     canvas.focus();
        // }  else if (event.keyCode===88 && (event.ctrlKey||event.metaKey)) {//ctrl+x
        //     runClick();
        //     prevent(event);
        //     event.target.blur();
        //     canvas.focus();
        }  else if (event.keyCode===120) { //f9
            prevent(event);
        	solve();
        }  else if (event.keyCode===119) { //f8
            prevent(event);
        	stopSolving();
        } else if (event.keyCode===13 && (event.ctrlKey||event.metaKey)){//ctrl+enter
			canvas.focus();
			editor.display.input.blur();
			if (event.shiftKey){
				runClick();
			} else {
				rebuildClick();
			}
			prevent(event);
            event.target.blur();
            canvas.focus();
		}
	}
}

function relMouseCoords(event){
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var currentElement = this;

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
    }
    while(currentElement = currentElement.offsetParent)

	if (event.touches && event.touches.length >= 1){
		canvasX = event.touches[0].pageX - totalOffsetX;
		canvasY = event.touches[0].pageY - totalOffsetY;
	} else if (event.changedTouches != null && event.changedTouches.length >= 1) {
		canvasX = event.changedTouches[0].pageX - totalOffsetX;
		canvasY = event.changedTouches[0].pageY - totalOffsetY;
	} else {
		canvasX = event.pageX - totalOffsetX;
		canvasY = event.pageY - totalOffsetY;
	}

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

function onKeyUp(event) {
	//event = event || window.event;
	var index=keybuffer.indexOf(event.keyCode);
	if (index>=0){
    	keybuffer.splice(index,1);
    	if (keyRepeatIndex>=index){
    		keyRepeatIndex--;
    	}
    }
}

function onMyFocus(event) {	
	keybuffer=[];
	keyRepeatIndex = 0;
	keyRepeatTimer = 0;
}

function onMyBlur(event) {
	keybuffer=[];
	keyRepeatIndex = 0;
	keyRepeatTimer = 0;
}

var mouseCoordX=0;
var mouseCoordY=0;
var mousePixelX=0;
var mousePixelY=0;

function setMouseCoord(e){
	var coords = canvas.relMouseCoords(e);

	//Fake mobile presses can generate mouse clicks resulting into this function. This is required, otherwise the state of the game seems to get weird, somehow. The following values are allowed to be NaN and should be checked as such. This is a little hacky though, apoligies. See PS+ issue #88

    mousePixelX=coords.x-xoffset;
	mousePixelY=coords.y-yoffset;
	mouseCoordX=Math.floor(mousePixelX/cellwidth);
	mouseCoordY=Math.floor(mousePixelY/cellheight);
}

function mouseMove(event) {
	
	if (event.handled){
		return;
	}

    if (levelEditorOpened) {
    	setMouseCoord(event);
    	if (dragging) { 	
    		levelEditorClick(event,false);
    	} else if (rightdragging){
    		levelEditorRightClick(event,false);
    	}
	    redraw();
	} else if (titleScreen && IsMouseGameInputEnabled()) {
		var prevHoverSelection = hoverSelection;
		setMouseCoord(event);
		mouseAction(event,false,null);
		if (prevHoverSelection != hoverSelection) {
			if (titleMode == 1) {
				generateTitleScreen(hoverSelection);
			} else if (titleMode == 2) {
				generateLevelSelectScreen(hoverSelection);
			} else if (titleMode == 3) {
				generatePauseScreen(hoverSelection);
			}
		}
	} else if (dragging && "mouse_drag" in state.metadata) {
    	setMouseCoord(event);
    	mouseAction(event,false,state.dragID);
	    redraw();
	} else if (rightdragging && "mouse_rdrag" in state.metadata) {
    	setMouseCoord(event);
		mouseAction(event,false,state.rdragID);
	    redraw();
	}

	event.handled=true;
}

// bug: if game starts with mouse already in canvas, it will not get set true
let mouseInCanvas = false;

function onMouseIn() {
	mouseInCanvas = true;
}

function onMouseOut() {
	mouseInCanvas = false;
}

document.addEventListener('touchstart', onTouchDown, {passive: false});
document.addEventListener('touchmove', mouseMove, false);
document.addEventListener('touchend', onTouchUp, {passive: false});

function onTouchDown(event) {
	onMouseDown(event, true)
}

function onTouchUp(event) {
	onMouseUp(event, true)
}

document.addEventListener('mousedown', onMouseDown, false);
document.addEventListener('mouseup', onMouseUp, false);
document.addEventListener('mousemove', mouseMove, false);

document.addEventListener('contextmenu', rightClickCanvas, false);
document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);
document.addEventListener('wheel', onMouseWheel, {passive: false})
window.addEventListener('focus', onMyFocus, false);
window.addEventListener('blur', onMyBlur, false);
canvas.addEventListener('mouseenter', onMouseIn, false);
canvas.addEventListener('mouseleave', onMouseOut, false)

function onMouseWheel(event) {

	if (!mouseInCanvas || event.ctrlKey) {return;}

	normalizedDelta = Math.sign(event.deltaY);

	if (titleScreen && titleMode == 2 && (IsMouseGameInputEnabled())) {
		levelSelectScroll(normalizedDelta);

		redraw();
		prevent(event)
	}
	if (levelEditorOpened) {
		glyphSelectedIndex = clamp(glyphSelectedIndex + normalizedDelta, 0, glyphCount() - 1);
		redraw();
		prevent(event)
	}
}

function levelSelectScroll(direction) {
	levelSelectScrollPos = clamp(levelSelectScrollPos + direction, 0, Math.max(state.sections.length - amountOfLevelsOnScreen, 0));
	titleSelection = clamp(titleSelection + direction, 0, state.sections.length - 1);
	generateLevelSelectScreen();
}

function clamp(number, min, max) {
	return Math.min(Math.max(number, min), max);
}

function prevent(e) {
    if (e.preventDefault) e.preventDefault();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    if (e.stopPropagation) e.stopPropagation();
    e.returnValue=false;
    return false;
}

function titleButtonSelected() {
	if (!titleSelected) {
		tryPlayStartGameSound();
		titleSelected=true;
		timer=0;
		quittingTitleScreen=true;
		canvasResize();

		document.dispatchEvent(new Event("psplusGameStarted"));
	}
}

var gamepadKeys = []; // used to store keys held at previous frame

function pollGamepads() {
	function buttonCheck(buttons, i) {
		if(buttons.length < i) {
			return false;
		}
		
		if(typeof(buttons[i]) == "object") {
			return buttons[i].pressed;
		}
	
		return buttons[i] == 1.0;
	}
	function axisCheck(axes, i, dir) {
		if(axes.length < i) {
			return false;
		}
		
		return axes[i] * dir > 0.5;
	}

	var newGamepadKeys = [];

	function keyPressed(keycode) {
    	if(keybuffer.indexOf(keycode) === -1) {
    		keybuffer.splice(keyRepeatIndex, 0, keycode);
	    	keyRepeatTimer = 0;
	    	checkKey({keyCode: keycode}, true);
		}

		newGamepadKeys.splice(0, 0, keycode);
	}

	// clear any keys previously pressed but no longer held:
	function clear() {
		for(var k = 0; k < gamepadKeys.length; k++) {
			if(newGamepadKeys.indexOf(gamepadKeys[k]) >= 0) {
				continue;
			}

			var index = keybuffer.indexOf(gamepadKeys[k]);
			if(index >= 0) {
				keybuffer.splice(index, 1);
				if(keyRepeatIndex >= index) {
					keyRepeatIndex--;
				}
			}
		}

		gamepadKeys = newGamepadKeys;
	}

	var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
	if(gamepads == null || gamepads.length == 0) {
		clear();
		return;
	}

	for(var i = 0; i < gamepads.length; i++) {
		var gamepad = gamepads[i];
		
		if(gamepad == null || !gamepad.connected) {
			continue;
		}

		if(buttonCheck(gamepad.buttons, 3) // Y
			|| buttonCheck(gamepad.buttons, 4)) { // LB
			
			keyPressed(82); // restart
		}
		if(buttonCheck(gamepad.buttons, 1) // B
			|| axisCheck(gamepad.axes, 2, 1)) { // LT
			
			keyPressed(90); // undo
		}
		if(buttonCheck(gamepad.buttons, 2) // X
			|| buttonCheck(gamepad.buttons, 0) // A
			|| buttonCheck(gamepad.buttons, 5) // RB
			|| axisCheck(gamepad.axes, 1, 1)) { // RT
			
			keyPressed(88); // action
		}
		if(buttonCheck(gamepad.buttons, 7)) { // menu button
			keyPressed(27); // exit
		}
		if(buttonCheck(gamepad.buttons, 6)) { // change view button
			keyPressed(69); // edit
		}
		if(axisCheck(gamepad.axes, 0, 1) // right
			|| axisCheck(gamepad.axes, 6, 1)) { // D-pad right
			
			keyPressed(39); // right
		}
		if(axisCheck(gamepad.axes, 0, -1) // left
			|| axisCheck(gamepad.axes, 6, -1)) { // D-pad left
			
			keyPressed(37); // left
		}
		if(axisCheck(gamepad.axes, 1, -1) // up
			|| axisCheck(gamepad.axes, 7, -1)) { // D-pad up
			
			keyPressed(38); // up
		}
		if(axisCheck(gamepad.axes, 1, 1) // down
			|| axisCheck(gamepad.axes, 7, 1)) { // D-pad down
			
			keyPressed(40); // down
		}
	}

	clear();
}

let debugTimestamp
function checkKey(e,justPressed) {
    if (debugSwitch.includes('input') && justPressed) console.log('checkKey', prevTimestamp, e, justPressed);
    if (debugSwitch.includes('key')) {
		const ele = document.getElementById('debug');
		if (ele)
			ele.innerHTML = `key-${e.keyCode} just=${justPressed} last=${~~(prevTimestamp-debugTimestamp)} TS=${~~prevTimestamp} delta=${~~(deltatime*1000)} keybuffer=${keybuffer.length}`;
		debugTimestamp = prevTimestamp;
	}
	ULBS();
	
    if (winning) {
    	return;
	}
	if (e&&(e.ctrlKey || e.metaKey|| e.altKey)){
		return;
	}
	
    var inputdir=-1;
    switch(e.keyCode) {
        case 65://a
        case 37: //left
        {
			inputdir = dirNames.indexOf('left');
        break;
        }
        case 38: //up
        case 87: //w
        {
			inputdir = dirNames.indexOf('up');
        break;
        }
        case 68://d
        case 39: //right
        {
			inputdir = dirNames.indexOf('right');
        break;
        }
        case 83://s
        case 40: //down
        {
			inputdir = dirNames.indexOf('down');
        break;
        }
        case 80://p
        {
			printLevel();
			return prevent(e);
        }
        case 13://enter
        case 32://space
        //case 67://c
        case 88://x
        {
			if (justPressed && ignoreNotJustPressedAction){
				ignoreNotJustPressedAction=false;
			}
			if (justPressed===false && ignoreNotJustPressedAction){
				return prevent(e);
			}
			if (norepeat_action===false || justPressed) {
				inputdir = dirNames.indexOf('action');		// todo: reaction
            } else {
            	return prevent(e);
            }
        break;
        }
        case 85://u
        case 90://z
        {
            //undo
            if (!textMode) {
                pushInput("undo");
                DoUndo(false,true);
                canvasResize(); // calls redraw
            	return prevent(e);
            }
            break;
        }
        case 82://r
        {
        	if (!textMode) {
        		if (justPressed) {
	        		pushInput("restart");
	        		DoRestart();
	                canvasResize(); // calls redraw
            		return prevent(e);
            	}
            }
            break;
        }
        case 27://escape
        {
        	if(solving) {
        		stopSolving();
        		break;
        	}
			if (!titleScreen) {
				goToPauseScreen(); 
				canvasResize();
			} else if (!titleScreen || titleMode > 1) {
				if ((timer/1000>0.5 || titleMode > 1) && !quittingTitleScreen && justPressed) {

					titleSelection = 0;
					
					timer = 0;
					if(titleScreen === false && state.metadata["level_select"] !== undefined) {
						gotoLevelSelectScreen();
					} else {
						goToTitleScreen();
					}

					tryPlayTitleSound();
					canvasResize();
				}

				return prevent(e)
        	}
        	break;
        }
        case 69: {//e
        	if (!solving && canOpenEditor) {
        		if (justPressed) {
        			if (titleScreen){
        				if (state.title==="EMPTY GAME"){
        					compile(["loadFirstNonMessageLevel"]);
        				} else {
        					nextLevel();
        				}
        			}
        			levelEditorOpened=!levelEditorOpened;
        			if (levelEditorOpened===false){
        				printLevel();
        			}
        			restartTarget=backupLevel();
        			canvasResize();
        		}
        		return prevent(e);
        	}
            break;
		}
		case 48://0
		case 49://1
		case 50://2
		case 51://3
		case 52://4
		case 53://5
		case 54://6
		case 55://7
		case 56://8
		case 57://9
		{
        	if (levelEditorOpened&&justPressed) {
        		var num=9;
        		if (e.keyCode>=49)  {
        			num = e.keyCode-49;
        		}

				if (num<glyphImages.length) {
					glyphSelectedIndex=num;
				} else {
					consolePrint("Trying to select tile outside of range in level editor.",true)
				}

        		canvasResize();
        		return prevent(e);
        	}	
        	break;	
        }
		case 189://-
		{
        	if (levelEditorOpened&&justPressed) {
				if (glyphSelectedIndex>0) {
					glyphSelectedIndex--;
					canvasResize();
					return prevent(e);
				} 
        	}	
        	break;	
		}
		case 187://+
		{
        	if (levelEditorOpened&&justPressed) {
				if (glyphSelectedIndex+1<glyphImages.length) {
					glyphSelectedIndex++;
					canvasResize();
					return prevent(e);
				} 
        	}	
        	break;	
		}
		case 33://PgUp
		{
			if (!textMode && showLayers) {
				showLayerNo++;	// will be range checked on use
				canvasResize();
				return prevent(e);
			}
		}
		case 34://PgDn
		{
			if (!textMode && showLayers) {
				showLayerNo--;	// will be range checked on use
				canvasResize();
				return prevent(e);
			}
		}
    }
    if (debugSwitch.includes('input')) console.log('checkKey', prevTimestamp, throttle_movement, inputdir, input_throttle_timer, repeatinterval);
    if (throttle_movement && inputdir>=0&&inputdir<=3) {
    	if (lastinput==inputdir && input_throttle_timer<repeatinterval) {
    		return prevent(e);
    	}else {
    		lastinput=inputdir;
    		input_throttle_timer=0;
    	}
    }
    if (textMode) {
		if(!throttle_movement) { //If movement isn't throttled, then throttle it anyway
			if (!titleScreen && lastinput==inputdir && input_throttle_timer < repeatinterval) { //Don't throttle on level select
				return prevent(e);
			} else {
				lastinput=inputdir;
				input_throttle_timer=0;
			}
		}
		
    	if (state.levels.length===0) {
    		//do nothing
    	} else if (titleScreen) {
			if (isSitelocked()) {return prevent(e);}
			if (quittingTitleScreen===false){
				if (titleMode===0) {
					if (inputdir===4&&justPressed) {
						generateTitleScreen(-1, 0, true);
						titleButtonSelected();
						clearInputHistory();
					}
				} else if (titleMode == 3) {
					if (inputdir == 4 && justPressed) {
						generatePauseScreen(-1, 0, levelSelectScrollPos);
						timer = 0;
						quittingTitleScreen=true;
						redraw();
					} else if (inputdir == 0 || inputdir == 2) {
						generatePauseScreen(-1, inputdir == 0 ? -1 : 1);
					}
				} else {
					if (inputdir==4&&justPressed) {
						if (titleSelected===false) {    				
							tryPlayStartGameSound();
							titleSelected=true;
							timer=0;
							quittingTitleScreen=true;
							
							if(titleMode == 1) {
								generateTitleScreen(-1, 0, levelSelectScrollPos);
								document.dispatchEvent(new Event("psplusGameStarted"));
							} else if(titleMode == 2) {
								generateLevelSelectScreen(-1, 0, levelHighlightLine);
							}
						}
					}
					else if (inputdir===0||inputdir===2) {
						if (quittingTitleScreen || titleSelected) {
							return prevent(e);
						}
						if(titleMode == 1) {
							generateTitleScreen(-1, inputdir == 0 ? -1 : 1);
						} else if(titleMode == 2) {
							generateLevelSelectScreen(-1, inputdir == 0 ? -1 : 1);
						} else if (titleMode == 3) {
							generatePauseScreen(-1, inputdir == 0 ? -1 : 1);
						}
					}
				}
			}
    	} else {
    		if (inputdir==4&&justPressed) {    				
				if (unitTesting) {
					nextLevel();
					return prevent(e);
				} else if (messageselected===false) {
					//console.log(`CK TS=${prevTimestamp} Timer = ${timer} qms=${quittingMessageScreen}`);
    				messageselected=true;
    				timer=0;
    				quittingMessageScreen=true;
    				tryPlayCloseMessageSound();
    				titleScreen=false;
    				drawMessageScreen("");
    			}
    		}
    	}
		return prevent(e);
    } else {
	    if (!againing && inputdir>=0) {
            if (inputdir===4 && ('noaction' in state.metadata)) {

            } else {
                pushInput(inputdir);
                if (processInput(inputdir)) {
                    redraw();
                }
	        }
	       	return prevent(e);
    	}
    }
	return prevent(e);
}

// called on every clock tick
function update() {
    var draw = false;

	timer+=deltatime;
	tweentimer+=deltatime;
	input_throttle_timer+=deltatime;

    if (quittingTitleScreen) {
        if (timer/1000>0.3) {
			quittingTitleScreen=false;
			
			if(titleMode <= 1) {
				nextLevel();
			} else if(titleMode == 2) {
				gotoLevel(titleSelection);
			} else if(titleMode == 3) {
				selectPauseScreen();
			}
        }
    }
    if (againing) {
        if (timer>againinterval && messagetext == "") {
            if (processInput(-1)) {
                draw = true;
                keyRepeatTimer=0;
                autotick=0;
            }
        }
    }
    if (quittingMessageScreen) {
		//console.log(`UP TS=${prevTimestamp} Timer = ${timer} qms=${quittingMessageScreen}`);
        if (timer/1000>0.15) {
            quittingMessageScreen=false;
            if (state.levels[curLevelNo].message) {
            	nextLevel();
            } else {
            	messagetext="";
            	textMode=false;
				titleScreen=false;
				titleMode=(curLevelNo>0||curlevelTarget!==null)?1:0;
				titleSelected=false;
				ignoreNotJustPressedAction=true;
				titleSelection=0;
    			canvasResize();  
    			checkWin();          	
            }
        }
    }
    if (winning) {
        if (timer/1000>0.5) {
            winning=false;
            nextLevel();
        }
	}
	
	pollGamepads();

    if (keybuffer.length>0) {
	    keyRepeatTimer+=deltatime;
	    var ticklength = throttle_movement ? repeatinterval : repeatinterval/(Math.sqrt(keybuffer.length));
	    if (keyRepeatTimer>ticklength) {
			keyRepeatTimer=0;	
	    	keyRepeatIndex = (keyRepeatIndex+1)%keybuffer.length;
	    	var key = keybuffer[keyRepeatIndex];
			if (debugSwitch.includes('key')) {
				const ele = document.getElementById('debug');
				if (ele)
					ele.innerHTML = `key-${key} TL=${~~ticklength} last=${~~(prevTimestamp-debugTimestamp)} TS=${~~prevTimestamp} delta=${~~(deltatime*1000)} keybuffer=${keybuffer.length}`;
				debugTimestamp = prevTimestamp;
			}
	        checkKey({keyCode:key},false);
	    }
	}

    if (autotickinterval>0&&!textMode&&!levelEditorOpened&&!againing&&!winning) {
        autotick+=deltatime;
        if (autotick>autotickinterval) {
            autotick=0;
            pushInput("tick");
            if (processInput(-1)) {
                draw = true;
            }
        }
    }

	// force redraw to update animations
	if (draw || isAnimating) {
	  	redraw();
	}
}

var prevTimestamp;
// Lights, camera…function!
var loop = function(timestamp){
	if (prevTimestamp !== undefined) {
		deltatime = timestamp - prevTimestamp
		if (debugSwitch.includes('key')) {
			const ele = document.getElementById('debug');
			if (ele)
				ele.innerHTML = `timer=${timer.toFixed()} TS=${~~timestamp} delta=${~~(deltatime*1000)} KB=${keybuffer.length}`;
		}
	}
	prevTimestamp = timestamp
	try {
		update();
	}
	catch (e) {
		//Something went wrong, but it's more important that the loop doesn't crash during errors
		console.error(e);
	}
	// requestAnimationFrame will call loop() at the 
	// browser's refresh rate (generally 60fps)
	// and will auto pause/unpause when the window is minimized
	window.requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);

</script>
<script>
/*
 * Add gesture support for mobile devices.
 */

window.Mobile = {};

//stolen from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
Mobile.hasTouch = function() {
    var bool;
    if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch)     {
      bool = true;
    } else {
      /*
      //don't know what's happening with this, so commented it out
      var query = ['@media (',prefixes.join('touch-enabled),    ('),'heartz',')','{#modernizr{top:9px;position:absolute}}'].join('');
      testStyles(query, function( node ) {
        bool = node.offsetTop === 9;
      });*/
    }
    return bool;
}

Mobile.enable = function (force) {
    if (force || Mobile.hasTouch() && !Mobile._instance) {
        Mobile._instance = new Mobile.GestureHandler();
        Mobile._instance.bindEvents();
        Mobile._instance.bootstrap();
    }
    return Mobile._instance;
};

window.Mobile.GestureHandler = function () {
    this.initialize.apply(this, arguments);
};

Mobile.log = function (message) {
    var h1;
    h1 = document.getElementsByTagName('h1')[0];
    h1.innerHTML = "" + Math.random().toString().substring(4, 1) + "-" + message;
};

Mobile.debugDot = function (event) {
    var dot, body, style

    style = 'border-radius: 50px;' +
        'width: 5px;' +
        'height: 5px;' +
        'background: red;' +
        'position: absolute;' +
        'left: ' + event.touches[0].clientX + 'px;' +
        'top: ' + event.touches[0].clientY + 'px;';
    dot = document.createElement('div');
    dot.setAttribute('style', style);
    body = document.getElementsByTagName('body')[0];
    body.appendChild(dot);
};

(function (proto) {
    'use strict';

    // Minimum range to begin looking at the swipe direction, in pixels
    var SWIPE_THRESHOLD = 10;
    // Distance in pixels required to complete a swipe gesture.
    var SWIPE_DISTANCE = 50;
    // Time in milliseconds to complete the gesture.
    var SWIPE_TIMEOUT = 1000;
    // Time in milliseconds to repeat a motion if still holding down,
    // ... and not specified in state.metadata.key_repeat_interval.
    var DEFAULT_REPEAT_INTERVAL = 150;

    // Lookup table mapping action to keyCode.
    var CODE = {
        action:  88, // x
        left:    37, // left arrow
        right:   39, // right arrow
        up:      38, // up arrow
        down:    40, // down arrow
        undo:    85, // u
        restart: 82, // r
        quit:    27 // escape
    }

    var TAB_STRING = [
        '<div class="tab">',
        '  <div class="tab-affordance"></div>',
        '  <div class="tab-icon">',
        '    <div class="slice"></div>',
        '    <div class="slice"></div>',
        '  </div>',
        '</div>'
    ].join("\n");

    /** Bootstrap Methods **/

    proto.initialize = function () {
        this.firstPos = { x: 0, y: 0 };
        this.setTabAnimationRatio = this.setTabAnimationRatio.bind(this);
        this.setMenuAnimationRatio = this.setMenuAnimationRatio.bind(this);
        this.repeatTick = this.repeatTick.bind(this);
        this.isFocused = true;
    };

    // assign the element that will allow tapping to toggle focus.
    proto.setFocusElement = function (focusElement) {
        this.focusElement = focusElement;
        this.isFocused = false;
        this.buildFocusIndicator();
    };

    proto.bindEvents = function () {
        window.addEventListener('touchstart', this.onTouchStart.bind(this));
        window.addEventListener('touchend', this.onTouchEnd.bind(this));
        window.addEventListener('touchmove', this.onTouchMove.bind(this));
    };

    proto.bootstrap = function () {
        this.showTab();
        this.disableScrolling();
        if (!this.isAudioSupported()) {
            this.disableAudio();
        }
        this.disableSelection();
    };

    /** Event Handlers **/

    proto.onTouchStart = function (event) {
        if (this.isTouching) {
            return;
        }

        // Handle focus changes used in editor.
        this.handleFocusChange(event);
        if (!this.isFocused) {
            return;
        }

        if (event.target.tagName.toUpperCase() === 'A') {
            return;
        }
        this.isTouching = true;

        this.mayBeSwiping = true;
        this.gestured = false;

        this.swipeDirection = undefined;
        this.swipeDistance = 0;
        this.startTime = new Date().getTime();

        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    };

    proto.onTouchEnd = function (event) {
        if (!this.isFocused) {
            return;
        }
        if (!this.isTouching) {
            // If we're here, the menu event handlers had probably
            // canceled the touchstart event.
            return;
        }
        if (!this.gestured) {
            if (event.touches.length === 0 && event.target.id!=="unMuteButton" && event.target.id!=="muteButton" ) {
                this.handleTap();
            }
        }

        // The last finger to be removed from the screen lets us know
        // we aren't tracking anything.
        if (event.touches.length === 0) {
            this.isTouching = false;
            this.endRepeatWatcher();
        }
    };

    proto.onTouchMove = function (event) {
        if (!this.isFocused) {
            return;
        }
        if (levelEditorOpened){
            return;
        }
        if (this.isSuccessfulSwipe()) {
            this.handleSwipe(this.swipeDirection, this.touchCount);
            this.gestured = true;
            this.mayBeSwiping = false;
            this.beginRepeatWatcher(event);
        } else if (this.mayBeSwiping) {
            this.swipeStep(event);
        } else if (this.isRepeating) {
            this.repeatStep(event);
        }

        prevent(event);
        return false;
    };

    proto.handleFocusChange = function (event) {
        if (!this.focusElement) {
            return;
        }

        this.isFocused = this.isTouchInsideFocusElement(event);
        this.setFocusIndicatorVisibility(this.isFocused);
        
        canvas.focus();
        editor.display.input.blur();
    };

    proto.isTouchInsideFocusElement = function (event) {
        var canvasPosition;

        if (!event.touches || !event.touches[0]) {
            return false;
        }
        canvasPosition = this.absoluteElementPosition(this.focusElement);

        if (event.touches[0].clientX < canvasPosition.left ||
            event.touches[0].clientY < canvasPosition.top) {
            return false;
        }

        if (event.touches[0].clientX > canvasPosition.left + this.focusElement.clientWidth ||
            event.touches[0].clientY > canvasPosition.top + this.focusElement.clientHeight) {
            return false;
        }

        return true;
    };

    proto.setFocusIndicatorVisibility = function (isVisible) {
        var visibility;

        visibility = 'visible';
        if (!isVisible) {
            visibility = 'hidden';
        }
        // this.focusIndicator.setAttribute('style', 'visibility: ' + visibility + ';');
    };

    proto.absoluteElementPosition = function (element) {
        var position, body;

        position = {
            top: element.offsetTop || 0,
            left: element.offsetLeft || 0
        };
        body = document.getElementsByTagName('body')[0];
        position.top -= body.scrollTop || 0;

        while (true) {
            element = element.offsetParent;
            if (!element) {
                break;
            }
            position.top += element.offsetTop || 0;
            position.left += element.offsetLeft || 0;
        }

        return position;
    };

    proto.beginRepeatWatcher = function (event) {
        var repeatIntervalMilliseconds;
        if (this.repeatInterval) {
            return;
        }
        this.isRepeating = true;
        repeatIntervalMilliseconds = state.metadata.key_repeat_interval * 1000;
        if (isNaN(repeatIntervalMilliseconds) || !repeatIntervalMilliseconds) {
            repeatIntervalMilliseconds = DEFAULT_REPEAT_INTERVAL;
        }
        this.repeatInterval = setInterval(this.repeatTick, repeatIntervalMilliseconds);
        this.recenter(event);
    };

    proto.endRepeatWatcher = function () {
        if (this.repeatInterval) {
            clearInterval(this.repeatInterval);
            delete this.repeatInterval;
            this.isRepeating = false;
        }
    };

    proto.repeatTick = function () {
        if (this.isTouching) {
            this.handleSwipe(this.direction, this.touchCount);
        }
    };

    // Capture the location to consider the gamepad center.
    proto.recenter = function (event) {
        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    }

    /** Detection Helper Methods **/

    proto.isSuccessfulSwipe = function () {
        var isSuccessful;

        if (this.mayBeSwiping &&
            this.swipeDirection !== undefined &&
            this.swipeDistance >= SWIPE_DISTANCE) {
            isSuccessful = true;
        }

        return isSuccessful;
    };

    // Examine the current state to see what direction they're swiping and
    // if the gesture can still be considered a swipe.
    proto.swipeStep = function (event) {
        var currentPos, distance, currentTime;
        var touchCount;

        if (!this.mayBeSwiping) {
            return;
        }

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
        currentTime = new Date().getTime();
        touchCount = event.touches.length;

        this.swipeDistance = this.cardinalDistance(this.firstPos, currentPos);
        if (!this.swipeDirection) {
            if (this.swipeDistance > SWIPE_THRESHOLD) {
                // We've swiped far enough to decide what direction we're swiping in.
                this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
                this.touchCount = touchCount;
            }
        } else if (distance < SWIPE_DISTANCE) {
            // Now that they've committed to the swipe, look for misfires...

            direction = this.dominantDirection(this.firstPos, currentPos);
            // Cancel the swipe if the direction changes.
            if (direction !== this.swipeDirection) {
                this.mayBeSwiping = false;
            }
            // If they're changing touch count at this point, it's a misfire.
            if (touchCount < this.touchCount) {
                this.mayBeSwiping = false;
            }
        } else if (currentTime - this.startTime > SWIPE_TIMEOUT) {
            // Cancel the swipe if they took too long to finish.
            this.mayBeSwiping = false;
        }
    };

    proto.repeatStep = function (event) {
        var currentPos, distance, currentTime;
        var newDistance, direction;

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };

        newDistance = this.cardinalDistance(this.firstPos, currentPos);

        if (newDistance >= SWIPE_DISTANCE) {
            this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
            this.recenter(event);
        }
    };

    // Find the distance traveled by the swipe along compass directions.
    proto.cardinalDistance = function (firstPos, currentPos) {
        var xDist, yDist;

        xDist = Math.abs(firstPos.x - currentPos.x);
        yDist = Math.abs(firstPos.y - currentPos.y);

        return Math.max(xDist, yDist);
    };

    // Decide which direction the touch has moved farthest.
    proto.dominantDirection = function (firstPos, currentPos) {
        var dx, dy;
        var dominantAxis, dominantDirection;

        dx = currentPos.x - firstPos.x;
        dy = currentPos.y - firstPos.y;

        dominantAxis = 'x';
        if (Math.abs(dy) > Math.abs(dx)) {
            dominantAxis = 'y';
        }

        if (dominantAxis === 'x') {
            if (dx > 0) {
                dominantDirection = 'right';
            } else {
                dominantDirection = 'left';
            }
        } else {
            if (dy > 0) {
                dominantDirection = 'down';
            } else {
                dominantDirection = 'up';
            }
        }

        return dominantDirection;
    };

    /** Action Methods **/

    // Method to be called when we've detected a swipe and some action
    // is called for.
    proto.handleSwipe = function (direction, touchCount) {
        if (IsMouseGameInputEnabled()) {
            return;
        }

        if (touchCount === 1) {
            this.emitKeydown(this.swipeDirection);
        } else if (touchCount > 1) {
            // Since this was a multitouch gesture, open the menu.
            this.toggleMenu();
        }
    };

    proto.handleTap = function () {
        if (IsMouseGameInputEnabled()) {
            return;
        }

        this.emitKeydown('action');
    };

    // Fake out keypresses to acheive the desired effect.
    proto.emitKeydown = function (input) {
        if(!this.isMenuVisible && (input == 'undo' || input == 'restart' || input == 'quit')) {
            return;
        }

        var event;

        event = { keyCode: CODE[input] };

        this.fakeCanvasFocus();
        // Press, then release key.
        onKeyDown(event);
        onKeyUp(event);
    };

    proto.fakeCanvasFocus = function () {
        var canvas;

        canvas = document.getElementById('gameCanvas');
        onMouseDown({
            button: 0,
            target: canvas
        });
    };

    proto.toggleMenu = function () {
        if (this.isMenuVisible) {
            this.hideMenu();
        } else {
            this.showMenu();
        }
    };

    proto.showMenu = function () {
        if (!this.menuElem) {
            this.buildMenu();
        }
        this.getAnimatables().menu.animateUp();
        this.isMenuVisible = true;
        this.hideTab();
    };

    proto.hideMenu = function () {
        if (this.menuElem) {
            this.getAnimatables().menu.animateDown();
        }
        this.isMenuVisible = false;
        this.showTab();
    };

    proto.getAnimatables = function () {
        var self = this;
        if (!this._animatables) {
            this._animatables = {
                tab: Animatable('tab', 0.1, self.setTabAnimationRatio),
                menu: Animatable('menu', 0.1, self.setMenuAnimationRatio)
            }
        }
        return this._animatables;
    };

    proto.showTab = function () {
        if (!this.tabElem) {
            this.buildTab();
        }
        this.getAnimatables().tab.animateDown();
    };

    proto.hideTab = function () {
        if (this.tabElem) {
            this.tabElem.setAttribute('style', 'display: none;');
        }
        this.getAnimatables().tab.animateUp();
    };

    proto.buildTab = function () {
        var self = this;
        var tempElem, body;
        var openCallback;
        var tabElem;
        var assemblyElem;

        tempElem = document.createElement('div');
        tempElem.innerHTML = TAB_STRING;
        assemblyElem = tempElem.children[0];

        openCallback = function (event) {
            event.stopPropagation();
            self.showMenu();
        };
        this.tabAffordance = assemblyElem.getElementsByClassName('tab-affordance')[0];
        this.tabElem = assemblyElem.getElementsByClassName('tab-icon')[0];

        //the reason I'm adding all these empty click events is on safari to disable double-tap to zoom (also needs some other css settings. cf https://github.com/increpare/PuzzleScript/issues/599 SMGDH)
        this.tabAffordance.addEventListener('touchstart', openCallback);
        this.tabAffordance.addEventListener("click", event => {});
        this.tabElem.addEventListener('touchstart', openCallback);
        this.tabElem.addEventListener("click", event => {});

        body = document.getElementsByTagName('body')[0];
        body.appendChild(assemblyElem);
    };

    proto.buildMenu = function () {
        var self = this;
        var tempElem, body;
        var undo, restart, quit;
        var closeTab;
        var closeCallback;

        tempElem = document.createElement('div');
        tempElem.innerHTML = this.buildMenuString(state);
        this.menuElem = tempElem.children[0];
        this.closeElem = this.menuElem.getElementsByClassName('close')[0];

        closeCallback = function (event) {
            event.stopPropagation();
            self.hideMenu();
        };
        this.closeAffordance = this.menuElem.getElementsByClassName('close-affordance')[0];
        closeTab = this.menuElem.getElementsByClassName('close')[0];
        this.closeAffordance.addEventListener('touchstart', closeCallback);
        this.closeAffordance.addEventListener("click", event => {});
        closeTab.addEventListener('touchstart', closeCallback);
        closeTab.addEventListener("click", event => {});

        undo = this.menuElem.getElementsByClassName('undo')[0];
        if (undo) {
            undo.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('undo');
            });
            undo.addEventListener("click", event => {});
        }
        restart = this.menuElem.getElementsByClassName('restart')[0];
        if (restart) {
            restart.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('restart');
            });
            restart.addEventListener("click", event => {});
        }

        quit = this.menuElem.getElementsByClassName('quit')[0];
        quit.addEventListener('touchstart', function (event) {
            event.stopPropagation();
            self.emitKeydown('quit');
        });
        quit.addEventListener("click", event => {});

        body = document.getElementsByTagName('body')[0];
        body.appendChild(this.menuElem);
    };

    proto.buildMenuString = function (state) {
    // Template for the menu.
        var itemCount, menuLines;
        var noUndo, noRestart;

        noUndo = state.metadata.noundo;
        noRestart = state.metadata.norestart;

        itemCount = 3;
        if (noUndo) {
            itemCount -= 1;
        }
        if (noRestart) {
            itemCount -= 1;
        }

        menuLines = [
            '<div class="mobile-menu item-count-' + itemCount + '">',
            '  <div class="close-affordance"></div>',
            '  <div class="close">',
            '    <div class="slice"></div>',
            '    <div class="slice"></div>',
            '  </div>'
        ];

        if (!noUndo) {
            menuLines.push('  <div class="undo button">Undo</div>');
        }
        if (!noRestart) {
            menuLines.push('  <div class="restart button">Restart</div>');
        }
        menuLines = menuLines.concat([
            '  <div class="quit button">Quit to Menu</div>',
            '  <div class="clear"></div>',
            '</div>'
        ]);

        return menuLines.join("\n");
    };

    proto.buildFocusIndicator = function () {
        var focusElementParent;
        this.focusIndicator = document.createElement('DIV');
        this.focusIndicator.setAttribute('class', 'tapFocusIndicator');
        this.focusIndicator.setAttribute('style', 'visibility: hidden;');

        focusElementParent = this.focusElement.parentNode;
        focusElementParent.appendChild(this.focusIndicator);
    };

    proto.setTabAnimationRatio = function (ratio) {
        var LEFT = 18;
        var RIGHT = 48 + 18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;
        if (ratio >= 0.999) {
            this.tabAffordance.setAttribute('style', 'display: none;');
        } else {
            this.tabAffordance.setAttribute('style', 'display: block;');
        }
        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + (1 - ratio) + ';';
        style = opacityString + ' ' +
            'width: ' + size + 'px;';
        this.tabElem.setAttribute('style', style);
    };

    proto.setMenuAnimationRatio = function (ratio) {
        var LEFT = -48 - 18;
        var RIGHT = -18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;

        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + ratio + ';';
        style = 'left: ' + (size - 4) + 'px; ' +
            opacityString + ' ' +
            'width: ' + (-size) + 'px;';
        ratio = Math.round((ratio) * 1000) / 1000;

        if (ratio <= 0.001) {
            this.closeAffordance.setAttribute('style', 'display: none;');
            opacityString="display:none;"
        } else {
            this.closeAffordance.setAttribute('style', 'display: block;');
        }

        this.closeElem.setAttribute('style', style);

        this.menuElem.setAttribute('style', opacityString);
    };

    proto.disableScrolling = function() {
        var style = {
            height: "100%",
            overflow: "hidden",
            position: "fixed",
            width: "100%",
            margin: 0
        }
        
        var styleString = "";
        for (var key in style) {
            styleString += key + ": " + style[key] + "; ";
        }

        document.body.setAttribute('style', styleString)
    }

    /** Audio Methods **/

    proto.disableAudio = function () {
        // Overwrite the playseed function to disable it.
        window.playSeed = function () {};
    };

    proto.isAudioSupported = function () {
        var isAudioSupported = true;

        if (typeof webkitAudioContext !== 'undefined') {
            // We may be on Mobile Safari, which throws up
            // 'Operation not Supported' alerts when we attempt to
            // play Audio elements with "data:audio/wav;base64"
            // encoded HTML5 Audio elements.
            //
            // Switching to MP3 encoded audio may be the way we have
            // to go to get Audio working on mobile devices.
            //
            // e.g. https://github.com/rioleo/webaudio-api-synthesizer
            isAudioSupported = false;
        }

        return isAudioSupported;
    };

    /** Other HTML5 Stuff **/

    proto.disableSelection = function () {
        var body;
        body = document.getElementsByTagName('body')[0];
        body.setAttribute('class', body.getAttribute('class') + ' disable-select');
    };

}(window.Mobile.GestureHandler.prototype));

window.Animator = function () {
    this.initialize.apply(this, arguments);
};

(function (proto) {
    proto.initialize = function () {
        this._animations = {};
        this.tick = this.tick.bind(this);
    };

    proto.animate = function (key, tick) {
        this._animations[key] = tick;
        this.wakeup();
    };

    proto.wakeup = function () {
        if (this._isAnimating) {
            return;
        }
        this._isAnimating = true;
        this.tick();
    };

    proto.tick = function () {
        var key;
        var isFinished, allFinished;
        var toRemove, index;

        toRemove = [];
        allFinished = true;
        for (key in this._animations) {
            if (!this._animations.hasOwnProperty(key)) {
                return;
            }
            isFinished = this._animations[key]();
            if (!isFinished) {
                allFinished = false;
            } else {
                toRemove.push(key);
            }
        }

        if (!allFinished) {
            requestAnimationFrame(this.tick);
        } else {
            for (index = 0; index < toRemove.length; toRemove++) {
                delete this._isAnimating[toRemove[index]];
            }
            this._isAnimating = false;
        }
    };

}(window.Animator.prototype));

window.Animator.getInstance = function () {
    if (!window.Animator._instance) {
        window.Animator._instance = new window.Animator();
    }
    return window.Animator._instance;
};

function Animatable(key, increment, update) {
    var ratio;
    var handles;

    handles = {
        animateUp: function () {
            Animator.getInstance().animate(key, tickUp);
        },
        animateDown: function () {
            Animator.getInstance().animate(key, tickDown);
        }
    };

    ratio = 0;

    function tickUp () {
        var isFinished;
        ratio += increment;
        if (ratio >= 1.0) {
            isFinished = true;
            ratio = 1;
        }
        update(ratio);
        return isFinished;
    };

    function tickDown () {
        var isFinished;
        ratio -= increment;
        if (ratio <= 0.0) {
            isFinished = true;
            ratio = 0;
        }
        update(ratio);
        return isFinished;
    };

    return handles;
};


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function() {
    'use strict';

    var VENDORS = ['ms', 'moz', 'webkit', 'o'];
    var index, lastTime;

    for (index = 0; index < VENDORS.length && !window.requestAnimationFrame; index++) {
        window.requestAnimationFrame = window[VENDORS[index] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[VENDORS[index] + 'CancelAnimationFrame'];
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = window[VENDORS[index] + 'CancelRequestAnimationFrame'];
        }
    }

    if (!window.requestAnimationFrame) {
        lastTime = 0;
        window.requestAnimationFrame = function(callback, element) {
            var currTime, timeToCall, id;

            currTime = new Date().getTime();
            timeToCall = Math.max(0, 16 - (currTime - lastTime));
            id = window.setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;

            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }

    Mobile.enable();
}());

</script>

<div style = "z-index: 2; background: transparent; position: absolute; top: 0.5em; right: 1em;">
    <img alt="mute" id="muteButton" width=32px height=32px onClick="muteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xOdTWsmQAAAIGSURBVFhH3ZchcsJAGIURiApEBbIH6BEqOQASWYHoESoQFcwgOAaiEsEBKip6BERlBQJRwQEqtu/tvj+TLMnAJpntTL+ZP/De7p/9k102YUCcc0tEbpbx4MHIAMcKQ2LM4ktmOCYH9gXIawXzQasLYGKnAphryErC53VJLiPvhNgjtog54tZ3bgDt7QpgTkyD/42Y+aQa2CG5APYvMdGnFTBC3COeEG8IY4M4uxtsSCqAfQ1ZhSdZATangdNCvhCVImheVQC6FFdKZHtkeQ8fB8QOsUCM5N0hPhBkQ8+gEQ5BXLUb+swSsu0cZXjFE/kswu7ElB6hCAeJS/isCDXZOcaIKeKdHvhBPKiN00F4l+zu1BaQtKkop1Ic5BCx8g3OfSJu5Fthj9LnBfB7Ckqzc/Dq1oihtA34LP0SpHuV7r0AYyXN6SC7SO+ley9gFpQ7SHNNkFifpP9fAcZaOvsUNC3ChbQtwq30eQGg88+QwLKNjRuS/e6toLl0bQGNsF+MmuwcdRuR7Ya2EfEJ6Z8JFOEQRK6tuHg8U4TDBdClr4eRn3uDRjhcCfsasgpPsgLs8uP4iBiryUMzqQDC/iXiFxJbA1zttg4IX9EqgxM2JBdAmBPT4Pf/SmYwr4y8PC+lBnMNWUn4vLbJBvNBtz8m4E//mtkGlK0IjhWG1Jj8EnRWMPhg8AvjeqPLyfe3igAAAABJRU5ErkJggg==" />
    <img alt="unmute" id="unMuteButton" width=32px height=32px onClick="unMuteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAABqElEQVRYR72XW3LDMAwDc7QerTdPRWjBoW1aedXZGUYUAIlqP9LpLbjf77+jvs3vfvgUvkDMmiPHzGxg9HTXEjNjsB6A0Nar+MxYg+UPFoH5ccLCauE+3Wmqvke+Pk5YWAl3sJuXGiSx3wfSOsMsrKRm4i6DJJAEktB+L1YW1oG4xyAJJIGUSOsMs7A2xB0GSSAJpA3Sz8xgYYnh/8R5g+ZKFG6Q9yAQ9dS3JEcEkkBqkb8K2X8EcYEkkE5RxkH6rkz7VT10uu3wwcbrcOipB+hEg62ZmlR9hbL1wEkJndgRMpVgif1+j3yH6LsSOtGALZAE0rUPwBJICfJ1D0A2ylamfDxXke8QfVfCGdak6pXpNkZBvkP0XeUl3hvkFiKfP8CwT5BPIfavD0iQBNJhEPJnDzCjr6Q31sMfI4P0/gPM6BP20ivTnSClxrZFvkP0WQ4YCQuImfzNYLfId4i+VqL0ExDfgNUi3yF6V6LkC3AsQW6R7xB9rZeHmzhrkFrkO0R/qHcZZ4Plv3sROARHv1mvImbG4GxixbucmDVHMjOauf8qY/jt9gdOODPsYZA1BAAAAABJRU5ErkJggg==" />
</div>

<script>const sourceCode="__GAMEDAT__";compile(["restart"],sourceCode);</script>
</body>
</html>
